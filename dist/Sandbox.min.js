const AsyncFunction=Object.getPrototypeOf(async function(){}).constructor,GeneratorFunction=Object.getPrototypeOf(function*(){}).constructor,AsyncGeneratorFunction=Object.getPrototypeOf(async function*(){}).constructor,SandboxGlobal=function(e){for(const t in e)this[t]=e[t]};class ExecContext{constructor(e,t,n,s,o,r,i,a,c,p,l,d){this.ctx=e,this.constants=t,this.tree=n,this.getSubscriptions=s,this.setSubscriptions=o,this.changeSubscriptions=r,this.setSubscriptionsGlobal=i,this.changeSubscriptionsGlobal=a,this.evals=c,this.registerSandboxFunction=p,this.allowJit=l,this.evalContext=d}}function createContext(e,t){const n=new SandboxGlobal(t.globals),s={sandbox:e,globalsWhitelist:new Set(Object.values(t.globals)),prototypeWhitelist:new Map([...t.prototypeWhitelist].map(e=>[e[0].prototype,e[1]])),options:t,globalScope:new Scope(null,t.globals,n),sandboxGlobal:n,ticks:{ticks:0n,tickLimit:t.executionQuota}};return s.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()),new Set),s}function createExecContext(sandbox,executionTree,evalContext){const evals=new Map,execContext=new ExecContext(sandbox.context,executionTree.constants,executionTree.tree,new Set,new WeakMap,new WeakMap,sandbox.setSubscriptions,sandbox.changeSubscriptions,evals,e=>sandbox.sandboxFunctions.set(e,execContext),!!evalContext,evalContext);if(evalContext){const func=evalContext.sandboxFunction(execContext),asyncFunc=evalContext.sandboxAsyncFunction(execContext);evals.set(Function,func),evals.set(AsyncFunction,asyncFunc),evals.set(GeneratorFunction,func),evals.set(AsyncGeneratorFunction,asyncFunc),evals.set(eval,evalContext.sandboxedEval(func)),evals.set(setTimeout,evalContext.sandboxedSetTimeout(func,execContext)),evals.set(setInterval,evalContext.sandboxedSetInterval(func,execContext)),evals.set(clearTimeout,evalContext.sandboxedClearTimeout(execContext)),evals.set(clearInterval,evalContext.sandboxedClearInterval(execContext));for(const[e,t]of evals)sandbox.context.prototypeWhitelist.set(t.prototype,new Set),sandbox.context.prototypeWhitelist.set(e.prototype,new Set)}return execContext}class CodeString{constructor(e){this.ref={str:""},e instanceof CodeString?(this.ref=e.ref,this.start=e.start,this.end=e.end):(this.ref.str=e,this.start=0,this.end=e.length)}substring(e,t){if(!this.length)return this;(e=this.start+e)<0&&(e=0),e>this.end&&(e=this.end),(t=void 0===t?this.end:this.start+t)<0&&(t=0),t>this.end&&(t=this.end);const n=new CodeString(this);return n.start=e,n.end=t,n}get length(){const e=this.end-this.start;return e<0?0:e}char(e){if(this.start!==this.end)return this.ref.str[this.start+e]}toString(){return this.ref.str.substring(this.start,this.end)}trimStart(){const e=/^\s+/.exec(this.toString()),t=new CodeString(this);return e&&(t.start+=e[0].length),t}slice(e,t){return e<0&&(e=this.end-this.start+e),e<0&&(e=0),void 0===t&&(t=this.end-this.start),t<0&&(t=this.end-this.start+t),t<0&&(t=0),this.substring(e,t)}trim(){const e=this.trimStart(),t=/\s+$/.exec(e.toString());return t&&(e.end-=t[0].length),e}valueOf(){return this.toString()}}function keysOnly(e){const t=Object.assign({},e);for(const e in t)t[e]=!0;return t}const reservedWords=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","enum","export","extends","false","finally","for","function","if","implements","import","in","instanceof","let","new","null","return","super","switch","this","throw","true","try","typeof","var","void","while","with"]);class Scope{constructor(e,t={},n){this.const={},this.let={},this.var={};const s=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=s?this.let:keysOnly(t),this.var=s?keysOnly(t):this.var,this.globals=null===e?keysOnly(t):{},this.functionThis=n}get(e){const t="this"===e,n=this.getWhereValScope(e,t);return n&&t?new Prop({this:n.functionThis},e,!1,!1,!0):n?new Prop(n.allVars,e,e in n.const,e in n.globals,!0):new Prop(void 0,e)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");const n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(null===n.context)throw new TypeError(`Cannot set properties of null, (setting '${e}')`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n.prop]=t,n}getWhereValScope(e,t){return t?void 0!==this.functionThis?this:this.parent?.getWhereValScope(e,t)||null:e in this.allVars?this:this.parent?.getWhereValScope(e,t)||null}getWhereVarScope(e,t=!1){return e in this.allVars||null===this.parent||t||void 0!==this.functionThis?this:this.parent.getWhereVarScope(e,t)}declare(e,t,n=void 0,s=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");const o=this.getWhereVarScope(e,"var"!==t);if("var"===t){if(o.var[e])return o.allVars[e]=n,s?o.globals[e]=!0:delete o.globals[e],new Prop(o.allVars,e,!1,o.globals[e],!0);if(e in o.allVars)throw new SyntaxError(`Identifier '${e}' has already been declared`)}if(e in o.allVars)throw new SyntaxError(`Identifier '${e}' has already been declared`);return s&&(o.globals[e]=!0),o[t][e]=!0,o.allVars[e]=n,new Prop(this.allVars,e,"const"===t,s,!0)}}class LocalScope{}class SandboxError extends Error{}class SandboxExecutionQuotaExceededError extends SandboxError{}class SandboxExecutionTreeError extends SandboxError{}class SandboxCapabilityError extends SandboxError{}class SandboxAccessError extends SandboxError{}function isLisp(e){return Array.isArray(e)&&"number"==typeof e[0]&&0!==e[0]&&88!==e[0]}class Prop{constructor(e,t,n=!1,s=!1,o=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=s,this.isVariable=o}get(e){const t=this.context;if(void 0===t)throw new ReferenceError(`${this.prop.toString()} is not defined`);if(null===t)throw new TypeError(`Cannot read properties of null, (reading '${this.prop.toString()}')`);return e.getSubscriptions.forEach(e=>e(t,this.prop.toString())),t[this.prop]}}function hasOwnProperty(e,t){return Object.prototype.hasOwnProperty.call(e,t)}class ExecReturn{constructor(e,t,n,s=!1,o=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=s,this.continueLoop=o}}const optional={};function generateArgs(e,t){const n={};return e.forEach((e,s)=>{e.startsWith("...")?n[e.substring(3)]=t.slice(s):n[e]=t[s]}),n}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,s,o,r){if(s.ctx.options.forbidFunctionCreation)throw new SandboxCapabilityError("Function creation is forbidden");let i;return i=void 0===r?(...r)=>{const i=generateArgs(e,r);return executeTree(n,s,t,void 0===o?[]:[new Scope(o,i)]).result}:function(...r){const i=generateArgs(e,r);return executeTree(n,s,t,void 0===o?[]:[new Scope(o,i,this)]).result},s.registerSandboxFunction(i),sandboxedFunctions.add(i),i}function createFunctionAsync(e,t,n,s,o,r){if(s.ctx.options.forbidFunctionCreation)throw new SandboxCapabilityError("Function creation is forbidden");if(!s.ctx.prototypeWhitelist?.has(Promise.prototype))throw new SandboxCapabilityError("Async/await not permitted");let i;return i=void 0===r?async(...r)=>{const i=generateArgs(e,r);return(await executeTreeAsync(n,s,t,void 0===o?[]:[new Scope(o,i)])).result}:async function(...r){const i=generateArgs(e,r);return(await executeTreeAsync(n,s,t,void 0===o?[]:[new Scope(o,i,this)])).result},s.registerSandboxFunction(i),sandboxedFunctions.add(i),i}function assignCheck(e,t,n="assign"){if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if(e.isConst)throw new TypeError("Assignment to constant variable.");if(e.isGlobal)throw new SandboxAccessError(`Cannot ${n} property '${e.prop.toString()}' of a global object`);if(null===e.context)throw new TypeError("Cannot set properties of null");if("function"==typeof e.context[e.prop]&&!hasOwnProperty(e.context,e.prop))throw new SandboxAccessError(`Override prototype property '${e.prop.toString()}' not allowed`);"delete"===n?hasOwnProperty(e.context,e.prop)&&(t.changeSubscriptions.get(e.context)?.forEach(t=>t({type:"delete",prop:e.prop.toString()})),t.changeSubscriptionsGlobal.get(e.context)?.forEach(t=>t({type:"delete",prop:e.prop.toString()}))):hasOwnProperty(e.context,e.prop)?(t.setSubscriptions.get(e.context)?.get(e.prop.toString())?.forEach(e=>e({type:"replace"})),t.setSubscriptionsGlobal.get(e.context)?.get(e.prop.toString())?.forEach(e=>e({type:"replace"}))):(t.changeSubscriptions.get(e.context)?.forEach(t=>t({type:"create",prop:e.prop.toString()})),t.changeSubscriptionsGlobal.get(e.context)?.forEach(t=>t({type:"create",prop:e.prop.toString()})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]);class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}class If{constructor(e,t){this.t=e,this.f=t}}const literalRegex=/(\$\$)*(\$)?\${(\d+)}/g,ops=new Map;function addOps(e,t){ops.set(e,t)}function isPropertyKey(e){return["string","number","symbol"].includes(typeof e)}function hasPossibleProperties(e){return null!=e}function valueOrProp(e,t){return e instanceof Prop?e.get(t):e!==optional?e:void 0}function execMany(e,t,n,s,o,r,i){t===execSync?_execManySync(e,n,s,o,r,i):_execManyAsync(e,n,s,o,r,i).catch(s)}function _execManySync(e,t,n,s,o,r){const i=[];for(let a=0;a<t.length;a++){let c;try{c=syncDone(n=>execSync(e,t[a],s,o,n,r)).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);if(isLisp(t[a])&&8===t[a][0])return void n(void 0,new ExecReturn(o.ctx.auditReport,c,!0));i.push(c)}n(void 0,i)}async function _execManyAsync(e,t,n,s,o,r){const i=[];for(let a=0;a<t.length;a++){let c;try{let n;c=!0===(n=asyncDone(n=>execAsync(e,t[a],s,o,n,r))).isInstant?n.instant:(await n.p).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);if(isLisp(t[a])&&8===t[a][0])return void n(void 0,new ExecReturn(o.ctx.auditReport,c,!0));i.push(c)}n(void 0,i)}function asyncDone(e){let t,n=!1;const s=new Promise((s,o)=>{e((e,r)=>{e?o(e):(n=!0,t=r,s({result:r}))})});return{isInstant:n,instant:t,p:s}}function syncDone(e){let t,n;if(e((e,s)=>{n=e,t=s}),n)throw n;return{result:t}}async function execAsync(e,t,n,s,o,r){let i=o;const a=new Promise(e=>{i=(t,n)=>{o(t,n),e()}});if(!_execNoneRecurse(e,t,n,s,i,!0,r)&&isLisp(t)){let o,a=t[0];try{let i;o=!0===(i=asyncDone(o=>execAsync(e,t[1],n,s,o,r))).isInstant?i.instant:(await i.p).result}catch(e){return void i(e)}let c,p=o;try{p=o instanceof Prop?o.get(s):o}catch(e){return void i(e)}if(20===a||21===a){if(null==p)return void i(void 0,optional);a=20===a?1:5}if(p===optional){if(1===a||5===a)return void i(void 0,p);p=void 0}if(89===a&&null!=p)return void i(void 0,p);try{let o;c=!0===(o=asyncDone(o=>execAsync(e,t[2],n,s,o,r))).isInstant?o.instant:(await o.p).result}catch(e){return void i(e)}let l=c;try{l=c instanceof Prop?c.get(s):c}catch(e){return void i(e)}l===optional&&(l=void 0),performOp({op:a,exec:execAsync,done:i,ticks:e,a:p,b:l,obj:o,context:s,scope:n,bobj:c,inLoopOrSwitch:r,tree:t})}await a}function execSync(e,t,n,s,o,r){if(!_execNoneRecurse(e,t,n,s,o,!1,r)&&isLisp(t)){let i,a=t[0];try{i=syncDone(o=>execSync(e,t[1],n,s,o,r)).result}catch(e){return void o(e)}let c,p=i;try{p=i instanceof Prop?i.get(s):i}catch(e){return void o(e)}if(20===a||21===a){if(null==p)return void o(void 0,optional);a=20===a?1:5}if(p===optional){if(1===a||5===a)return void o(void 0,p);p=void 0}if(89===a&&null!=p)return void o(void 0,p);try{c=syncDone(o=>execSync(e,t[2],n,s,o,r)).result}catch(e){return void o(e)}let l=c;try{l=c instanceof Prop?c.get(s):c}catch(e){return void o(e)}l===optional&&(l=void 0),performOp({op:a,exec:execSync,done:o,ticks:e,a:p,b:l,obj:i,context:s,scope:n,bobj:c,inLoopOrSwitch:r,tree:t})}}async function checkHaltAsync(e,t){if(!(t instanceof Promise))return t;let n,s,o=!1,r=e.ctx.sandbox.halted,i=()=>{};const a=new Promise(t=>{i=()=>{s.unsubscribe(),n.unsubscribe(),t()},s=e.ctx.sandbox.subscribeHalt(()=>{r=!0}),n=e.ctx.sandbox.subscribeResume(()=>{r=!1,o&&i()})});return t.finally(()=>{o=!0,r||i()}),await Promise.allSettled([t,a]),t}function checkHaltExpectedTicks(e,t=0){const n=e.context.ctx.sandbox,s=e.context.ctx.options,{ticks:o,scope:r,context:i,done:a,op:c}=e;if(n.halted){const t=n.subscribeResume(()=>{t.unsubscribe();try{const t=ops.get(c);if(!t)return void a(new SyntaxError("Unknown operator: "+c));t(e)}catch(e){if(s.haltOnSandboxError&&e instanceof SandboxError){const t=n.subscribeResume(()=>{t.unsubscribe(),a(e)});n.haltExecution({error:e,ticks:o,scope:r,context:i})}else a(e)}});return!0}if(o.tickLimit&&o.tickLimit<=o.ticks+BigInt(t)){const t=n.subscribeResume(()=>{t.unsubscribe();try{const t=ops.get(c);if(!t)return void a(new SyntaxError("Unknown operator: "+c));t(e)}catch(e){if(i.ctx.options.haltOnSandboxError&&e instanceof SandboxError){const t=n.subscribeResume(()=>{t.unsubscribe(),a(e)});n.haltExecution({error:e,ticks:o,scope:r,context:i})}else a(e)}}),s=new SandboxExecutionQuotaExceededError("Execution quota exceeded");return n.haltExecution({error:s,ticks:o,scope:r,context:i}),!0}return!1}function performOp(e){const{done:t,op:n,ticks:s,context:o,scope:r}=e;s.ticks++;const i=o.ctx.sandbox;if(!checkHaltExpectedTicks(e))try{const s=ops.get(n);if(!s)return void t(new SandboxExecutionTreeError("Unknown operator: "+n));s(e)}catch(e){if(o.ctx.options.haltOnSandboxError&&e instanceof SandboxError){const n=i.subscribeResume(()=>{n.unsubscribe(),t(e)});i.haltExecution({error:e,ticks:s,scope:r,context:o})}else t(e)}}addOps(1,({done:e,a:t,b:n,obj:s,context:o,scope:r})=>{if(null===t)throw new TypeError(`Cannot read properties of null (reading '${n?.toString()}')`);if(!isPropertyKey(n))try{n=`${n}`}catch(a){return void e(a)}if(void 0===t&&void 0===s&&"string"==typeof n){const t=r.get(n);t.context===o.ctx.sandboxGlobal&&o.ctx.options.audit&&o.ctx.auditReport?.globalsAccess.add(n);const s=t.context?t.context[t.prop]:void 0;if(s===globalThis)return void e(void 0,new Prop({[t.prop]:o.ctx.sandboxGlobal},t.prop,t.isConst,!1,t.isVariable));const i="function"==typeof s&&o.evals.get(s);return i?void e(void 0,new Prop({[t.prop]:i},t.prop,t.isConst,!0,t.isVariable)):void e(void 0,t)}if(void 0===t)throw new TypeError(`Cannot read properties of undefined (reading '${n.toString()}')`);if(!hasPossibleProperties(t))return void e(void 0,new Prop(void 0,n));const i="function"==typeof t||!hasOwnProperty(t,n);if(o.ctx.options.audit&&i){let e=Object.getPrototypeOf(t);do{hasOwnProperty(e,n)&&(o.ctx.auditReport&&!o.ctx.auditReport.prototypeAccess[e.constructor.name]&&(o.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),o.ctx.auditReport?.prototypeAccess[e.constructor.name].add(n))}while(e=Object.getPrototypeOf(e))}if(i){if("function"==typeof t&&hasOwnProperty(t,n)){const s=o.ctx.prototypeWhitelist.get(t.prototype),r=o.ctx.options.prototypeReplacements.get(t);if(r)return void e(void 0,new Prop(r(t,!0),n));if(!s||s.size&&!s.has(n))throw new SandboxAccessError(`Static method or property access not permitted: ${t.name}.${n.toString()}`)}let s=t;for(;s=Object.getPrototypeOf(s);)if(hasOwnProperty(s,n)){const r=o.ctx.prototypeWhitelist.get(s),i=o.ctx.options.prototypeReplacements.get(s.constructor);if(i)return void e(void 0,new Prop(i(t,!1),n));if(r&&(!r.size||r.has(n)))break;throw new SandboxAccessError(`Method or property access not permitted: ${s.constructor.name}.${n.toString()}`)}}const a="function"==typeof t[n]&&o.evals.get(t[n]);if(a)return void e(void 0,new Prop({[n]:a},n,!1,!0,!1));if(t[n]===globalThis)return void e(void 0,new Prop({[n]:o.ctx.sandboxGlobal},n,!1,!1,!1));const c=s instanceof Prop&&s.isGlobal||"function"==typeof t&&!sandboxedFunctions.has(t)||o.ctx.globalsWhitelist.has(t);e(void 0,new Prop(t,n,!1,c,!1))}),addOps(5,({done:e,a:t,b:n,obj:s,context:o})=>{if(o.ctx.options.forbidFunctionCalls)throw new SandboxCapabilityError("Function invocations are not allowed");if("function"!=typeof t)throw new TypeError(`${"symbol"==typeof s.prop?"Symbol":s.prop} is not a function`);const r=n.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat().map(e=>valueOrProp(e,o));if("function"==typeof s){let t=s(...r);return t instanceof Promise&&(t=checkHaltAsync(o,t)),void e(void 0,t)}if(s.context[s.prop]===JSON.stringify&&o.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(const e of Object.keys(n))o.getSubscriptions.forEach(t=>t(n,e)),t(n[e])}};t(r[0])}if(s.context instanceof Array&&arrayChange.has(s.context[s.prop])&&(o.changeSubscriptions.get(s.context)||o.changeSubscriptionsGlobal.get(s.context))){let e,t=!1;if("push"===s.prop)e={type:"push",added:r},t=!!r.length;else if("pop"===s.prop)e={type:"pop",removed:s.context.slice(-1)},t=!!e.removed.length;else if("shift"===s.prop)e={type:"shift",removed:s.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===s.prop)e={type:"unshift",added:r},t=!!r.length;else if("splice"===s.prop)e={type:"splice",startIndex:r[0],deleteCount:void 0===r[1]?s.context.length:r[1],added:r.slice(2),removed:s.context.slice(r[0],void 0===r[1]?void 0:r[0]+r[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===s.prop||"sort"===s.prop)e={type:s.prop},t=!!s.context.length;else if("copyWithin"===s.prop){const n=void 0===r[2]?s.context.length-r[1]:Math.min(s.context.length,r[2]-r[1]);e={type:"copyWithin",startIndex:r[0],endIndex:r[0]+n,added:s.context.slice(r[1],r[1]+n),removed:s.context.slice(r[0],r[0]+n)},t=!!e.added.length||!!e.removed.length}t&&(o.changeSubscriptions.get(s.context)?.forEach(t=>t(e)),o.changeSubscriptionsGlobal.get(s.context)?.forEach(t=>t(e)))}s.get(o);let i=s.context[s.prop](...r);"function"==typeof i&&(i=o.evals.get(i)||i),i===globalThis&&(i=o.ctx.sandboxGlobal),i instanceof Promise&&(i=checkHaltAsync(o,i)),e(void 0,i)}),addOps(22,({done:e,b:t})=>{let n={};for(const e of t)e.key instanceof SpreadObject?n={...n,...e.key.item}:n[e.key]=e.val;e(void 0,n)}),addOps(6,({done:e,a:t,b:n})=>e(void 0,new KeyVal(t,n))),addOps(12,({done:e,b:t,context:n})=>{e(void 0,t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat().map(e=>valueOrProp(e,n)))}),addOps(23,({done:e,b:t})=>e(void 0,t)),addOps(35,({done:e,b:t})=>{switch(t){case"true":return e(void 0,!0);case"false":return e(void 0,!1);case"null":return e(void 0,null);case"undefined":return e(void 0,void 0);case"NaN":return e(void 0,NaN);case"Infinity":return e(void 0,1/0)}e(new Error("Unknown symbol: "+t))}),addOps(7,({done:e,b:t})=>e(void 0,Number(t.replace(/_/g,"")))),addOps(83,({done:e,b:t})=>e(void 0,BigInt(t.replace(/_/g,"")))),addOps(2,({done:e,b:t,context:n})=>e(void 0,n.constants.strings[parseInt(t)])),addOps(85,({done:e,b:t,context:n})=>{const s=n.constants.regexes[parseInt(t)];if(!n.ctx.globalsWhitelist.has(RegExp))throw new SandboxCapabilityError("Regex not permitted");e(void 0,new RegExp(s.regex,s.flags))}),addOps(84,({exec:e,done:t,ticks:n,b:s,context:o,scope:r})=>{const i=o.constants.literals[parseInt(s)],[,a,c]=i,p=[];let l;const d=[];for(;l=literalRegex.exec(a);)l[2]||(p.push(c[parseInt(l[3],10)]),d.push(l[3]));e(n,p,r,o,(e,n)=>{const s={};if(e)t(e);else{for(const e of Object.keys(n)){const t=d[e];s[t]=n[e]}t(void 0,a.replace(/(\\\\)*(\\)?\${(\d+)}/g,(e,t,n,r)=>{if(n)return e;return(t||"")+`${valueOrProp(s[r],o)}`}))}})}),addOps(18,({done:e,b:t})=>{e(void 0,new SpreadArray(t))}),addOps(17,({done:e,b:t})=>{e(void 0,new SpreadObject(t))}),addOps(24,({done:e,b:t})=>e(void 0,!t)),addOps(64,({done:e,b:t})=>e(void 0,~t)),addOps(25,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,++t.context[t.prop])}),addOps(26,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,t.context[t.prop]++)}),addOps(27,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,--t.context[t.prop])}),addOps(28,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,t.context[t.prop]--)}),addOps(9,({done:e,b:t,obj:n,context:s,scope:o,bobj:r})=>{if(assignCheck(n,s),n.isGlobal=r?.isGlobal||!1,n.isVariable){const s=o.getWhereValScope(n.prop,"this"===n.prop);if(null===s)throw new ReferenceError(`Cannot assign to undeclared variable '${n.prop.toString()}'`);return s.set(n.prop,t),n.isGlobal?s.globals[n.prop.toString()]=!0:delete s.globals[n.prop.toString()],void e(void 0,t)}e(void 0,n.context[n.prop]=t)}),addOps(66,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]+=t)}),addOps(65,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]-=t)}),addOps(67,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]/=t)}),addOps(69,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]*=t)}),addOps(68,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]**=t)}),addOps(70,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]%=t)}),addOps(71,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]^=t)}),addOps(72,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]&=t)}),addOps(73,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]|=t)}),addOps(76,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]<<=t)}),addOps(75,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]>>=t)}),addOps(74,({done:e,b:t,obj:n,context:s})=>{assignCheck(n,s),e(void 0,n.context[n.prop]>>>=t)}),addOps(57,({done:e,a:t,b:n})=>e(void 0,t>n)),addOps(56,({done:e,a:t,b:n})=>e(void 0,t<n)),addOps(55,({done:e,a:t,b:n})=>e(void 0,t>=n)),addOps(54,({done:e,a:t,b:n})=>e(void 0,t<=n)),addOps(52,({done:e,a:t,b:n})=>e(void 0,t==n)),addOps(32,({done:e,a:t,b:n})=>e(void 0,t===n)),addOps(53,({done:e,a:t,b:n})=>e(void 0,t!=n)),addOps(31,({done:e,a:t,b:n})=>e(void 0,t!==n)),addOps(29,({done:e,a:t,b:n})=>e(void 0,t&&n)),addOps(30,({done:e,a:t,b:n})=>e(void 0,t||n)),addOps(89,({done:e,a:t,b:n})=>e(void 0,t??n)),addOps(77,({done:e,a:t,b:n})=>e(void 0,t&n)),addOps(78,({done:e,a:t,b:n})=>e(void 0,t|n)),addOps(33,({done:e,a:t,b:n})=>e(void 0,t+n)),addOps(47,({done:e,a:t,b:n})=>e(void 0,t-n)),addOps(59,({done:e,b:t})=>e(void 0,+t)),addOps(58,({done:e,b:t})=>e(void 0,-t)),addOps(48,({done:e,a:t,b:n})=>e(void 0,t/n)),addOps(49,({done:e,a:t,b:n})=>e(void 0,t**n)),addOps(79,({done:e,a:t,b:n})=>e(void 0,t^n)),addOps(50,({done:e,a:t,b:n})=>e(void 0,t*n)),addOps(51,({done:e,a:t,b:n})=>e(void 0,t%n)),addOps(80,({done:e,a:t,b:n})=>e(void 0,t<<n)),addOps(81,({done:e,a:t,b:n})=>e(void 0,t>>n)),addOps(82,({done:e,a:t,b:n})=>e(void 0,t>>>n)),addOps(60,({exec:e,done:t,ticks:n,b:s,context:o,scope:r})=>{e(n,s,r,o,(e,n)=>{t(void 0,typeof valueOrProp(n,o))})}),addOps(62,({done:e,a:t,b:n})=>e(void 0,t instanceof n)),addOps(63,({done:e,a:t,b:n})=>e(void 0,t in n)),addOps(61,({done:e,context:t,bobj:n})=>{n instanceof Prop?(assignCheck(n,t,"delete"),n.isVariable?e(void 0,!1):e(void 0,delete n.context?.[n.prop])):e(void 0,!0)}),addOps(8,({done:e,b:t})=>e(void 0,t)),addOps(34,({done:e,a:t,b:n,scope:s,bobj:o})=>{e(void 0,s.declare(t,"var",n,o?.isGlobal||!1))}),addOps(3,({done:e,a:t,b:n,scope:s,bobj:o})=>{e(void 0,s.declare(t,"let",n,o?.isGlobal||!1))}),addOps(4,({done:e,a:t,b:n,scope:s,bobj:o})=>{e(void 0,s.declare(t,"const",n,o?.isGlobal||!1))}),addOps(11,({done:e,ticks:t,a:n,b:s,obj:o,context:r,scope:i})=>{if(n=[...n],"string"==typeof o[2]||o[2]instanceof CodeString){if(!r.allowJit||!r.evalContext)throw new SandboxCapabilityError("Unevaluated code detected, JIT not allowed");o[2]=s=r.evalContext.lispifyFunction(new CodeString(o[2]),r.constants)}n.shift()?e(void 0,createFunctionAsync(n,s,t,r,i)):e(void 0,createFunction(n,s,t,r,i))}),addOps(37,({done:e,ticks:t,a:n,b:s,obj:o,context:r,scope:i})=>{if("string"==typeof o[2]||o[2]instanceof CodeString){if(!r.allowJit||!r.evalContext)throw new SandboxCapabilityError("Unevaluated code detected, JIT not allowed");o[2]=s=r.evalContext.lispifyFunction(new CodeString(o[2]),r.constants)}const a=n.shift(),c=n.shift();let p;p=88===a?createFunctionAsync(n,s,t,r,i,c):createFunction(n,s,t,r,i,c),c&&i.declare(c,"var",p),e(void 0,p)}),addOps(10,({done:e,ticks:t,a:n,b:s,obj:o,context:r,scope:i})=>{if("string"==typeof o[2]||o[2]instanceof CodeString){if(!r.allowJit||!r.evalContext)throw new SandboxCapabilityError("Unevaluated code detected, JIT not allowed");o[2]=s=r.evalContext.lispifyFunction(new CodeString(o[2]),r.constants)}const a=n.shift(),c=n.shift();let p;c&&(i=new Scope(i,{})),p=88===a?createFunctionAsync(n,s,t,r,i,c):createFunction(n,s,t,r,i,c),c&&i.declare(c,"let",p),e(void 0,p)}),addOps(38,({exec:e,done:t,ticks:n,a:s,b:o,context:r,scope:i})=>{const[a,c,p,l,d,u,f]=s;let x=!0;const h=new Scope(i,{}),b={$$obj:void 0},g=new Scope(h,b);if(e===execAsync)(async()=>{let s;for(s=asyncDone(t=>e(n,l,h,r,t)),b.$$obj=!0===(s=asyncDone(t=>e(n,p,h,r,t))).isInstant?s.instant:(await s.p).result,s=asyncDone(t=>e(n,c,g,r,t)),a&&(x=!0===(s=asyncDone(t=>e(n,u,g,r,t))).isInstant?s.instant:(await s.p).result);x;){const i={};s=asyncDone(t=>e(n,f,new Scope(g,i),r,t)),!0===s.isInstant?s.instant:(await s.p).result;const a=await executeTreeAsync(n,r,o,[new Scope(h,i)],"loop");if(a instanceof ExecReturn&&a.returned)return void t(void 0,a);if(a instanceof ExecReturn&&a.breakLoop)break;s=asyncDone(t=>e(n,d,g,r,t)),x=!0===(s=asyncDone(t=>e(n,u,g,r,t))).isInstant?s.instant:(await s.p).result}t()})().catch(t);else{for(syncDone(t=>e(n,l,h,r,t)),b.$$obj=syncDone(t=>e(n,p,h,r,t)).result,syncDone(t=>e(n,c,g,r,t)),a&&(x=syncDone(t=>e(n,u,g,r,t)).result);x;){const s={};syncDone(t=>e(n,f,new Scope(g,s),r,t));const i=executeTree(n,r,o,[new Scope(h,s)],"loop");if(i instanceof ExecReturn&&i.returned)return void t(void 0,i);if(i instanceof ExecReturn&&i.breakLoop)break;syncDone(t=>e(n,d,g,r,t)),x=syncDone(t=>e(n,u,g,r,t)).result}t()}}),addOps(86,({done:e,a:t,context:n,inLoopOrSwitch:s})=>{if("switch"===s&&"continue"===t||!s)throw new TypeError("Illegal "+t+" statement");e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1,"break"===t,"continue"===t))}),addOps(13,({exec:e,done:t,ticks:n,a:s,b:o,context:r,scope:i,inLoopOrSwitch:a})=>{e(n,valueOrProp(s,r)?o.t:o.f,i,r,t,a)}),addOps(15,({exec:e,done:t,ticks:n,a:s,b:o,context:r,scope:i})=>{e(n,valueOrProp(s,r)?o.t:o.f,i,r,t,void 0)}),addOps(16,({done:e,a:t,b:n})=>e(void 0,new If(t,n))),addOps(14,({done:e,a:t,b:n})=>e(void 0,new If(t,n))),addOps(40,({exec:e,done:t,ticks:n,a:s,b:o,context:r,scope:i})=>{e(n,s,i,r,(s,a)=>{if(s)t(s);else if(a=valueOrProp(a,r),e===execSync){let s,c=!1;for(const p of o)if(c||(c=!p[1]||a===valueOrProp(syncDone(t=>e(n,p[1],i,r,t)).result,r))){if(!p[2])continue;if(s=executeTree(n,r,p[2],[i],"switch"),s.breakLoop)break;if(s.returned)return void t(void 0,s);if(!p[1])break}t()}else(async()=>{let s,c=!1;for(const p of o){let o;if(c||(c=!p[1]||a===valueOrProp(!0===(o=asyncDone(t=>e(n,p[1],i,r,t))).isInstant?o.instant:(await o.p).result,r))){if(!p[2])continue;if(s=await executeTreeAsync(n,r,p[2],[i],"switch"),s.breakLoop)break;if(s.returned)return void t(void 0,s);if(!p[1])break}}t()})().catch(t)})}),addOps(39,({exec:e,done:t,ticks:n,a:s,b:o,context:r,scope:i,inLoopOrSwitch:a})=>{const[c,p,l]=o;executeTreeWithDone(e,(s,o)=>{executeTreeWithDone(e,c=>{c?t(c):s?executeTreeWithDone(e,t,n,r,p,[new Scope(i)],a):t(void 0,o)},n,r,l,[new Scope(i,{})])},n,r,s,[new Scope(i)],a)}),addOps(87,({done:e})=>{e()}),addOps(45,({done:e,a:t,b:n,context:s})=>{if(!s.ctx.globalsWhitelist.has(t)&&!sandboxedFunctions.has(t))throw new SandboxAccessError(`Object construction not allowed: ${t.constructor.name}`);e(void 0,new t(...n))}),addOps(46,({done:e,b:t})=>{e(t)}),addOps(43,({done:e,a:t})=>e(void 0,t.pop())),addOps(0,({done:e})=>e());const unexecTypes=new Set([11,37,10,38,39,40,14,16,60]),currentTicks={current:{ticks:BigInt(0)}};function _execNoneRecurse(e,t,n,s,o,r,i){const a=r?execAsync:execSync;if(currentTicks.current=e,t instanceof Prop)try{o(void 0,t.get(s))}catch(e){o(e)}else if(t===optional)o();else if(Array.isArray(t)&&!isLisp(t))0===t[0]?o():execMany(e,a,t,o,n,s,i);else if(isLisp(t))if(42===t[0])execMany(e,a,t[1],o,n,s,i);else if(44===t[0])r?s.ctx.prototypeWhitelist?.has(Promise.prototype)?execAsync(e,t[1],n,s,async(e,t)=>{if(e)o(e);else try{o(void 0,await valueOrProp(t,s))}catch(e){o(e)}},i).catch(o):o(new SandboxCapabilityError("Async/await is not permitted")):o(new SyntaxError("Illegal use of 'await', must be inside async function"));else{if(!unexecTypes.has(t[0]))return!1;performOp({op:t[0],exec:a,done:o,ticks:e,a:t[1],b:t[2],obj:t,tree:t,context:s,scope:n,bobj:void 0,inLoopOrSwitch:i})}else o(void 0,t);return!0}function executeTree(e,t,n,s=[],o){return syncDone(r=>executeTreeWithDone(execSync,r,e,t,n,s,o)).result}async function executeTreeAsync(e,t,n,s=[],o){let r;return!0===(r=asyncDone(r=>executeTreeWithDone(execAsync,r,e,t,n,s,o))).isInstant?r.instant:(await r.p).result}function executeTreeWithDone(e,t,n,s,o,r=[],i){if(!o)return void t();if(!(o instanceof Array))throw new SyntaxError("Bad execution tree");let a,c=s.ctx.globalScope;for(;a=r.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,a instanceof LocalScope?void 0:null));s.ctx.options.audit&&!s.ctx.auditReport&&(s.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,s,o,c,i):_executeWithDoneAsync(t,n,s,o,c,i).catch(t)}function _executeWithDoneSync(e,t,n,s,o,r){if(!(s instanceof Array))throw new SyntaxError("Bad execution tree");let i=0;for(i=0;i<s.length;i++){let a,c;const p=s[i];try{execSync(t,p,o,n,(e,t)=>{c=e,a=t},r)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(isLisp(p)&&8===p[0])return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,s,o,r){if(!(s instanceof Array))throw new SyntaxError("Bad execution tree");let i=0;for(i=0;i<s.length;i++){let a,c;const p=s[i];try{await execAsync(t,p,o,n,(e,t)=>{c=e,a=t},r)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(isLisp(p)&&8===p[0])return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}function parseHexToInt(e){return!e.match(/[^a-f0-9]/i)?parseInt(e,16):NaN}function validateAndParseHex(e,t,n){const s=parseHexToInt(e);if(Number.isNaN(s)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return s}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,function(e,t,n,s,o,r,i,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==s)return parseUnicodeCodePointCode(s);if(void 0!==o)return parseUnicodeCode(o,r);if(void 0!==i)return parseUnicodeCode(i);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")})}function createLisp(e){return[e.op,e.a,e.b]}const NullLisp=createLisp({op:0,a:0,b:0}),lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e+": "+t.substring(0,40)),this.code=t}}let lastType;const inlineIfElse=/^:/,elseIf=/^else(?![\w$])/,ifElse=/^if(?![\w$])/,space=/^\s/,expectTypes={splitter:{types:{opHigh:/^(\/|\*\*|\*(?!\*)|%)(?!=)/,op:/^(\+(?!(\+))|-(?!(-)))(?!=)/,comparitor:/^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!=)|===|==)/,bitwiseShift:/^(<<|>>(?!>)|>>>)(?!=)/,bitwiseAnd:/^(&(?!&))(?!=)/,bitwiseXor:/^(\^)(?!=)/,bitwiseOr:/^(\|(?!\|))(?!=)/,boolOpAnd:/^(&&)/,boolOpOr:/^(\|\||instanceof(?![\w$])|in(?![\w$]))/,nullishCoalescing:/^\?\?/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?(?!\.(?!\d))/},next:["expEnd"]},assignment:{types:{assignModify:/^(-=|\+=|\/=|\*\*=|\*=|%=|\^=|&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|--)/},next:["prop"]},expEdge:{types:{call:/^(\?\.)?[(]/,incrementerAfter:/^(\+\+|--)/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^-(?!-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w$])/,delete:/^delete(?![\w$])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^(\?\.)?\[/,dot:/^(\?)?\.(?=\s*[a-zA-Z$_])/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},prop:{types:{prop:/^[a-zA-Z$_][a-zA-Z\d$_]*/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0b[01]+(_[01]+)*|0o[0-7]+(_[0-7]+)*|0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[+-]?\d+(_\d+)*)?(n)?(?!\d)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w$])/,boolean:/^(true|false)(?![\w$])/,null:/^null(?![\w$])/,und:/^undefined(?![\w$])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z$_][a-zA-Z\d$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z$_][a-zA-Z\d$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w$])/,Infinity:/^Infinity(?![\w$])/,void:/^void(?![\w$])\s*/,await:/^await(?![\w$])\s*/,new:/^new(?![\w$])\s*/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z$_][a-zA-Z\d$_]*)\s*(=)?/,return:/^return(?![\w$])/,throw:/^throw(?![\w$])\s*/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expFunction:{types:{function:/^(async\s+)?function(\s*[a-zA-Z$_][a-zA-Z\d$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*{/},next:["expEdge","expEnd"]},expSingle:{types:{for:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*do(?![\w$])\s*(\{)?/,while:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w$])\s*([a-zA-Z$_][\w$]*)?/,if:/^((([a-zA-Z$_][\w$]*)\s*:)?\s*)if\s*\(/,try:/^try\s*{/,block:/^{/,switch:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};function testMultiple(e,t){let n=null;for(let s=0;s<t.length;s++){if(n=t[s].exec(e),n)break}return n}const emptyString=new CodeString(""),okFirstChars=/^[+\-~ !]/,aNumber=expectTypes.value.types.number,wordReg=/^((if|for|else|while|do|function)(?![\w$])|[\w$]+)/,semiColon=/^;/,insertedSemicolons=new WeakMap,quoteCache=new WeakMap;function restOfExp(e,t,n,s,o,r,i={}){if(!t.length)return t;i.words=i.words||[];let a=!0;const c=(n=n||[]).includes(semiColon);c&&(n=n.filter(e=>e!==semiColon));const p=insertedSemicolons.get(t.ref)||[],l=quoteCache.get(t.ref)||new Map;if(quoteCache.set(t.ref,l),s&&l.has(t.start-1))return t.substring(0,l.get(t.start-1)-t.start);let d,u=!1,f=!1,x="",h=!1,b=!1;for(d=0;d<t.length&&!f;d++){let g=t.char(d);if('"'===s||"'"===s||"`"===s){if("`"!==s||"$"!==g||"{"!==t.char(d+1)||u){if(g===s&&!u)return t.substring(0,d)}else{d+=restOfExp(e,t.substring(d+2),[],"{").length+2}u=!u&&"\\"===g}else if(closings[g]){if(!b&&p[d+t.start]){if(b=!0,c)break;d--,x=";";continue}if(h&&"{"===g&&(h=!1),g===o){f=!0;break}{const n=restOfExp(e,t.substring(d+1),[],g);if(l.set(n.start-1,n.end),d+=n.length+1,a=!1,r){let e;(e=testMultiple(t.substring(d).toString(),r))&&(i.regRes=e,f=!0)}}}else if(s){if(g===closings[s])return t.substring(0,d)}else{let e,s,o=t.substring(d).toString();if(r){let e;if(e=testMultiple(o,r)){i.regRes=e,d++,f=!0;break}}if(s=aNumber.exec(o))d+=s[0].length-1,o=t.substring(d).toString();else if(x!=g){let s=null;if(";"===g||p[d+t.start]&&!a&&!b){if(c)s=[";"];else if(p[d+t.start]){b=!0,d--,x=";";continue}g=o=";"}else b=!1;s||(s=testMultiple(o,n)),s&&(f=!0),!f&&(e=wordReg.exec(o))&&(h=!0,e[0].length>1&&(i.words.push(e[1]),i.lastAnyWord=e[1],e[2]&&(i.lastWord=e[2])),e[0].length>2&&(d+=e[0].length-2))}if(a&&(okFirstChars.test(o)?f=!1:a=!1),f)break}x=g}if(s)throw new SyntaxError("Unclosed '"+s+"'");return i&&(i.oneliner=h),t.substring(0,d)}restOfExp.next=["splitter","expEnd","inlineIf"];const startingExecpted=["initialize","expSingle","expFunction","value","modifier","prop","incrementerBefore","expEnd"],setLispType=(e,t)=>{e.forEach(e=>{lispTypes.set(e,t)})},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/},typesCreate={createArray:12,createObject:22,group:23,arrayProp:19,call:5,prop:1,"?prop":20,"?call":21};setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,n,s,o,r)=>{let i=emptyString;const a=[];let c=!1,p=s[0].length;const l=p;for(;p<n.length&&!c;)i=restOfExp(e,n.substring(p),[closingsCreate[t],/^,/]),p+=i.length,i.trim().length&&a.push(i),","!==n.char(p)?c=!0:p++;const d=["value","modifier","prop","incrementerBefore","expEnd"];let u,f;switch(t){case"group":case"arrayProp":u=lispifyExpr(e,n.substring(l,p));break;case"call":case"createArray":u=a.map(t=>lispify(e,t,[...d,"spreadArray"]));break;case"createObject":u=a.map(t=>{let n;t=t.trimStart();let s="";if(f=expectTypes.expFunction.types.function.exec("function "+t),f)s=f[2].trimStart(),n=lispify(e,new CodeString("function "+t.toString().replace(s,"")));else{const o=restOfExp(e,t,[/^:/]);s=lispify(e,o,[...d,"spreadObject"]),1===s[0]&&(s=s[2]),n=lispify(e,t.substring(o.length+1))}return createLisp({op:6,a:s,b:n})})}const x="arrayProp"===t?s[1]?20:1:"call"===t?s[1]?21:5:typesCreate[t];r.lispTree=lispify(e,n.substring(p+1),expectTypes[o].next,createLisp({op:x,a:r.lispTree,b:u}))});const modifierTypes={inverse:64,not:24,positive:59,negative:58,typeof:60,delete:61};setLispType(["inverse","not","negative","positive","typeof","delete"],(e,t,n,s,o,r)=>{const i=restOfExp(e,n.substring(s[0].length),[/^([^\s.?\w$]|\?[^.])/]);r.lispTree=lispify(e,n.substring(i.length+s[0].length),restOfExp.next,createLisp({op:modifierTypes[t],a:r.lispTree,b:lispify(e,i,expectTypes[o].next)}))});const incrementTypes={"++$":25,"--$":27,"$++":26,"$--":28};setLispType(["incrementerBefore"],(e,t,n,s,o,r)=>{const i=restOfExp(e,n.substring(2),[/^[^\s.\w$]/]);r.lispTree=lispify(e,n.substring(i.length+2),restOfExp.next,createLisp({op:incrementTypes[s[0]+"$"],a:lispify(e,i,expectTypes[o].next),b:0}))}),setLispType(["incrementerAfter"],(e,t,n,s,o,r)=>{r.lispTree=lispify(e,n.substring(s[0].length),expectTypes[o].next,createLisp({op:incrementTypes["$"+s[0]],a:r.lispTree,b:0}))});const adderTypes={"&&":29,"||":30,"??":89,instanceof:62,in:63,"=":9,"-=":65,"+=":66,"/=":67,"**=":68,"*=":69,"%=":70,"^=":71,"&=":72,"|=":73,">>>=":74,"<<=":76,">>=":75};setLispType(["assign","assignModify","nullishCoalescing"],(e,t,n,s,o,r)=>{r.lispTree=createLisp({op:adderTypes[s[0]],a:r.lispTree,b:lispify(e,n.substring(s[0].length),expectTypes[o].next)})}),setLispType(["boolOpOr"],(e,t,n,s,o,r)=>{const i=[expectTypes.inlineIf.types.inlineIf,inlineIfElse,expectTypes.splitter.types.boolOpOr],a=restOfExp(e,n.substring(s[0].length),i);r.lispTree=lispify(e,n.substring(a.length+s[0].length),restOfExp.next,createLisp({op:adderTypes[s[0]],a:r.lispTree,b:lispify(e,a,expectTypes[o].next)}))}),setLispType(["boolOpAnd"],(e,t,n,s,o,r)=>{const i=[expectTypes.inlineIf.types.inlineIf,inlineIfElse,expectTypes.splitter.types.boolOpAnd,expectTypes.splitter.types.boolOpOr],a=restOfExp(e,n.substring(s[0].length),i);r.lispTree=lispify(e,n.substring(a.length+s[0].length),restOfExp.next,createLisp({op:adderTypes[s[0]],a:r.lispTree,b:lispify(e,a,expectTypes[o].next)}))});const opTypes={"&":77,"|":78,"^":79,"<<":80,">>":81,">>>":82,"<=":54,">=":55,"<":56,">":57,"!==":31,"!=":53,"===":32,"==":52,"+":33,"-":47,"/":48,"**":49,"*":50,"%":51};function extractIfElse(e,t){let n,s,o=0,r=t.substring(0,0),i=emptyString,a=!0,c={};for(;(r=restOfExp(e,t.substring(r.end-t.start),[elseIf,ifElse,semiColon],void 0,void 0,void 0,c)).length||a;){a=!1;const p=t.substring(r.end-t.start).toString();if(p.startsWith("if"))r.end++,o++;else if(p.startsWith("else"))n=t.substring(0,r.end-t.start),r.end++,o--,o||r.end--;else{if(!(s=/^;?\s*else(?![\w$])/.exec(p))){n=i.length?n:t.substring(0,r.end-t.start);break}n=t.substring(0,r.end-t.start),r.end+=s[0].length-1,o--,o||(r.end-=s[0].length-1)}if(!o){i=extractIfElse(e,t.substring(r.end-t.start+(/^;?\s*else(?![\w$])/.exec(p)?.[0].length||0))).all;break}c={}}return n=n||t.substring(0,r.end-t.start),{all:t.substring(0,Math.max(n.end,i.end)-t.start),true:n,false:i}}setLispType(["opHigh","op","comparitor","bitwiseShift","bitwiseAnd","bitwiseXor","bitwiseOr"],(e,t,n,s,o,r)=>{const i=[expectTypes.inlineIf.types.inlineIf,inlineIfElse];switch(t){case"opHigh":i.push(expectTypes.splitter.types.opHigh);case"op":i.push(expectTypes.splitter.types.op);case"comparitor":i.push(expectTypes.splitter.types.comparitor);case"bitwiseShift":i.push(expectTypes.splitter.types.bitwiseShift);case"bitwiseAnd":i.push(expectTypes.splitter.types.bitwiseAnd);case"bitwiseXor":i.push(expectTypes.splitter.types.bitwiseXor);case"bitwiseOr":i.push(expectTypes.splitter.types.bitwiseOr),i.push(expectTypes.splitter.types.boolOpAnd),i.push(expectTypes.splitter.types.boolOpOr)}const a=restOfExp(e,n.substring(s[0].length),i);r.lispTree=lispify(e,n.substring(a.length+s[0].length),restOfExp.next,createLisp({op:opTypes[s[0]],a:r.lispTree,b:lispify(e,a,expectTypes[o].next)}))}),setLispType(["inlineIf"],(e,t,n,s,o,r)=>{let i=!1;const a=n.substring(0,0);let c=1;for(;!i&&a.length<n.length;)a.end=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]).end,"?"===n.char(a.length)?c++:c--,c||(i=!0);a.start=n.start+1,r.lispTree=createLisp({op:15,a:r.lispTree,b:createLisp({op:16,a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(s[0].length+a.length+1))})})}),setLispType(["if"],(e,t,n,s,o,r)=>{let i=restOfExp(e,n.substring(s[0].length),[],"(");const a=extractIfElse(e,n.substring(s[1].length)),c=s[0].length-s[1].length+i.length+1;let p=a.true.substring(c),l=a.false;i=i.trim(),p=p.trim(),l=l.trim(),"{"===p.char(0)&&(p=p.slice(1,-1)),"{"===l.char(0)&&(l=l.slice(1,-1)),r.lispTree=createLisp({op:13,a:lispifyExpr(e,i),b:createLisp({op:14,a:lispifyBlock(p,e),b:lispifyBlock(l,e)})})}),setLispType(["switch"],(e,t,n,s,o,r)=>{const i=restOfExp(e,n.substring(s[0].length),[],"(");let a=n.toString().indexOf("{",s[0].length+i.length+1);if(-1===a)throw new SyntaxError("Invalid switch");let c,p=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"));const l=/^\s*(case\s|default)\s*/,d=[];let u=!1;for(;c=l.exec(p.toString());){if("default"===c[1]){if(u)throw new SyntaxError("Only one default switch case allowed");u=!0}const t=restOfExp(e,p.substring(c[0].length),[/^:/]);let n=emptyString,s=a=c[0].length+t.length+1;const o=/^\s*\{/.exec(p.substring(s).toString());let r=[];if(o)s+=o[0].length,n=restOfExp(e,p.substring(s),[],"{"),s+=n.length+1,r=lispifyBlock(n,e);else{const t=restOfExp(e,p.substring(s),[l]);if(t.trim().length){for(;(n=restOfExp(e,p.substring(s),[semiColon])).length&&(s+=n.length+(";"===p.char(s+n.length)?1:0),!l.test(p.substring(s).toString())););r=lispifyBlock(p.substring(a,n.end-p.start),e)}else r=[],s+=t.length}p=p.substring(s),d.push(createLisp({op:41,a:"default"===c[1]?0:lispifyExpr(e,t),b:r}))}r.lispTree=createLisp({op:40,a:lispifyExpr(e,i),b:d})}),setLispType(["dot","prop"],(e,t,n,s,o,r)=>{let i=s[0],a=s[0].length,c="prop";if("dot"===t){s[1]&&(c="?prop");const e=n.substring(s[0].length).toString().match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging dot");i=e[0],a=i.length+s[0].length}else if(reservedWords.has(i)&&"this"!==i)throw new SyntaxError(`Unexpected token '${i}'`);r.lispTree=lispify(e,n.substring(a),expectTypes[o].next,createLisp({op:typesCreate[c],a:r.lispTree,b:i}))}),setLispType(["spreadArray","spreadObject"],(e,t,n,s,o,r)=>{r.lispTree=createLisp({op:"spreadArray"===t?18:17,a:0,b:lispify(e,n.substring(s[0].length),expectTypes[o].next)})}),setLispType(["return","throw"],(e,t,n,s,o,r)=>{r.lispTree=createLisp({op:"return"===t?8:46,a:0,b:lispifyExpr(e,n.substring(s[0].length))})}),setLispType(["number","boolean","null","und","NaN","Infinity"],(e,t,n,s,o,r)=>{r.lispTree=lispify(e,n.substring(s[0].length),expectTypes[o].next,createLisp({op:"number"===t?s[12]?83:7:35,a:0,b:s[12]?s[1]:s[0]}))}),setLispType(["string","literal","regex"],(e,t,n,s,o,r)=>{r.lispTree=lispify(e,n.substring(s[0].length),expectTypes[o].next,createLisp({op:"string"===t?2:"literal"===t?84:85,a:0,b:s[1]}))}),setLispType(["initialize"],(e,t,n,s,o,r)=>{const i="var"===s[1]?34:"let"===s[1]?3:4;s[3]?r.lispTree=createLisp({op:i,a:s[2],b:lispify(e,n.substring(s[0].length),expectTypes[o].next)}):r.lispTree=lispify(e,n.substring(s[0].length),expectTypes[o].next,createLisp({op:i,a:s[2],b:0}))}),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],(e,t,n,s,o,r)=>{const i="function"!==t&&"inlineFunction"!==t,a=i&&!s[s.length-1],c=i?2:3,p=s[1]?88:0,l=s[c]?s[c].replace(/\s+/g,"").split(/,/g):[];i||l.unshift((s[2]||"").trimStart());let d=!1;l.forEach(e=>{if(d)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(d=!0)});const u=restOfExp(e,n.substring(s[0].length),a?[/^[,)}\]]/,semiColon]:[/^}/]),f=a?"return "+u:u.toString();l.forEach(e=>{if(reservedWords.has(e.replace(/^\.\.\./,"")))throw new SyntaxError(`Unexpected token '${e}'`)}),r.lispTree=lispify(e,n.substring(s[0].length+f.length+1),expectTypes[o].next,createLisp({op:i?11:"function"===t?37:10,a:[p,...l],b:e.eager?lispifyFunction(new CodeString(f),e):f}))});const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z$_][a-zA-Z\d$_]*)\s+(in|of)(?![\w$])/;setLispType(["for","do","while"],(e,t,n,s,o,r)=>{let i,a,c=0,p=88,l=[],d=0,u=0,f=88,x=88;switch(t){case"while":{c=n.toString().indexOf("(")+1;const t=restOfExp(e,n.substring(c),[],"(");i=lispifyReturnExpr(e,t),a=restOfExp(e,n.substring(c+t.length+1)).trim(),"{"===a.char(0)&&(a=a.slice(1,-1));break}case"for":{c=n.toString().indexOf("(")+1;const t=[];let s,o=emptyString;for(let s=0;s<3&&(o=restOfExp(e,n.substring(c),[/^[;)]/]),t.push(o.trim()),c+=o.length+1,")"!==n.char(c-1));s++);if(1===t.length&&(s=iteratorRegex.exec(t[0].toString())))"of"===s[4]?(d=lispifyReturnExpr(e,t[0].substring(s[0].length)),l=[ofStart2,ofStart3],i=ofCondition,x=ofStep,u=lispify(e,new CodeString((s[1]||"let ")+s[3]+" = $$next.value"),["initialize"])):(d=lispifyReturnExpr(e,t[0].substring(s[0].length)),l=[inStart2,inStart3],x=inStep,i=inCondition,u=lispify(e,new CodeString((s[1]||"let ")+s[3]+" = $$keys[$$keyIndex]"),["initialize"]));else{if(3!==t.length)throw new SyntaxError("Invalid for loop definition");p=lispifyExpr(e,t.shift(),startingExecpted),i=lispifyReturnExpr(e,t.shift()),x=lispifyExpr(e,t.shift())}a=restOfExp(e,n.substring(c)).trim(),"{"===a.char(0)&&(a=a.slice(1,-1));break}case"do":{f=0;const t=!!s[3];a=restOfExp(e,n.substring(s[0].length),t?[/^\}/]:[semiColon]),i=lispifyReturnExpr(e,restOfExp(e,n.substring(n.toString().indexOf("(",s[0].length+a.length)+1),[],"("));break}}const h=[f,l,d,p,x,i,u];r.lispTree=createLisp({op:38,a:h,b:lispifyBlock(a,e)})}),setLispType(["block"],(e,t,n,s,o,r)=>{r.lispTree=createLisp({op:42,a:lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e),b:0})}),setLispType(["loopAction"],(e,t,n,s,o,r)=>{r.lispTree=createLisp({op:86,a:s[1],b:0})});const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z$_][a-zA-Z\d$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],(e,t,n,s,o,r)=>{const i=restOfExp(e,n.substring(s[0].length),[],"{");let a,c,p=catchReg.exec(n.substring(s[0].length+i.length+1).toString()),l="",d=0;p[1].startsWith("catch")?(p=catchReg.exec(n.substring(s[0].length+i.length+1).toString()),l=p[2],c=restOfExp(e,n.substring(s[0].length+i.length+1+p[0].length),[],"{"),d=s[0].length+i.length+1+p[0].length+c.length+1,(p=catchReg.exec(n.substring(d).toString()))&&p[1].startsWith("finally")&&(a=restOfExp(e,n.substring(d+p[0].length),[],"{"))):a=restOfExp(e,n.substring(s[0].length+i.length+1+p[0].length),[],"{");const u=[l,lispifyBlock(insertSemicolons(e,c||emptyString),e),lispifyBlock(insertSemicolons(e,a||emptyString),e)];r.lispTree=createLisp({op:39,a:lispifyBlock(insertSemicolons(e,i),e),b:u})}),setLispType(["void","await"],(e,t,n,s,o,r)=>{const i=restOfExp(e,n.substring(s[0].length),[/^([^\s.?\w$]|\?[^.])/]);r.lispTree=lispify(e,n.substring(s[0].length+i.length),expectTypes[o].next,createLisp({op:"void"===t?87:44,a:lispify(e,i),b:0}))}),setLispType(["new"],(e,t,n,s,o,r)=>{let i=s[0].length;const a=restOfExp(e,n.substring(i),[],void 0,"(");i+=a.length+1;const c=[];if("("===n.char(i-1)){const t=restOfExp(e,n.substring(i),[],"(");let s;i+=t.length+1;let o=0;for(;(s=restOfExp(e,t.substring(o),[/^,/])).length;)o+=s.length+1,c.push(s.trim())}r.lispTree=lispify(e,n.substring(i),expectTypes.expEdge.next,createLisp({op:45,a:lispify(e,a,expectTypes.initialize.next),b:c.map(t=>lispify(e,t,expectTypes.initialize.next))}))});const ofStart2=lispify(void 0,new CodeString("let $$iterator = $$obj[Symbol.iterator]()"),["initialize"]),ofStart3=lispify(void 0,new CodeString("let $$next = $$iterator.next()"),["initialize"]),ofCondition=lispify(void 0,new CodeString("return !$$next.done"),["initialize"]),ofStep=lispify(void 0,new CodeString("$$next = $$iterator.next()")),inStart2=lispify(void 0,new CodeString("let $$keys = Object.keys($$obj)"),["initialize"]),inStart3=lispify(void 0,new CodeString("let $$keyIndex = 0"),["initialize"]),inStep=lispify(void 0,new CodeString("$$keyIndex++")),inCondition=lispify(void 0,new CodeString("return $$keyIndex < $$keys.length"),["initialize"]);function lispify(e,t,n,s,o=!1){if(s=s||NullLisp,n=n||expectTypes.initialize.next,void 0===t)return s;const r=(t=t.trimStart()).toString();if(!t.length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");if(!t.length)return s;const i={lispTree:s};let a;for(const s of n)if("expEnd"!==s){for(const n in expectTypes[s].types)if("expEnd"!==n&&(a=expectTypes[s].types[n].exec(r))){lastType=n;try{lispTypes.get(n)?.(e,n,t,a,s,i)}catch(e){if(o&&e instanceof SyntaxError)throw new ParseError(e.message,r);throw e}break}if(a)break}if(!a&&t.length){if(o)throw new ParseError(`Unexpected token after ${lastType}: ${t.char(0)}`,r);throw new SyntaxError(`Unexpected token after ${lastType}: ${t.char(0)}`)}return i.lispTree}const startingExpectedWithoutSingle=startingExecpted.filter(e=>"expSingle"!==e);function lispifyExpr(e,t,n){if(!t.trimStart().length)return NullLisp;const s=[];let o,r=0;if((n=n||expectTypes.initialize.next).includes("expSingle")&&testMultiple(t.toString(),Object.values(expectTypes.expSingle.types)))return lispify(e,t,["expSingle"],void 0,!0);for(n===startingExecpted&&(n=startingExpectedWithoutSingle);(o=restOfExp(e,t.substring(r),[/^,/])).length;)s.push(o.trimStart()),r+=o.length+1;if(1===s.length)return lispify(e,t,n,void 0,!0);if(n.includes("initialize")){const o=expectTypes.initialize.types.initialize.exec(s[0].toString());if(o)return createLisp({op:42,a:s.map((t,n)=>lispify(e,n?new CodeString(o[1]+" "+t):t,["initialize"],void 0,!0)),b:0});if(expectTypes.initialize.types.return.exec(s[0].toString()))return lispify(e,t,n,void 0,!0)}const i=s.map(t=>lispify(e,t,n,void 0,!0));return createLisp({op:43,a:i,b:0})}function lispifyReturnExpr(e,t){return createLisp({op:8,a:0,b:lispifyExpr(e,t)})}function lispifyBlock(e,t,n=!1){if(!(e=insertSemicolons(t,e)).trim().length)return[];const s=[];let o,r=0,i=0,a={},c=!1,p=!1;for(;(o=restOfExp(t,e.substring(r),[semiColon],void 0,void 0,void 0,a)).length&&(p=!(!e.char(r+o.length)||";"===e.char(r+o.length)),r+=o.length+(p?0:1),/^\s*else(?![\w$])/.test(e.substring(r).toString())||a.words?.includes("do")&&/^\s*while(?![\w$])/.test(e.substring(r).toString())?c=!0:(c=!1,s.push(e.substring(i,r-(p?0:1))),i=r),a={},!n););return c&&s.push(e.substring(i,r-(p?0:1))),s.map(e=>e.trimStart()).filter(e=>e.length).map(e=>lispifyExpr(t,e.trimStart(),startingExecpted))}function lispifyFunction(e,t,n=!1){if(!e.trim().length)return[];const s=lispifyBlock(e,t,n);return hoist(s),s}function hoist(e,t=[]){if(isLisp(e)){if(!isLisp(e))return!1;const[n,s,o]=e;if(39===n||13===n||38===n||40===n)hoist(s,t),hoist(o,t);else if(34===n)t.push(createLisp({op:34,a:s,b:0}));else if(37===n&&s[1])return t.push(e),!0}else if(Array.isArray(e)){const n=[];for(const s of e)hoist(s,t)||n.push(s);n.length!==e.length&&(e.length=0,e.push(...t,...n))}return!1}const closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w$])/,colonsRegex=/^((([\w$\])"'`]|\+\+|--)\s*\r?\n\s*([\w$+\-!~]))|(\}\s*[\w$!~+\-{("'`]))/;function insertSemicolons(e,t){let n=t,s=emptyString,o={};const r=insertedSemicolons.get(t.ref)||new Array(t.ref.str.length);for(;(s=restOfExp(e,n,[],void 0,void 0,[colonsRegex],o)).length;){let e=!1,t=s,i=s.length;if(o.regRes){e=!0;const[,,r,,,a]=o.regRes;if(i="++"===o.regRes[3]||"--"===o.regRes[3]?s.length+1:s.length,t=n.substring(0,i),a){const t=closingsNoInsertion.exec(n.substring(s.length-1).toString());t?e="while"===t[2]&&"do"!==o.lastWord:"function"===o.lastWord&&"}"===o.regRes[5][0]&&"("===o.regRes[5].slice(-1)&&(e=!1)}else r&&("if"!==o.lastWord&&"while"!==o.lastWord&&"for"!==o.lastWord&&"else"!==o.lastWord||(e=!1))}e&&(r[t.end]=!0),n=n.substring(i),o={}}return insertedSemicolons.set(t.ref,r),t}function checkRegex(e){let t=1,n=!1,s=!1,o=!1;for(;t<e.length&&!s&&!o;)s="/"===e[t]&&!n,n="\\"===e[t]&&!n,o="\n"===e[t],t++;const r=e.substring(t);if(o=o||!s||/^\s*\d/.test(r),o)return null;const i=/^[a-z]*/.exec(r);return/^\s+[\w$]/.test(e.substring(t+i[0].length))?null:{regex:e.substring(1,t-1),flags:i&&i[0]||"",length:t+(i&&i[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w$\])]|\+\+|--)[\s/]/;function extractConstants(e,t,n=""){let s,o,r=[],i=!1,a="",c=-1,p=[],l="";const d=[],u=[];let f=null,x=0;for(x=0;x<t.length;x++)if(l=t[x],a)l===a&&("*"===a&&"/"===t[x+1]?(a="",x++):"\n"===a&&(a=""));else{if(i){i=!1,r.push(l);continue}if(s)if("`"===s&&"$"===l&&"{"===t[x+1]){const n=extractConstants(e,t.substring(x+2),"{");p.push(n.str),r.push("${",p.length-1,"}"),x+=n.length+2}else if(s===l){if("`"===s){const t=createLisp({op:36,a:unraw(r.join("")),b:[]});t.tempJsStrings=p,e.literals.push(t),d.push("`",e.literals.length-1,"`")}else e.strings.push(unraw(r.join(""))),d.push('"',e.strings.length-1,'"');s=null,r=[]}else r.push(l);else{if("'"===l||'"'===l||"`"===l)p=[],s=l;else{if(closings[n]===l&&!u.length)return{str:d.join(""),length:x};closings[l]?(u.push(l),d.push(l)):closings[u[u.length-1]]===l?(u.pop(),d.push(l)):"/"!==l||"*"!==t[x+1]&&"/"!==t[x+1]?"/"===l&&!f&&(o=checkRegex(t.substring(x)))?(e.regexes.push(o),d.push("/",e.regexes.length-1,"/r"),x+=o.length-1):d.push(l):(a="*"===t[x+1]?"*":"\n",c=x)}f&&space.test(l)||(f=possibleDivide.exec(t.substring(x)))&&notDivide.test(t.substring(0,x+f[1].length))&&(f=null)}i=!(!s||"\\"!==l)}if(a&&"*"===a)throw new SyntaxError(`Unclosed comment '/*': ${t.substring(c)}`);return{str:d.join(""),length:x}}function parse(e,t=!1,n=!1){if("string"!=typeof e)throw new ParseError(`Cannot parse ${e}`,e);let s=" "+e;const o={strings:[],literals:[],regexes:[],eager:t};s=extractConstants(o,s).str;for(const e of o.literals)e[2]=e.tempJsStrings.map(e=>lispifyExpr(o,new CodeString(e))),delete e.tempJsStrings;return{tree:lispifyFunction(new CodeString(s),o,n),constants:o}}function createEvalContext(){return{sandboxFunction:sandboxFunction,sandboxAsyncFunction:sandboxAsyncFunction,sandboxedEval:sandboxedEval,sandboxedSetTimeout:sandboxedSetTimeout,sandboxedSetInterval:sandboxedSetInterval,sandboxedClearTimeout:sandboxedClearTimeout,sandboxedClearInterval:sandboxedClearInterval,lispifyFunction:lispifyFunction}}function sandboxFunction(e,t){return function SandboxFunction(...n){const s=parse(n.pop()||"");return createFunction(n,s.tree,t||currentTicks.current,{...e,constants:s.constants,tree:s.tree},void 0,"anonymous")}}function sandboxAsyncFunction(e,t){return function(...n){const s=parse(n.pop()||"");return createFunctionAsync(n,s.tree,t||currentTicks.current,{...e,constants:s.constants,tree:s.tree},void 0,"anonymous")}}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e,t){return function(n,s,...o){const r=t.ctx.sandbox,i=(...t)=>{const s="string"==typeof n?e(n):n;return d.unsubscribe(),u.unsubscribe(),s(...t)},a=++r.timeoutHandleCounter;let c=Date.now(),p=setTimeout(i,s,...o);r.setTimeoutHandles.set(a,p);let l=0;const d=r.subscribeHalt(()=>{l=Date.now()-c+l,clearTimeout(p)}),u=r.subscribeResume(()=>{c=Date.now();const e=Math.floor((s||0)-l);p=setTimeout(i,e,...o),r.setTimeoutHandles.set(a,p)});return a}}function sandboxedClearTimeout(e){return function(t){const n=e.ctx.sandbox,s=n.setTimeoutHandles.get(t);s&&(clearTimeout(s),n.setTimeoutHandles.delete(t))}}function sandboxedClearInterval(e){return function(t){const n=e.ctx.sandbox,s=n.setIntervalHandles.get(t);s&&(clearInterval(s.handle),n.setIntervalHandles.delete(t),s.haltsub.unsubscribe(),s.contsub.unsubscribe())}}function sandboxedSetInterval(e,t){return function(n,s,...o){const r=t.ctx.sandbox,i="string"==typeof n?e(n):n,a=(...e)=>(p=Date.now(),d=0,i(...e)),c=++r.timeoutHandleCounter;let p=Date.now(),l=setInterval(a,s,...o),d=0;const u=r.subscribeHalt(()=>{d=Date.now()-p+d,clearInterval(l)}),f=r.subscribeResume(()=>{p=Date.now(),l=setTimeout(()=>{p=Date.now(),d=0,l=setInterval(a,s,...o),a(...o)},Math.floor((s||0)-d),...o),x.handle=l}),x={handle:l,haltsub:u,contsub:f};return r.setIntervalHandles.set(c,x),c}}function subscribeSet(e,t,n,s){const o=s.setSubscriptions.get(e)||new Map;s.setSubscriptions.set(e,o);const r=o.get(t)||new Set;let i;o.set(t,r),r.add(n);const a=e[t];return a instanceof Object&&(i=s.changeSubscriptions.get(a)||new Set,i.add(n),s.changeSubscriptions.set(a,i)),{unsubscribe:()=>{r.delete(n),i?.delete(n)}}}class SandboxExec{constructor(e,t){this.evalContext=t,this.setSubscriptions=new WeakMap,this.changeSubscriptions=new WeakMap,this.sandboxFunctions=new WeakMap,this.haltSubscriptions=new Set,this.resumeSubscriptions=new Set,this.halted=!1,this.timeoutHandleCounter=0,this.setTimeoutHandles=new Map,this.setIntervalHandles=new Map;const n=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:SandboxExec.SAFE_GLOBALS,prototypeWhitelist:SandboxExec.SAFE_PROTOTYPES,prototypeReplacements:new Map},e||{});this.context=createContext(this,n)}static get SAFE_GLOBALS(){return{globalThis:globalThis,Function:Function,eval:eval,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,BigInt:BigInt,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){const e=[SandboxGlobal,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach(e=>{t.set(e,new Set)}),t.set(Object,new Set(["constructor","name","entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e,t){return t.getSubscriptions.add(e),{unsubscribe:()=>t.getSubscriptions.delete(e)}}subscribeSet(e,t,n,s){return subscribeSet(e,t,n,s)}subscribeSetGlobal(e,t,n){return subscribeSet(e,t,n,this)}subscribeHalt(e){return this.haltSubscriptions.add(e),{unsubscribe:()=>{this.haltSubscriptions.delete(e)}}}subscribeResume(e){return this.resumeSubscriptions.add(e),{unsubscribe:()=>{this.resumeSubscriptions.delete(e)}}}haltExecution(e){if(!this.halted){this.halted=!0;for(const t of this.haltSubscriptions)t(e)}}resumeExecution(){if(this.halted){if(this.context.ticks.ticks>=this.context.ticks.tickLimit)throw new SandboxExecutionQuotaExceededError("Cannot resume execution: tick limit exceeded");this.halted=!1;for(const e of this.resumeSubscriptions)e()}}getContext(e){return this.sandboxFunctions.get(e)}executeTree(e,t=[]){return executeTree(e.ctx.ticks,e,e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync(e.ctx.ticks,e,e.tree,t)}}class Sandbox extends SandboxExec{constructor(e){super(e,createEvalContext())}static audit(e,t=[]){const n={};for(const e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];const s=new SandboxExec({globals:n,audit:!0});return s.executeTree(createExecContext(s,parse(e,!0),createEvalContext()),t)}static parse(e){return parse(e)}compile(e,t=!1){const n=parse(e,t);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileAsync(e,t=!1){const n=parse(e,t);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then(e=>e.result)}}}compileExpression(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileExpressionAsync(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then(e=>e.result)}}}}export{LocalScope,SandboxAccessError,SandboxCapabilityError,SandboxError,SandboxExecutionTreeError,Sandbox as default};
//# sourceMappingURL=Sandbox.min.js.map
