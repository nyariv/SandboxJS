{"version":3,"file":"Sandbox.min.js","sources":["../src/utils.ts","../src/executor.ts","../src/unraw.ts","../src/parser.ts","../src/eval.ts","../src/SandboxExec.ts","../src/Sandbox.ts"],"sourcesContent":["// Reusable AsyncFunction constructor reference\nexport const AsyncFunction: Function = Object.getPrototypeOf(async function () {}).constructor;\nexport const GeneratorFunction: Function = Object.getPrototypeOf(function* () {}).constructor;\nexport const AsyncGeneratorFunction: Function = Object.getPrototypeOf(\n  async function* () {},\n).constructor;\n\nimport { IEvalContext } from './eval';\nimport { Change, Unknown } from './executor';\nimport { IConstants, IExecutionTree, Lisp, LispItem } from './parser';\nimport SandboxExec from './SandboxExec';\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any;\n\nexport interface IOptionParams {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals?: IGlobals;\n  executionQuota?: bigint;\n  haltOnSandboxError?: boolean;\n}\n\nexport interface IOptions {\n  audit: boolean;\n  forbidFunctionCalls: boolean;\n  forbidFunctionCreation: boolean;\n  prototypeReplacements: Map<Function, replacementCallback>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  haltOnSandboxError?: boolean;\n}\n\nexport interface IContext {\n  sandbox: SandboxExec;\n  globalScope: Scope;\n  sandboxGlobal: ISandboxGlobal;\n  globalsWhitelist: Set<any>;\n  prototypeWhitelist: Map<any, Set<PropertyKey>>;\n  sandboxedFunctions: WeakSet<Function>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n  ticks: Ticks;\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<unknown>;\n  prototypeAccess: { [name: string]: Set<PropertyKey> };\n}\n\nexport interface Ticks {\n  ticks: bigint;\n  tickLimit?: bigint;\n}\n\nexport type SubscriptionSubject = object;\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext;\n  getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<\n    SubscriptionSubject,\n    Map<string, Set<(modification: Change) => void>>\n  >;\n  changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n  allowJit: boolean;\n  evalContext?: IEvalContext;\n}\n\nexport interface ISandboxGlobal {\n  [key: string]: unknown;\n}\ninterface SandboxGlobalConstructor {\n  new (globals: IGlobals): ISandboxGlobal;\n}\n\nexport const SandboxGlobal = function SandboxGlobal(this: ISandboxGlobal, globals: IGlobals) {\n  for (const i in globals) {\n    this[i] = globals[i];\n  }\n} as any as SandboxGlobalConstructor;\n\nexport type IGlobals = ISandboxGlobal;\n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: Lisp[],\n    public getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>,\n    public setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Set<(modification: Change) => void>\n    >,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void,\n    public allowJit: boolean,\n    public evalContext?: IEvalContext,\n  ) {}\n}\n\nexport function createContext(sandbox: SandboxExec, options: IOptions): IContext {\n  const sandboxGlobal = new SandboxGlobal(options.globals);\n  const context: IContext = {\n    sandbox: sandbox,\n    globalsWhitelist: new Set(Object.values(options.globals)),\n    prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n    options,\n    globalScope: new Scope(null, options.globals, sandboxGlobal),\n    sandboxGlobal,\n    ticks: { ticks: 0n, tickLimit: options.executionQuota },\n    sandboxedFunctions: new WeakSet<Function>(),\n  };\n  context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()) as object, new Set());\n  return context;\n}\n\nexport function createExecContext(\n  sandbox: {\n    readonly setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    readonly changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n    readonly sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext>;\n    readonly context: IContext;\n  },\n  executionTree: IExecutionTree,\n  evalContext?: IEvalContext,\n): IExecContext {\n  const evals = new Map();\n  const execContext: IExecContext = new ExecContext(\n    sandbox.context,\n    executionTree.constants,\n    executionTree.tree,\n    new Set<(obj: SubscriptionSubject, name: string) => void>(),\n    new WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>(),\n    new WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>(),\n    sandbox.setSubscriptions,\n    sandbox.changeSubscriptions,\n    evals,\n    (fn) => sandbox.sandboxFunctions.set(fn, execContext),\n    !!evalContext,\n    evalContext,\n  );\n  if (evalContext) {\n    const func = evalContext.sandboxFunction(execContext);\n    const asyncFunc = evalContext.sandboxAsyncFunction(execContext);\n    evals.set(Function, func);\n    evals.set(AsyncFunction, asyncFunc);\n    evals.set(GeneratorFunction, func);\n    evals.set(AsyncGeneratorFunction, asyncFunc);\n    evals.set(eval, evalContext.sandboxedEval(func));\n    evals.set(setTimeout, evalContext.sandboxedSetTimeout(func, execContext));\n    evals.set(setInterval, evalContext.sandboxedSetInterval(func, execContext));\n    evals.set(clearTimeout, evalContext.sandboxedClearTimeout(execContext));\n    evals.set(clearInterval, evalContext.sandboxedClearInterval(execContext));\n\n    for (const [key, value] of evals) {\n      sandbox.context.prototypeWhitelist.set(value.prototype, new Set());\n      sandbox.context.prototypeWhitelist.set(key.prototype, new Set());\n    }\n  }\n  return execContext;\n}\n\nexport class CodeString {\n  start: number;\n  end: number;\n  ref: { str: string };\n  constructor(str: string | CodeString) {\n    this.ref = { str: '' };\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start;\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length() {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\nfunction keysOnly(obj: unknown): Record<string, true> {\n  const ret: Record<string, true> = Object.assign({}, obj);\n  for (const key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nexport const reservedWords = new Set([\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'let',\n  'new',\n  'null',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n]);\n\nexport const enum VarType {\n  let = 'let',\n  const = 'const',\n  var = 'var',\n}\n\nexport class Scope {\n  parent: Scope | null;\n  const: { [key: string]: true } = {};\n  let: { [key: string]: true } = {};\n  var: { [key: string]: true } = {};\n  globals: { [key: string]: true };\n  allVars: { [key: string]: unknown } & object;\n  functionThis?: Unknown;\n  constructor(parent: Scope | null, vars = {}, functionThis?: Unknown) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string): Prop {\n    const isThis = key === 'this';\n    const scope = this.getWhereValScope(key, isThis);\n    if (scope && isThis) {\n      return new Prop({ this: scope.functionThis }, key, false, false, true);\n    }\n    if (!scope) {\n      return new Prop(undefined, key);\n    }\n    return new Prop(scope.allVars, key, key in scope.const, key in scope.globals, true);\n  }\n\n  set(key: string, val: unknown) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    const prop = this.get(key);\n    if (prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.context === null) {\n      throw new TypeError(`Cannot set properties of null, (setting '${key}')`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    (prop.context as any)[prop.prop] = val;\n    return prop;\n  }\n\n  getWhereValScope(key: string, isThis: boolean): Scope | null {\n    if (isThis) {\n      if (this.functionThis !== undefined) {\n        return this;\n      } else {\n        return this.parent?.getWhereValScope(key, isThis) || null;\n      }\n    }\n    if (key in this.allVars && !(key in {} && !hasOwnProperty(this.allVars, key))) {\n      return this;\n    }\n    return this.parent?.getWhereValScope(key, isThis) || null;\n  }\n\n  getWhereVarScope(key: string, localScope = false): Scope {\n    if (key in this.allVars && !(key in {} && !hasOwnProperty(this.allVars, key))) {\n      return this;\n    }\n    if (this.parent === null || localScope || this.functionThis !== undefined) {\n      return this;\n    }\n    return this.parent.getWhereVarScope(key, localScope);\n  }\n\n  declare(key: string, type: VarType, value: unknown = undefined, isGlobal = false): Prop {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    const existingScope = this.getWhereVarScope(key, type !== VarType.var);\n    if (type === VarType.var) {\n      if (existingScope.var[key]) {\n        existingScope.allVars[key] = value;\n        if (!isGlobal) {\n          delete existingScope.globals[key];\n        } else {\n          existingScope.globals[key] = true;\n        }\n        return new Prop(existingScope.allVars, key, false, existingScope.globals[key], true);\n      } else if (key in existingScope.allVars) {\n        throw new SyntaxError(`Identifier '${key}' has already been declared`);\n      }\n    }\n    if (key in existingScope.allVars) {\n      throw new SyntaxError(`Identifier '${key}' has already been declared`);\n    }\n\n    if (isGlobal) {\n      existingScope.globals[key] = true;\n    }\n    existingScope[type][key] = true;\n    existingScope.allVars[key] = value;\n\n    return new Prop(this.allVars, key, type === VarType.const, isGlobal, true);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nexport class SandboxExecutionQuotaExceededError extends SandboxError {}\n\nexport class SandboxExecutionTreeError extends SandboxError {}\n\nexport class SandboxCapabilityError extends SandboxError {}\n\nexport class SandboxAccessError extends SandboxError {}\n\nexport function isLisp<Type extends Lisp = Lisp>(item: LispItem | LispItem): item is Type {\n  return (\n    Array.isArray(item) &&\n    typeof item[0] === 'number' &&\n    item[0] !== LispType.None &&\n    item[0] !== LispType.True\n  );\n}\n\nexport const enum LispType {\n  None,\n  Prop,\n  StringIndex,\n  Let,\n  Const,\n  Call,\n  KeyVal,\n  Number,\n  Return,\n  Assign,\n  InlineFunction,\n  ArrowFunction,\n  CreateArray,\n  If,\n  IfCase,\n  InlineIf,\n  InlineIfCase,\n  SpreadObject,\n  SpreadArray,\n  ArrayProp,\n  PropOptional,\n  CallOptional,\n  CreateObject,\n  Group,\n  Not,\n  IncrementBefore,\n  IncrementAfter,\n  DecrementBefore,\n  DecrementAfter,\n  And,\n  Or,\n  StrictNotEqual,\n  StrictEqual,\n  Plus,\n  Var,\n  GlobalSymbol,\n  Literal,\n  Function,\n  Loop,\n  Try,\n  Switch,\n  SwitchCase,\n  Block,\n  Expression,\n  Await,\n  New,\n  Throw,\n  Minus,\n  Divide,\n  Power,\n  Multiply,\n  Modulus,\n  Equal,\n  NotEqual,\n  SmallerEqualThan,\n  LargerEqualThan,\n  SmallerThan,\n  LargerThan,\n  Negative,\n  Positive,\n  Typeof,\n  Delete,\n  Instanceof,\n  In,\n  Inverse,\n  SubractEquals,\n  AddEquals,\n  DivideEquals,\n  PowerEquals,\n  MultiplyEquals,\n  ModulusEquals,\n  BitNegateEquals,\n  BitAndEquals,\n  BitOrEquals,\n  UnsignedShiftRightEquals,\n  ShiftRightEquals,\n  ShiftLeftEquals,\n  BitAnd,\n  BitOr,\n  BitNegate,\n  BitShiftLeft,\n  BitShiftRight,\n  BitUnsignedShiftRight,\n  BigInt,\n  LiteralIndex,\n  RegexIndex,\n  LoopAction,\n  Void,\n  True,\n  NullishCoalescing,\n\n  LispEnumSize,\n}\n\nexport class Prop<T = unknown> {\n  constructor(\n    public context: T,\n    public prop: PropertyKey,\n    public isConst = false,\n    public isGlobal = false,\n    public isVariable = false,\n  ) {}\n\n  get<T = unknown>(context: IExecContext): T {\n    const ctx = this.context;\n    if (ctx === undefined) throw new ReferenceError(`${this.prop.toString()} is not defined`);\n    if (ctx === null)\n      throw new TypeError(`Cannot read properties of null, (reading '${this.prop.toString()}')`);\n    context.getSubscriptions.forEach((cb) => cb(ctx, this.prop.toString()));\n    return (ctx as any)[this.prop] as T;\n  }\n}\n\nexport function hasOwnProperty(obj: unknown, prop: PropertyKey): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { LispItem, Lisp, IRegEx, SwitchCase } from './parser.js';\nimport {\n  CodeString,\n  hasOwnProperty,\n  IAuditReport,\n  IExecContext,\n  IScope,\n  isLisp,\n  LispType,\n  LocalScope,\n  Prop,\n  SandboxExecutionQuotaExceededError,\n  SandboxError,\n  SandboxExecutionTreeError,\n  Scope,\n  Ticks,\n  VarType,\n  SandboxCapabilityError,\n  SandboxAccessError,\n} from './utils.js';\n\nexport type Done<T = any> = (err?: any, res?: T | typeof optional) => void;\n\nexport class ExecReturn<T> {\n  constructor(\n    public auditReport: IAuditReport | undefined,\n    public result: T,\n    public returned: boolean,\n    public breakLoop = false,\n    public continueLoop = false,\n  ) {}\n}\n\nexport type Unknown = undefined | null | Record<string | number, unknown>;\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: 'create';\n  prop: number | string;\n}\n\nexport interface IReplace extends IChange {\n  type: 'replace';\n}\n\nexport interface IDelete extends IChange {\n  type: 'delete';\n  prop: number | string;\n}\n\nexport interface IReverse extends IChange {\n  type: 'reverse';\n}\n\nexport interface ISort extends IChange {\n  type: 'sort';\n}\n\nexport interface IPush extends IChange {\n  type: 'push';\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: 'pop';\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: 'shift';\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: 'unshift';\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: 'splice';\n  startIndex: number;\n  deleteCount: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport interface ICopyWithin extends IChange {\n  type: 'copyWithin';\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change =\n  | ICreate\n  | IReplace\n  | IDelete\n  | IReverse\n  | ISort\n  | IPush\n  | IPop\n  | IUnShift\n  | IShift\n  | ISplice\n  | ICopyWithin;\n\nconst optional = {};\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: Record<string, unknown> = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nexport function createFunction(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string,\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxCapabilityError('Function creation is forbidden');\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)],\n      );\n      return res.result;\n    };\n  } else {\n    func = function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)],\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  context.ctx.sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string,\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxCapabilityError('Function creation is forbidden');\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxCapabilityError('Async/await not permitted');\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)],\n      );\n      return res.result;\n    };\n  } else {\n    func = async function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)],\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  context.ctx.sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if (obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`);\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Assignment to constant variable.`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxAccessError(\n      `Cannot ${op} property '${obj.prop.toString()}' of a global object`,\n    );\n  }\n  if (obj.context === null) {\n    throw new TypeError('Cannot set properties of null');\n  }\n  if (\n    typeof (obj.context as any)[obj.prop] === 'function' &&\n    !hasOwnProperty(obj.context, obj.prop)\n  ) {\n    throw new SandboxAccessError(\n      `Override prototype property '${obj.prop.toString()}' not allowed`,\n    );\n  }\n  if (op === 'delete') {\n    if (hasOwnProperty(obj.context, obj.prop)) {\n      context.changeSubscriptions\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop.toString() }));\n      context.changeSubscriptionsGlobal\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop.toString() }));\n    }\n  } else if (hasOwnProperty(obj.context, obj.prop)) {\n    context.setSubscriptions\n      .get(obj.context)\n      ?.get(obj.prop.toString())\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        }),\n      );\n    context.setSubscriptionsGlobal\n      .get(obj.context)\n      ?.get(obj.prop.toString())\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        }),\n      );\n  } else {\n    context.changeSubscriptions\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop.toString() }));\n    context.changeSubscriptionsGlobal\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop.toString() }));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin,\n]);\n\nexport class KeyVal {\n  constructor(\n    public key: string | SpreadObject,\n    public val: unknown,\n  ) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: { [key: string]: unknown }) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(\n    public t: Lisp,\n    public f: Lisp,\n  ) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback<a, b, obj, bobj> = (params: OpsCallbackParams<a, b, obj, bobj>) => void;\n\nexport const ops = new Map<LispType, OpCallback<any, any, any, any>>();\nexport function addOps<a = unknown, b = unknown, obj = unknown, bobj = unknown>(\n  type: LispType,\n  cb: OpCallback<a, b, obj, bobj>,\n) {\n  ops.set(type, cb);\n}\n\nfunction isPropertyKey(val: unknown): val is PropertyKey {\n  return ['string', 'number', 'symbol'].includes(typeof val);\n}\n\nfunction hasPossibleProperties(val: unknown): val is {} {\n  return val !== null && val !== undefined;\n}\n\naddOps<unknown, PropertyKey>(LispType.Prop, ({ done, a, b, obj, context, scope }) => {\n  if (a === null) {\n    throw new TypeError(`Cannot read properties of null (reading '${b?.toString()}')`);\n  }\n\n  if (!isPropertyKey(b)) {\n    try {\n      b = `${b}`;\n    } catch (e) {\n      done(e);\n      return;\n    }\n  }\n\n  if (a === undefined && obj === undefined && typeof b === 'string') {\n    // is variable access\n    const prop = scope.get(b);\n    if (prop.context === context.ctx.sandboxGlobal) {\n      if (context.ctx.options.audit) {\n        context.ctx.auditReport?.globalsAccess.add(b);\n      }\n    }\n    const val = prop.context ? (prop.context as any)[prop.prop] : undefined;\n    const p = getGlobalProp(val, context, prop) || prop;\n\n    done(undefined, p);\n    return;\n  } else if (a === undefined) {\n    throw new TypeError(`Cannot read properties of undefined (reading '${b.toString()}')`);\n  }\n\n  if (!hasPossibleProperties(a)) {\n    done(undefined, new Prop(undefined, b));\n    return;\n  }\n\n  const prototypeAccess = typeof a === 'function' || !hasOwnProperty(a, b);\n\n  if (context.ctx.options.audit && prototypeAccess) {\n    let prot: {} = Object.getPrototypeOf(a);\n    do {\n      if (hasOwnProperty(prot, b)) {\n        if (\n          context.ctx.auditReport &&\n          !context.ctx.auditReport.prototypeAccess[prot.constructor.name]\n        ) {\n          context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n        }\n        context.ctx.auditReport?.prototypeAccess[prot.constructor.name].add(b);\n      }\n    } while ((prot = Object.getPrototypeOf(prot)));\n  }\n\n  if (prototypeAccess) {\n    if (typeof a === 'function') {\n      if (hasOwnProperty(a, b)) {\n        const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n        const replace = context.ctx.options.prototypeReplacements.get(a);\n        if (replace) {\n          done(undefined, new Prop(replace(a, true), b));\n          return;\n        }\n        if (\n          !(whitelist && (!whitelist.size || whitelist.has(b))) &&\n          !context.ctx.sandboxedFunctions.has(a)\n        ) {\n          throw new SandboxAccessError(\n            `Static method or property access not permitted: ${a.name}.${b.toString()}`,\n          );\n        }\n      }\n    }\n\n    let prot: {} = a;\n    while ((prot = Object.getPrototypeOf(prot))) {\n      if (hasOwnProperty(prot, b) || b === '__proto__') {\n        const whitelist = context.ctx.prototypeWhitelist.get(prot);\n        const replace = context.ctx.options.prototypeReplacements.get(prot.constructor);\n        if (replace) {\n          done(undefined, new Prop(replace(a, false), b));\n          return;\n        }\n        if (\n          (whitelist && (!whitelist.size || whitelist.has(b))) ||\n          context.ctx.sandboxedFunctions.has(prot.constructor)\n        ) {\n          break;\n        }\n        if (b === '__proto__') {\n          throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n        }\n        throw new SandboxAccessError(\n          `Method or property access not permitted: ${prot.constructor.name}.${b.toString()}`,\n        );\n      }\n    }\n  }\n\n  const val = a[b as keyof typeof a] as unknown;\n  if (typeof a === 'function') {\n    if (b === 'prototype' && !context.ctx.sandboxedFunctions.has(a)) {\n      throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n    }\n  }\n\n  if (b === '__proto__' && !context.ctx.sandboxedFunctions.has(val?.constructor as any)) {\n    throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n  }\n\n  const p = getGlobalProp(val, context);\n  if (p) {\n    done(undefined, p);\n    return;\n  }\n\n  const g =\n    (obj instanceof Prop && obj.isGlobal) ||\n    (typeof a === 'function' && !context.ctx.sandboxedFunctions.has(a)) ||\n    context.ctx.globalsWhitelist.has(a);\n\n  done(undefined, new Prop(a, b, false, g, false));\n});\n\nfunction getGlobalProp(val: unknown, context: IExecContext, prop?: Prop) {\n  if (!val) return;\n  const isFunc = typeof val === 'function';\n  if (val instanceof Prop) {\n    if (!prop) {\n      prop = val;\n    }\n    val = val.get(context);\n  }\n  const p = prop?.prop || 'prop';\n  if (val === globalThis) {\n    return new Prop(\n      {\n        [p]: context.ctx.sandboxGlobal,\n      },\n      p,\n      prop?.isConst || false,\n      false,\n      prop?.isVariable || false,\n    );\n  }\n  const e = isFunc && context.evals.get(val);\n  if (e) {\n    return new Prop(\n      {\n        [p]: e,\n      },\n      p,\n      prop?.isConst || false,\n      true,\n      prop?.isVariable || false,\n    );\n  }\n}\n\naddOps<unknown, Lisp[], any>(LispType.Call, ({ done, a, b, obj, context }) => {\n  if (context.ctx.options.forbidFunctionCalls)\n    throw new SandboxCapabilityError('Function invocations are not allowed');\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    let ret = obj(...vals);\n    if (ret instanceof Promise) {\n      ret = checkHaltAsync(context, ret);\n    } else {\n      ret = getGlobalProp(ret, context) || ret;\n    }\n    done(undefined, ret);\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (const y of Object.keys(x) as (keyof typeof x)[]) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (\n    obj.context instanceof Array &&\n    arrayChange.has(obj.context[obj.prop]) &&\n    (context.changeSubscriptions.get(obj.context) ||\n      context.changeSubscriptionsGlobal.get(obj.context))\n  ) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === 'push') {\n      change = {\n        type: 'push',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'pop') {\n      change = {\n        type: 'pop',\n        removed: obj.context.slice(-1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'shift') {\n      change = {\n        type: 'shift',\n        removed: obj.context.slice(0, 1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'unshift') {\n      change = {\n        type: 'unshift',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'splice') {\n      change = {\n        type: 'splice',\n        startIndex: vals[0] as number,\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(\n          vals[0],\n          vals[1] === undefined ? undefined : (vals[0] as number) + (vals[1] as number),\n        ),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === 'reverse' || obj.prop === 'sort') {\n      change = { type: obj.prop };\n      changed = !!obj.context.length;\n    } else if (obj.prop === 'copyWithin') {\n      const len =\n        vals[2] === undefined\n          ? obj.context.length - (vals[1] as number)\n          : Math.min(obj.context.length, (vals[2] as number) - (vals[1] as number));\n      change = {\n        type: 'copyWithin',\n        startIndex: vals[0] as number,\n        endIndex: (vals[0] as number) + len,\n        added: obj.context.slice(vals[1] as number, (vals[1] as number) + len),\n        removed: obj.context.slice(vals[0] as number, (vals[0] as number) + len),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  let ret = obj.context[obj.prop](...vals) as unknown;\n  if (ret instanceof Promise) {\n    ret = checkHaltAsync(context, ret);\n  } else {\n    ret = getGlobalProp(ret, context) || ret;\n  }\n  done(undefined, ret);\n});\n\naddOps<unknown, KeyVal[]>(LispType.CreateObject, ({ done, b }) => {\n  let res = {} as any;\n  for (const item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = { ...res, ...item.key.item };\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps<string, LispItem>(LispType.KeyVal, ({ done, a, b }) => done(undefined, new KeyVal(a, b)));\n\naddOps<unknown, Lisp[]>(LispType.CreateArray, ({ done, b, context }) => {\n  const items = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n  done(undefined, items);\n});\n\naddOps<unknown, unknown>(LispType.Group, ({ done, b }) => done(undefined, b));\n\naddOps<unknown, string>(LispType.GlobalSymbol, ({ done, b }) => {\n  switch (b) {\n    case 'true':\n      return done(undefined, true);\n    case 'false':\n      return done(undefined, false);\n    case 'null':\n      return done(undefined, null);\n    case 'undefined':\n      return done(undefined, undefined);\n    case 'NaN':\n      return done(undefined, NaN);\n    case 'Infinity':\n      return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b));\n});\n\naddOps<unknown, string>(LispType.Number, ({ done, b }) =>\n  done(undefined, Number(b.replace(/_/g, ''))),\n);\naddOps<unknown, string>(LispType.BigInt, ({ done, b }) =>\n  done(undefined, BigInt(b.replace(/_/g, ''))),\n);\naddOps<unknown, string>(LispType.StringIndex, ({ done, b, context }) =>\n  done(undefined, context.constants.strings[parseInt(b)]),\n);\n\naddOps<unknown, string>(LispType.RegexIndex, ({ done, b, context }) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxCapabilityError('Regex not permitted');\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps<unknown, string>(LispType.LiteralIndex, ({ exec, done, ticks, b, context, scope }) => {\n  const item = context.constants.literals[parseInt(b)];\n  const [, name, js] = item;\n  const found: Lisp[] = [];\n  let f: RegExpExecArray | null;\n  const resnums: string[] = [];\n  while ((f = literalRegex.exec(name))) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec<unknown[]>(ticks, found, scope, context, (err, processed) => {\n    const reses: Record<string, unknown> = {};\n    if (err) {\n      done(err);\n      return;\n    }\n    for (const i of Object.keys(processed!) as (keyof typeof processed)[]) {\n      const num = resnums[i];\n      reses[num] = processed![i];\n    }\n    done(\n      undefined,\n      name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        const res = reses[num];\n        return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n      }),\n    );\n  });\n});\n\naddOps<unknown, unknown[]>(LispType.SpreadArray, ({ done, b }) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps<unknown, Record<string, unknown>>(LispType.SpreadObject, ({ done, b }) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps<unknown, unknown>(LispType.Not, ({ done, b }) => done(undefined, !b));\naddOps<unknown, number>(LispType.Inverse, ({ done, b }) => done(undefined, ~b));\n\naddOps<unknown, unknown, Prop<any>>(LispType.IncrementBefore, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.IncrementAfter, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.DecrementBefore, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.DecrementAfter, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps<unknown, unknown, Prop<any>, Prop<any>>(\n  LispType.Assign,\n  ({ done, b, obj, context, scope, bobj }) => {\n    assignCheck(obj, context);\n    obj.isGlobal = bobj?.isGlobal || false;\n    if (obj.isVariable) {\n      const s = scope.getWhereValScope(obj.prop as string, obj.prop === 'this');\n      if (s === null) {\n        throw new ReferenceError(`Cannot assign to undeclared variable '${obj.prop.toString()}'`);\n      }\n      s.set(obj.prop as string, b);\n      if (obj.isGlobal) {\n        s.globals[obj.prop.toString()] = true;\n      } else {\n        delete s.globals[obj.prop.toString()];\n      }\n      done(undefined, b);\n      return;\n    }\n    done(undefined, (obj.context[obj.prop] = b));\n  },\n);\n\naddOps<unknown, unknown, Prop<any>>(LispType.AddEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] += b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.SubractEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] -= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.DivideEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] /= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.MultiplyEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] *= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.PowerEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] **= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ModulusEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] %= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitNegateEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] ^= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitAndEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] &= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitOrEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] |= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ShiftLeftEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] <<= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ShiftRightEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] >>= b));\n});\n\naddOps<unknown, number, Prop<any>>(\n  LispType.UnsignedShiftRightEquals,\n  ({ done, b, obj, context }) => {\n    assignCheck(obj, context);\n    done(undefined, (obj.context[obj.prop] >>>= b));\n  },\n);\n\naddOps<number, number>(LispType.LargerThan, ({ done, a, b }) => done(undefined, a > b));\naddOps<number, number>(LispType.SmallerThan, ({ done, a, b }) => done(undefined, a < b));\naddOps<number, number>(LispType.LargerEqualThan, ({ done, a, b }) => done(undefined, a >= b));\naddOps<number, number>(LispType.SmallerEqualThan, ({ done, a, b }) => done(undefined, a <= b));\naddOps<number, number>(LispType.Equal, ({ done, a, b }) => done(undefined, a == b));\naddOps<number, number>(LispType.StrictEqual, ({ done, a, b }) => done(undefined, a === b));\naddOps<number, number>(LispType.NotEqual, ({ done, a, b }) => done(undefined, a != b));\naddOps<number, number>(LispType.StrictNotEqual, ({ done, a, b }) => done(undefined, a !== b));\naddOps<number, number>(LispType.And, ({ done, a, b }) => done(undefined, a && b));\naddOps<number, number>(LispType.Or, ({ done, a, b }) => done(undefined, a || b));\naddOps<number, number>(LispType.NullishCoalescing, ({ done, a, b }) => done(undefined, a ?? b));\naddOps<number, number>(LispType.BitAnd, ({ done, a, b }) => done(undefined, a & b));\naddOps<number, number>(LispType.BitOr, ({ done, a, b }) => done(undefined, a | b));\naddOps<number, number>(LispType.Plus, ({ done, a, b }) => done(undefined, a + b));\naddOps<number, number>(LispType.Minus, ({ done, a, b }) => done(undefined, a - b));\naddOps<number, number>(LispType.Positive, ({ done, b }) => done(undefined, +b));\naddOps<number, number>(LispType.Negative, ({ done, b }) => done(undefined, -b));\naddOps<number, number>(LispType.Divide, ({ done, a, b }) => done(undefined, a / b));\naddOps<number, number>(LispType.Power, ({ done, a, b }) => done(undefined, a ** b));\naddOps<number, number>(LispType.BitNegate, ({ done, a, b }) => done(undefined, a ^ b));\naddOps<number, number>(LispType.Multiply, ({ done, a, b }) => done(undefined, a * b));\naddOps<number, number>(LispType.Modulus, ({ done, a, b }) => done(undefined, a % b));\naddOps<number, number>(LispType.BitShiftLeft, ({ done, a, b }) => done(undefined, a << b));\naddOps<number, number>(LispType.BitShiftRight, ({ done, a, b }) => done(undefined, a >> b));\naddOps<number, number>(LispType.BitUnsignedShiftRight, ({ done, a, b }) =>\n  done(undefined, a >>> b),\n);\naddOps<unknown, LispItem>(LispType.Typeof, ({ exec, done, ticks, b, context, scope }) => {\n  exec(ticks, b, scope, context, (e, prop) => {\n    done(undefined, typeof valueOrProp(prop, context));\n  });\n});\n\naddOps<unknown, { new (): unknown }>(LispType.Instanceof, ({ done, a, b }) =>\n  done(undefined, a instanceof b),\n);\naddOps<string, {}>(LispType.In, ({ done, a, b }) => done(undefined, a in b));\n\naddOps<unknown, unknown>(LispType.Delete, ({ done, context, bobj }) => {\n  if (!(bobj instanceof Prop)) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete (bobj.context as any)?.[bobj.prop]);\n});\n\naddOps(LispType.Return, ({ done, b }) => done(undefined, b));\n\naddOps<string, unknown, unknown, Prop>(LispType.Var, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.var, b, bobj?.isGlobal || false));\n});\n\naddOps<string, unknown, unknown, Prop>(LispType.Let, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj?.isGlobal || false));\n});\n\naddOps<string, unknown, unknown, Prop>(LispType.Const, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.const, b, bobj?.isGlobal || false));\n});\n\naddOps<string[], Lisp[], Lisp>(\n  LispType.ArrowFunction,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    a = [...a];\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  },\n);\n\naddOps<(string | LispType)[], Lisp[], Lisp>(\n  LispType.Function,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n);\n\naddOps<(string | LispType)[], Lisp[], Lisp>(\n  LispType.InlineFunction,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    if (name) {\n      scope = new Scope(scope, {});\n    }\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n);\n\naddOps<Lisp[], Lisp[]>(LispType.Loop, ({ exec, done, ticks, a, b, context, scope }) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  const internalVars = {\n    $$obj: undefined,\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async () => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] =\n        (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst)\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      while (loop) {\n        const innerLoopVars = {};\n        ad = asyncDone((d) =>\n          exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d),\n        );\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        const res = await executeTreeAsync(\n          ticks,\n          context,\n          b,\n          [new Scope(loopScope, innerLoopVars)],\n          'loop',\n        );\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    while (loop) {\n      const innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      const res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], 'loop');\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    }\n    done();\n  }\n});\n\naddOps<LispItem, LispItem>(LispType.LoopAction, ({ done, a, context, inLoopOrSwitch }) => {\n  if ((inLoopOrSwitch === 'switch' && a === 'continue') || !inLoopOrSwitch) {\n    throw new TypeError('Illegal ' + a + ' statement');\n  }\n  done(\n    undefined,\n    new ExecReturn(context.ctx.auditReport, undefined, false, a === 'break', a === 'continue'),\n  );\n});\n\naddOps<LispItem, If>(LispType.If, ({ exec, done, ticks, a, b, context, scope, inLoopOrSwitch }) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done, inLoopOrSwitch);\n});\n\naddOps<LispItem, If>(LispType.InlineIf, ({ exec, done, ticks, a, b, context, scope }) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done, undefined);\n});\n\naddOps<Lisp, Lisp>(LispType.InlineIfCase, ({ done, a, b }) => done(undefined, new If(a, b)));\naddOps<Lisp, Lisp>(LispType.IfCase, ({ done, a, b }) => done(undefined, new If(a, b)));\n\naddOps<LispItem, SwitchCase[]>(LispType.Switch, ({ exec, done, ticks, a, b, context, scope }) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (const caseItem of b) {\n        if (\n          isTrue ||\n          (isTrue =\n            !caseItem[1] ||\n            toTest ===\n              valueOrProp(\n                syncDone((d) => exec(ticks, caseItem[1], scope, context, d)).result,\n                context,\n              ))\n        ) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], 'switch');\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) {\n            // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (const caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (\n            isTrue ||\n            (isTrue =\n              !caseItem[1] ||\n              toTest ===\n                valueOrProp(\n                  (ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant ===\n                    true\n                    ? ad.instant\n                    : (await ad.p).result,\n                  context,\n                ))\n          ) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], 'switch');\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) {\n              // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done);\n    }\n  });\n});\n\naddOps<Lisp[], [string, Lisp[], Lisp[]]>(\n  LispType.Try,\n  ({ exec, done, ticks, a, b, context, scope, inLoopOrSwitch }) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(\n      exec,\n      (err, res) => {\n        executeTreeWithDone(\n          exec,\n          (e) => {\n            if (e) done(e);\n            else if (err) {\n              const sc: Record<string, unknown> = {};\n              if (exception) sc[exception] = err;\n              executeTreeWithDone(\n                exec,\n                done,\n                ticks,\n                context,\n                catchBody,\n                [new Scope(scope)],\n                inLoopOrSwitch,\n              );\n            } else {\n              done(undefined, res);\n            }\n          },\n          ticks,\n          context,\n          finallyBody,\n          [new Scope(scope, {})],\n        );\n      },\n      ticks,\n      context,\n      a,\n      [new Scope(scope)],\n      inLoopOrSwitch,\n    );\n  },\n);\n\naddOps(LispType.Void, ({ done }) => {\n  done();\n});\naddOps<new (...args: unknown[]) => unknown, unknown[]>(LispType.New, ({ done, a, b, context }) => {\n  if (!context.ctx.globalsWhitelist.has(a) && !context.ctx.sandboxedFunctions.has(a)) {\n    throw new SandboxAccessError(`Object construction not allowed: ${a.constructor.name}`);\n  }\n  done(undefined, new a(...b));\n});\n\naddOps(LispType.Throw, ({ done, b }) => {\n  done(b);\n});\naddOps<unknown[]>(LispType.Expression, ({ done, a }) => done(undefined, a.pop()));\naddOps(LispType.None, ({ done }) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): unknown {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(\n  ticks: Ticks,\n  exec: Execution,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res =\n        (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = <T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string,\n) => void;\n\nexport interface AsyncDoneRet {\n  isInstant: boolean;\n  instant: any;\n  p: Promise<{ result: any }>;\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({ result });\n      }\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p,\n  };\n}\n\nexport function syncDone(callback: (done: Done) => void): { result: any } {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return { result };\n}\n\nexport async function execAsync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  doneOriginal: Done<T>,\n  inLoopOrSwitch?: string,\n): Promise<void> {\n  let done: Done<T> = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    };\n  });\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    // Short-circuit for nullish coalescing: if a is not null/undefined, return a without evaluating b\n    if (op === LispType.NullishCoalescing && a !== undefined && a !== null) {\n      done(undefined, a);\n      return;\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    performOp({\n      op,\n      exec: execAsync,\n      done,\n      ticks,\n      a,\n      b,\n      obj,\n      context,\n      scope,\n      bobj,\n      inLoopOrSwitch,\n      tree,\n    });\n  }\n  await p;\n}\n\nexport function execSync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string,\n) {\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    // Short-circuit for nullish coalescing: if a is not null/undefined, return a without evaluating b\n    if (op === LispType.NullishCoalescing && a !== undefined && a !== null) {\n      done(undefined, a);\n      return;\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    performOp({\n      op,\n      exec: execSync,\n      done,\n      ticks,\n      a,\n      b,\n      obj,\n      context,\n      scope,\n      bobj,\n      inLoopOrSwitch,\n      tree,\n    });\n  }\n}\n\nfunction checkHaltAsync<T>(context: IExecContext, promise: Promise<T>): Promise<T> {\n  let done = false;\n  let halted = context.ctx.sandbox.halted;\n  let doResolve = () => {};\n  let subres: { unsubscribe: () => void };\n  let subhalt: { unsubscribe: () => void };\n  const interupted = new Promise<void>((resolve) => {\n    doResolve = () => {\n      subhalt.unsubscribe();\n      subres.unsubscribe();\n      resolve();\n    };\n    subhalt = context.ctx.sandbox.subscribeHalt(() => {\n      halted = true;\n    });\n\n    subres = context.ctx.sandbox.subscribeResume(() => {\n      halted = false;\n      if (done) doResolve();\n    });\n  });\n  promise\n    .finally(() => {\n      done = true;\n      if (!halted) {\n        doResolve();\n      }\n    })\n    .catch(() => {});\n  return Promise.allSettled([promise, interupted]).then(() => {\n    return promise;\n  });\n}\n\ntype OpsCallbackParams<a, b, obj, bobj> = {\n  op: LispType;\n  exec: Execution;\n  a: a;\n  b: b;\n  obj: obj;\n  bobj: bobj;\n  ticks: Ticks;\n  tree: LispItem;\n  scope: Scope;\n  context: IExecContext;\n  done: Done;\n  inLoopOrSwitch?: string;\n};\n\nfunction checkHaltExpectedTicks(\n  params: OpsCallbackParams<any, any, any, any>,\n  expectTicks = 0,\n): boolean {\n  const sandbox = params.context.ctx.sandbox;\n  const options = params.context.ctx.options;\n  const { ticks, scope, context, done, op } = params;\n  if (sandbox.halted) {\n    const sub = sandbox.subscribeResume(() => {\n      sub.unsubscribe();\n      try {\n        const o = ops.get(op);\n        if (!o) {\n          done(new SyntaxError('Unknown operator: ' + op));\n          return;\n        }\n        o(params);\n      } catch (err) {\n        if (options.haltOnSandboxError && err instanceof SandboxError) {\n          const sub = sandbox.subscribeResume(() => {\n            sub.unsubscribe();\n            done(err);\n          });\n          sandbox.haltExecution({\n            error: err as Error,\n            ticks,\n            scope,\n            context,\n          });\n        } else {\n          done(err);\n        }\n      }\n    });\n    return true;\n  } else if (ticks.tickLimit && ticks.tickLimit <= ticks.ticks + BigInt(expectTicks)) {\n    const sub = sandbox.subscribeResume(() => {\n      sub.unsubscribe();\n      try {\n        const o = ops.get(op);\n        if (!o) {\n          done(new SyntaxError('Unknown operator: ' + op));\n          return;\n        }\n        o(params);\n      } catch (err) {\n        if (context.ctx.options.haltOnSandboxError && err instanceof SandboxError) {\n          const sub = sandbox.subscribeResume(() => {\n            sub.unsubscribe();\n            done(err);\n          });\n          sandbox.haltExecution({\n            error: err as Error,\n            ticks,\n            scope,\n            context,\n          });\n        } else {\n          done(err);\n        }\n      }\n    });\n    const error = new SandboxExecutionQuotaExceededError('Execution quota exceeded');\n    sandbox.haltExecution({\n      error,\n      ticks,\n      scope: scope,\n      context,\n    });\n    return true;\n  }\n  return false;\n}\n\nfunction performOp(params: OpsCallbackParams<any, any, any, any>) {\n  const { done, op, ticks, context, scope } = params;\n  ticks.ticks++;\n  const sandbox = context.ctx.sandbox;\n\n  if (checkHaltExpectedTicks(params)) {\n    return;\n  }\n\n  try {\n    const o = ops.get(op);\n    if (!o) {\n      done(new SandboxExecutionTreeError('Unknown operator: ' + op));\n      return;\n    }\n    o(params);\n  } catch (err) {\n    if (context.ctx.options.haltOnSandboxError && err instanceof SandboxError) {\n      const sub = sandbox.subscribeResume(() => {\n        sub.unsubscribe();\n        done(err);\n      });\n      sandbox.haltExecution({\n        error: err as Error,\n        ticks,\n        scope,\n        context,\n      });\n    } else {\n      done(err);\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof,\n]);\n\nexport const currentTicks = { current: { ticks: BigInt(0) } as Ticks };\n\nfunction _execNoneRecurse<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  isAsync: boolean,\n  inLoopOrSwitch?: string,\n): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  currentTicks.current = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SyntaxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(\n        ticks,\n        tree[1],\n        scope,\n        context,\n        async (e, r) => {\n          if (e) done(e);\n          else\n            try {\n              done(undefined, (await valueOrProp(r, context)) as any);\n            } catch (err) {\n              done(err);\n            }\n        },\n        inLoopOrSwitch,\n      ).catch(done);\n    } else {\n      done(new SandboxCapabilityError('Async/await is not permitted'));\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    performOp({\n      op: tree[0],\n      exec,\n      done,\n      ticks,\n      a: tree[1],\n      b: tree[2],\n      obj: tree,\n      tree,\n      context,\n      scope,\n      bobj: undefined,\n      inLoopOrSwitch,\n    });\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n): ExecReturn<T> {\n  return syncDone((done) =>\n    executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch),\n  ).result;\n}\n\nexport async function executeTreeAsync<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) =>\n    executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch),\n  )).isInstant === true\n    ? ad.instant\n    : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(\n  exec: Execution,\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n) {\n  if (!executionTree) {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while ((s = scopes.shift())) {\n    if (typeof s !== 'object') continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    };\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string,\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      execSync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch,\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string,\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      await execAsync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch,\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex: string, errorName: string, enforcedLength?: number): number {\n  const parsedHex = parseHexToInt(hex);\n  if (Number.isNaN(parsedHex) || (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Hexadecimal', 2);\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(surrogateCode, 'Malformed Unicode', 4);\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === '{' && text.charAt(text.length - 1) === '}';\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(withoutBraces, 'Malformed Unicode');\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError ? new SyntaxError('Code Point Limit:' + parsedCode) : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  ['b', '\\b'],\n  ['f', '\\f'],\n  ['n', '\\n'],\n  ['r', '\\r'],\n  ['t', '\\t'],\n  ['v', '\\v'],\n  ['0', '\\0'],\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch =\n  /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(\n    escapeMatch,\n    function (\n      _,\n      backslash?: string,\n      hex?: string,\n      codePoint?: string,\n      unicodeWithSurrogate?: string,\n      surrogate?: string,\n      unicode?: string,\n      octal?: string,\n      singleCharacter?: string,\n    ): string {\n      // Compare groups to undefined because empty strings mean different errors\n      // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n      if (backslash !== undefined) {\n        return '\\\\';\n      }\n      if (hex !== undefined) {\n        return parseHexadecimalCode(hex);\n      }\n      if (codePoint !== undefined) {\n        return parseUnicodeCodePointCode(codePoint);\n      }\n      if (unicodeWithSurrogate !== undefined) {\n        return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n      }\n      if (unicode !== undefined) {\n        return parseUnicodeCode(unicode);\n      }\n      if (octal === '0') {\n        return '\\0';\n      }\n      if (octal !== undefined) {\n        throw new SyntaxError('Octal Deprecation: ' + octal);\n      }\n      if (singleCharacter !== undefined) {\n        return parseSingleCharacterCode(singleCharacter);\n      }\n      throw new SyntaxError('End of string');\n    },\n  );\n}\nexport default unraw;\n","import unraw from './unraw.js';\nimport { CodeString, isLisp, LispType, reservedWords } from './utils.js';\n\nexport type DefineLisp<\n  op extends LispType,\n  a extends LispItem | LispItem,\n  b extends LispItem | LispItem,\n> = [op, a, b];\n\nexport type ExtractLispOp<L> = L extends DefineLisp<infer i, any, any> ? i : never;\nexport type ExtractLispA<L> = L extends DefineLisp<any, infer i, any> ? i : never;\nexport type ExtractLispB<L> = L extends DefineLisp<any, any, infer i> ? i : never;\n\nexport type LispItemSingle = LispType.None | LispType.True | string | Lisp;\nexport type LispItem = LispItemSingle | LispItemSingle[];\nexport type Lisp = [LispType, LispItem, LispItem];\n\nfunction createLisp<L extends Lisp>(obj: {\n  op: ExtractLispOp<L>;\n  a: ExtractLispA<L>;\n  b: ExtractLispB<L>;\n}) {\n  return [obj.op, obj.a, obj.b] as L;\n}\n\nconst NullLisp = createLisp<None>({ op: LispType.None, a: LispType.None, b: LispType.None });\n\nexport type Literal = DefineLisp<LispType.Literal, string, Lisp[]> & { tempJsStrings?: string[] };\nexport type If = DefineLisp<LispType.If, Lisp, IfCase>;\nexport type InlineIf = DefineLisp<LispType.InlineIf, Lisp, InlineIfCase>;\nexport type IfCase = DefineLisp<LispType.IfCase, Lisp[], Lisp[]>;\nexport type InlineIfCase = DefineLisp<LispType.InlineIfCase, Lisp, Lisp>;\nexport type KeyVal = DefineLisp<LispType.KeyVal, string | Lisp, Lisp>;\nexport type SpreadObject = DefineLisp<LispType.SpreadObject, LispType.None, Lisp>;\nexport type SpreadArray = DefineLisp<LispType.SpreadArray, LispType.None, Lisp>;\nexport type ArrayProp = DefineLisp<LispType.ArrayProp, Lisp, Lisp>;\nexport type Prop = DefineLisp<LispType.Prop, Lisp, string | Lisp>;\nexport type PropOptional = DefineLisp<LispType.PropOptional, Lisp, Lisp[]>;\nexport type Call = DefineLisp<LispType.Call, Lisp, Lisp[]>;\nexport type CallOptional = DefineLisp<LispType.CallOptional, Lisp, Lisp[]>;\nexport type CreateArray = DefineLisp<LispType.CreateArray, Lisp, Lisp[]>;\nexport type CreateObject = DefineLisp<LispType.CreateObject, Lisp, Lisp[]>;\nexport type Group = DefineLisp<LispType.Group, Lisp, Lisp[]>;\nexport type Inverse = DefineLisp<LispType.Inverse, Lisp, Lisp>;\nexport type Not = DefineLisp<LispType.Not, Lisp, Lisp>;\nexport type Negative = DefineLisp<LispType.Negative, Lisp, Lisp>;\nexport type Positive = DefineLisp<LispType.Positive, Lisp, Lisp>;\nexport type Typeof = DefineLisp<LispType.Typeof, Lisp, Lisp>;\nexport type Delete = DefineLisp<LispType.Delete, Lisp, Lisp>;\nexport type IncrementBefore = DefineLisp<LispType.IncrementBefore, Lisp, LispType.None>;\nexport type IncrementAfter = DefineLisp<LispType.IncrementAfter, Lisp, LispType.None>;\nexport type DecrementBefore = DefineLisp<LispType.DecrementBefore, Lisp, LispType.None>;\nexport type DecrementAfter = DefineLisp<LispType.DecrementAfter, Lisp, LispType.None>;\n\nexport type And = DefineLisp<LispType.And, Lisp, Lisp>;\nexport type Or = DefineLisp<LispType.Or, Lisp, Lisp>;\nexport type NullishCoalescing = DefineLisp<LispType.NullishCoalescing, Lisp, Lisp>;\nexport type Instanceof = DefineLisp<LispType.Instanceof, Lisp, Lisp>;\nexport type In = DefineLisp<LispType.In, Lisp, Lisp>;\nexport type Assigns = DefineLisp<LispType.Assign, Lisp, Lisp>;\nexport type SubractEquals = DefineLisp<LispType.SubractEquals, Lisp, Lisp>;\nexport type AddEquals = DefineLisp<LispType.AddEquals, Lisp, Lisp>;\nexport type DivideEquals = DefineLisp<LispType.DivideEquals, Lisp, Lisp>;\nexport type PowerEquals = DefineLisp<LispType.PowerEquals, Lisp, Lisp>;\nexport type MultiplyEquals = DefineLisp<LispType.MultiplyEquals, Lisp, Lisp>;\nexport type ModulusEquals = DefineLisp<LispType.ModulusEquals, Lisp, Lisp>;\nexport type BitNegateEquals = DefineLisp<LispType.BitNegateEquals, Lisp, Lisp>;\nexport type BitAndEquals = DefineLisp<LispType.BitAndEquals, Lisp, Lisp>;\nexport type BitOrEquals = DefineLisp<LispType.BitOrEquals, Lisp, Lisp>;\nexport type UnsignedShiftRightEquals = DefineLisp<LispType.UnsignedShiftRightEquals, Lisp, Lisp>;\nexport type ShiftLeftEquals = DefineLisp<LispType.ShiftLeftEquals, Lisp, Lisp>;\nexport type ShiftRightEquals = DefineLisp<LispType.ShiftRightEquals, Lisp, Lisp>;\n\nexport type BitAnd = DefineLisp<LispType.BitAnd, Lisp, Lisp>;\nexport type BitOr = DefineLisp<LispType.BitOr, Lisp, Lisp>;\nexport type BitNegate = DefineLisp<LispType.BitNegate, Lisp, Lisp>;\nexport type BitShiftLeft = DefineLisp<LispType.BitShiftLeft, Lisp, Lisp>;\nexport type BitShiftRight = DefineLisp<LispType.BitShiftRight, Lisp, Lisp>;\nexport type BitUnsignedShiftRight = DefineLisp<LispType.BitUnsignedShiftRight, Lisp, Lisp>;\nexport type SmallerEqualThan = DefineLisp<LispType.SmallerEqualThan, Lisp, Lisp>;\nexport type LargerEqualThan = DefineLisp<LispType.LargerEqualThan, Lisp, Lisp>;\nexport type SmallerThan = DefineLisp<LispType.SmallerThan, Lisp, Lisp>;\nexport type LargerThan = DefineLisp<LispType.LargerThan, Lisp, Lisp>;\nexport type StrictNotEqual = DefineLisp<LispType.StrictNotEqual, Lisp, Lisp>;\nexport type NotEqual = DefineLisp<LispType.NotEqual, Lisp, Lisp>;\nexport type StrictEqual = DefineLisp<LispType.StrictEqual, Lisp, Lisp>;\nexport type Equal = DefineLisp<LispType.Equal, Lisp, Lisp>;\nexport type Plus = DefineLisp<LispType.Plus, Lisp, Lisp>;\nexport type Minus = DefineLisp<LispType.Minus, Lisp, Lisp>;\nexport type Divide = DefineLisp<LispType.Divide, Lisp, Lisp>;\nexport type Power = DefineLisp<LispType.Power, Lisp, Lisp>;\nexport type Multiply = DefineLisp<LispType.Multiply, Lisp, Lisp>;\nexport type Modulus = DefineLisp<LispType.Modulus, Lisp, Lisp>;\n\nexport type Block = DefineLisp<LispType.Block, Lisp[], LispType.None>;\nexport type Expression = DefineLisp<LispType.Expression, Lisp[], LispType.None>;\nexport type Return = DefineLisp<LispType.Return, LispType.None, Lisp>;\nexport type Throw = DefineLisp<LispType.Throw, LispType.None, Lisp>;\nexport type Switch = DefineLisp<LispType.Switch, Lisp, SwitchCase[]>;\nexport type SwitchCase = DefineLisp<LispType.SwitchCase, LispType.None | Lisp, Lisp[]>;\nexport type Var = DefineLisp<LispType.Var, string, Lisp | LispType.None>;\nexport type Let = DefineLisp<LispType.Let, string, Lisp | LispType.None>;\nexport type Const = DefineLisp<LispType.Const, string, Lisp | LispType.None>;\n\nexport type Number = DefineLisp<LispType.Number, LispType.None, string>;\nexport type BigInt = DefineLisp<LispType.BigInt, LispType.None, string>;\nexport type GlobalSymbol = DefineLisp<LispType.GlobalSymbol, LispType.None, string>;\nexport type LiteralIndex = DefineLisp<LispType.LiteralIndex, LispType.None, string>;\nexport type StringIndex = DefineLisp<LispType.StringIndex, LispType.None, string>;\nexport type RegexIndex = DefineLisp<LispType.RegexIndex, LispType.None, string>;\n\nexport type Function = DefineLisp<\n  LispType.Function,\n  (string | LispType.None | LispType.True)[],\n  string | Lisp[]\n>;\nexport type InlineFunction = DefineLisp<LispType.InlineFunction, string[], string | Lisp[]>;\nexport type ArrowFunction = DefineLisp<LispType.ArrowFunction, string[], string | Lisp[]>;\nexport type Loop = DefineLisp<LispType.Loop, LispItem, Lisp[]>;\nexport type LoopAction = DefineLisp<LispType.LoopAction, string, LispType.None>;\nexport type Try = DefineLisp<LispType.Try, Lisp[], LispItem>;\n\nexport type Void = DefineLisp<LispType.Void, Lisp, LispType.None>;\nexport type Await = DefineLisp<LispType.Await, Lisp, LispType.None>;\nexport type New = DefineLisp<LispType.New, Lisp, Lisp[]>;\nexport type None = DefineLisp<LispType.None, LispType.None, LispType.None>;\n\nexport type LispFamily =\n  | Literal\n  | If\n  | InlineIf\n  | IfCase\n  | InlineIfCase\n  | KeyVal\n  | SpreadObject\n  | SpreadArray\n  | ArrayProp\n  | Prop\n  | PropOptional\n  | Call\n  | CallOptional\n  | CreateArray\n  | CreateObject\n  | Group\n  | Inverse\n  | Not\n  | Negative\n  | Positive\n  | Typeof\n  | Delete\n  | IncrementBefore\n  | IncrementAfter\n  | DecrementBefore\n  | DecrementAfter\n  | And\n  | Or\n  | NullishCoalescing\n  | Instanceof\n  | In\n  | Assigns\n  | SubractEquals\n  | AddEquals\n  | DivideEquals\n  | PowerEquals\n  | MultiplyEquals\n  | ModulusEquals\n  | BitNegateEquals\n  | BitAndEquals\n  | BitOrEquals\n  | UnsignedShiftRightEquals\n  | ShiftLeftEquals\n  | ShiftRightEquals\n  | BitAnd\n  | BitOr\n  | BitNegate\n  | BitShiftLeft\n  | BitShiftRight\n  | BitUnsignedShiftRight\n  | SmallerEqualThan\n  | LargerEqualThan\n  | SmallerThan\n  | LargerThan\n  | StrictNotEqual\n  | NotEqual\n  | StrictEqual\n  | Equal\n  | Plus\n  | Minus\n  | Divide\n  | Power\n  | Multiply\n  | Modulus\n  | Block\n  | Expression\n  | Return\n  | Throw\n  | Switch\n  | SwitchCase\n  | Var\n  | Let\n  | Const\n  | Number\n  | BigInt\n  | GlobalSymbol\n  | LiteralIndex\n  | StringIndex\n  | RegexIndex\n  | Function\n  | InlineFunction\n  | ArrowFunction\n  | Loop\n  | LoopAction\n  | Try\n  | Void\n  | Await\n  | New\n  | None;\n\nexport interface IRegEx {\n  regex: string;\n  flags: string;\n  length: number;\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: Literal[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: Lisp[];\n  constants: IConstants;\n}\n\ntype LispCallback<T> = (\n  strings: IConstants,\n  type: T,\n  part: CodeString,\n  res: string[],\n  expect: string,\n  ctx: { lispTree: Lisp },\n) => any;\nconst lispTypes: Map<string, LispCallback<string>> = new Map();\n\nexport class ParseError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n  ) {\n    super(message + ': ' + code.substring(0, 40));\n  }\n}\n\nlet lastType: CodeString | string;\nlet lastPart: CodeString | string;\nlet lastLastPart: CodeString | string;\nlet lastLastLastPart: CodeString | string;\nlet lastLastLastLastPart: CodeString | string;\n\nconst inlineIfElse = /^:/;\nconst elseIf = /^else(?![\\w$])/;\nconst ifElse = /^if(?![\\w$])/;\nconst space = /^\\s/;\n\nexport const expectTypes = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|%)(?!=)/,\n      op: /^(\\+(?!(\\+))|-(?!(-)))(?!=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!=)|===|==)/,\n      bitwiseShift: /^(<<|>>(?!>)|>>>)(?!=)/,\n      bitwiseAnd: /^(&(?!&))(?!=)/,\n      bitwiseXor: /^(\\^)(?!=)/,\n      bitwiseOr: /^(\\|(?!\\|))(?!=)/,\n      boolOpAnd: /^(&&)/,\n      boolOpOr: /^(\\|\\||instanceof(?![\\w$])|in(?![\\w$]))/,\n      nullishCoalescing: /^\\?\\?/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: ['expEnd'],\n  },\n  assignment: {\n    types: {\n      assignModify: /^(-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  incrementerBefore: {\n    types: { incrementerBefore: /^(\\+\\+|--)/ },\n    next: ['prop'],\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[(]/,\n      incrementerAfter: /^(\\+\\+|--)/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^-(?!-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w$])/,\n      delete: /^delete(?![\\w$])/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z$_])/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z$_][a-zA-Z\\d$_]*/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number:\n        /^(0b[01]+(_[01]+)*|0o[0-7]+(_[0-7]+)*|0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[+-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w$])/,\n      boolean: /^(true|false)(?![\\w$])/,\n      null: /^null(?![\\w$])/,\n      und: /^undefined(?![\\w$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*=>\\s*({)?/,\n      arrowFunction:\n        /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w$])/,\n      Infinity: /^Infinity(?![\\w$])/,\n      void: /^void(?![\\w$])\\s*/,\n      await: /^await(?![\\w$])\\s*/,\n      new: /^new(?![\\w$])\\s*/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*(=)?/,\n      return: /^return(?![\\w$])/,\n      throw: /^throw(?![\\w$])\\s*/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore', 'expEnd'],\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  expEnd: { types: {}, next: [] },\n  expFunction: {\n    types: {\n      function:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: ['expEdge', 'expEnd'],\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*do(?![\\w$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w$])\\s*([a-zA-Z$_][\\w$]*)?/,\n      if: /^((([a-zA-Z$_][\\w$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: ['expEnd'],\n  },\n} as Record<string, { types: Record<string, RegExp>; next: string[] }>;\n\nconst closings = {\n  '(': ')',\n  '[': ']',\n  '{': '}',\n  \"'\": \"'\",\n  '\"': '\"',\n  '`': '`',\n} as Record<string, string>;\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray | null = null;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nconst emptyString = new CodeString('');\n\nconst okFirstChars = /^[+\\-~ !]/;\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w$])|[\\w$]+)/;\nconst semiColon = /^;/;\nconst insertedSemicolons: WeakMap<{ str: string }, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{ str: string }, Map<number, number>> = new WeakMap();\nexport interface restDetails {\n  oneliner?: boolean;\n  words?: string[];\n  lastWord?: string;\n  lastAnyWord?: string;\n  regRes?: RegExpExecArray;\n}\nexport function restOfExp(\n  constants: IConstants,\n  part: CodeString,\n  tests?: RegExp[],\n  quote?: string,\n  firstOpening?: string,\n  closingsTests?: RegExp[],\n  details: restDetails = {},\n): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1)! - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = '';\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i)!;\n    if (quote === '\"' || quote === \"'\" || quote === '`') {\n      if (quote === '`' && char === '$' && part.char(i + 1) === '{' && !escape) {\n        const skip = restOfExp(constants, part.substring(i + 2), [], '{');\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === '\\\\';\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true;\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === '{') {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        const skip = restOfExp(constants, part.substring(i + 1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          const sub = part.substring(i);\n          let found: RegExpExecArray | null;\n          if ((found = testMultiple(sub.toString(), closingsTests))) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray | null;\n      let foundNumber: RegExpExecArray | null;\n      if (closingsTests) {\n        let found: RegExpExecArray | null;\n        if ((found = testMultiple(sub, closingsTests))) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if ((foundNumber = aNumber.exec(sub))) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string] | RegExpExecArray | null = null;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [';'];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true;\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if (foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if (char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = ['splitter', 'expEnd', 'inlineIf'];\n\nconst startingExecpted = [\n  'initialize',\n  'expSingle',\n  'expFunction',\n  'value',\n  'modifier',\n  'prop',\n  'incrementerBefore',\n  'expEnd',\n];\n\nexport const setLispType = <T extends readonly string[]>(types: T, fn: LispCallback<T[number]>) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  });\n};\n\nconst closingsCreate: { [type: string]: RegExp } = {\n  createArray: /^\\]/,\n  createObject: /^\\}/,\n  group: /^\\)/,\n  arrayProp: /^\\]/,\n  call: /^\\)/,\n};\n\nconst typesCreate = {\n  createArray: LispType.CreateArray,\n  createObject: LispType.CreateObject,\n  group: LispType.Group,\n  arrayProp: LispType.ArrayProp,\n  call: LispType.Call,\n  prop: LispType.Prop,\n  '?prop': LispType.PropOptional,\n  '?call': LispType.CallOptional,\n} as any;\n\nsetLispType(\n  ['createArray', 'createObject', 'group', 'arrayProp', 'call'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    let extract = emptyString;\n    const arg: CodeString[] = [];\n    let end = false;\n    let i = res[0].length;\n    const start = i;\n    while (i < part.length && !end) {\n      extract = restOfExp(constants, part.substring(i), [closingsCreate[type], /^,/]);\n      i += extract.length;\n      if (extract.trim().length) {\n        arg.push(extract);\n      }\n      if (part.char(i) !== ',') {\n        end = true;\n      } else {\n        i++;\n      }\n    }\n    const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n    let l: Lisp | Lisp[];\n\n    let funcFound: RegExpExecArray | null;\n    switch (type) {\n      case 'group':\n      case 'arrayProp':\n        l = lispifyExpr(constants, part.substring(start, i));\n        break;\n      case 'call':\n      case 'createArray':\n        // @TODO: support 'empty' values\n        l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n        break;\n      case 'createObject':\n        l = arg.map((str) => {\n          str = str.trimStart();\n          let value: Lisp;\n          let key: string | Lisp = '';\n          funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n          if (funcFound) {\n            key = funcFound[2].trimStart();\n            value = lispify(\n              constants,\n              new CodeString('function ' + str.toString().replace(key, '')),\n            );\n          } else {\n            const extract = restOfExp(constants, str, [/^:/]);\n            key = lispify(constants, extract, [...next, 'spreadObject']) as Prop;\n            if (key[0] === LispType.Prop) {\n              key = (key as Prop)[2];\n            }\n            value = lispify(constants, str.substring(extract.length + 1));\n          }\n          return createLisp<KeyVal>({\n            op: LispType.KeyVal,\n            a: key,\n            b: value,\n          });\n        });\n        break;\n    }\n    const lisptype = (\n      type === 'arrayProp'\n        ? res[1]\n          ? LispType.PropOptional\n          : LispType.Prop\n        : type === 'call'\n          ? res[1]\n            ? LispType.CallOptional\n            : LispType.Call\n          : typesCreate[type]\n    ) as (typeof typesCreate)[keyof typeof typesCreate];\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(i + 1),\n      expectTypes[expect].next,\n      createLisp<\n        ArrayProp | Prop | Call | CreateObject | CreateArray | Group | PropOptional | CallOptional\n      >({\n        op: lisptype,\n        a: ctx.lispTree,\n        b: l,\n      }),\n    );\n  },\n);\n\nconst modifierTypes = {\n  inverse: LispType.Inverse,\n  not: LispType.Not,\n  positive: LispType.Positive,\n  negative: LispType.Negative,\n  typeof: LispType.Typeof,\n  delete: LispType.Delete,\n} as const;\n\nsetLispType(\n  ['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<Inverse | Not | Negative | Positive | Typeof | Delete>({\n        op: modifierTypes[type],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      }),\n    );\n  },\n);\n\nconst incrementTypes = {\n  '++$': LispType.IncrementBefore,\n  '--$': LispType.DecrementBefore,\n  '$++': LispType.IncrementAfter,\n  '$--': LispType.DecrementAfter,\n} as any;\n\nsetLispType(['incrementerBefore'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(2), [/^[^\\s.\\w$]/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + 2),\n    restOfExp.next,\n    createLisp<IncrementBefore | DecrementBefore>({\n      op: incrementTypes[res[0] + '$'],\n      a: lispify(constants, extract, expectTypes[expect].next),\n      b: LispType.None,\n    }),\n  );\n});\n\nsetLispType(['incrementerAfter'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<IncrementAfter | DecrementAfter>({\n      op: incrementTypes['$' + res[0]],\n      a: ctx.lispTree,\n      b: LispType.None,\n    }),\n  );\n});\n\nconst adderTypes = {\n  '&&': LispType.And,\n  '||': LispType.Or,\n  '??': LispType.NullishCoalescing,\n  instanceof: LispType.Instanceof,\n  in: LispType.In,\n  '=': LispType.Assign,\n  '-=': LispType.SubractEquals,\n  '+=': LispType.AddEquals,\n  '/=': LispType.DivideEquals,\n  '**=': LispType.PowerEquals,\n  '*=': LispType.MultiplyEquals,\n  '%=': LispType.ModulusEquals,\n  '^=': LispType.BitNegateEquals,\n  '&=': LispType.BitAndEquals,\n  '|=': LispType.BitOrEquals,\n  '>>>=': LispType.UnsignedShiftRightEquals,\n  '<<=': LispType.ShiftLeftEquals,\n  '>>=': LispType.ShiftRightEquals,\n} as any;\n\nsetLispType(\n  ['assign', 'assignModify', 'nullishCoalescing'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = createLisp<\n      | NullishCoalescing\n      | Assigns\n      | SubractEquals\n      | AddEquals\n      | DivideEquals\n      | PowerEquals\n      | MultiplyEquals\n      | ModulusEquals\n      | BitNegateEquals\n      | BitAndEquals\n      | BitOrEquals\n      | UnsignedShiftRightEquals\n      | ShiftLeftEquals\n      | ShiftRightEquals\n    >({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  },\n);\n\n// Separate handler for boolOpOr (||, instanceof, in) - lower precedence than &&\nsetLispType(['boolOpOr'] as const, (constants, type, part, res, expect, ctx) => {\n  // boolOpOr should allow boolOpOr on the right (same precedence, left-to-right)\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse,\n    expectTypes.splitter.types.boolOpOr,\n  ];\n  const extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + res[0].length),\n    restOfExp.next,\n    createLisp<Or | Instanceof | In>({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, extract, expectTypes[expect].next),\n    }),\n  );\n});\n\n// Separate handler for boolOpAnd (&&) - higher precedence than ||\nsetLispType(['boolOpAnd'] as const, (constants, type, part, res, expect, ctx) => {\n  // boolOpAnd should allow boolOpAnd and boolOpOr on the right\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse,\n    expectTypes.splitter.types.boolOpAnd,\n    expectTypes.splitter.types.boolOpOr,\n  ];\n  const extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + res[0].length),\n    restOfExp.next,\n    createLisp<And>({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, extract, expectTypes[expect].next),\n    }),\n  );\n});\n\nconst opTypes = {\n  '&': LispType.BitAnd,\n  '|': LispType.BitOr,\n  '^': LispType.BitNegate,\n  '<<': LispType.BitShiftLeft,\n  '>>': LispType.BitShiftRight,\n  '>>>': LispType.BitUnsignedShiftRight,\n  '<=': LispType.SmallerEqualThan,\n  '>=': LispType.LargerEqualThan,\n  '<': LispType.SmallerThan,\n  '>': LispType.LargerThan,\n  '!==': LispType.StrictNotEqual,\n  '!=': LispType.NotEqual,\n  '===': LispType.StrictEqual,\n  '==': LispType.Equal,\n  '+': LispType.Plus,\n  '-': LispType.Minus,\n  '/': LispType.Divide,\n  '**': LispType.Power,\n  '*': LispType.Multiply,\n  '%': LispType.Modulus,\n} as any;\n\nsetLispType(\n  ['opHigh', 'op', 'comparitor', 'bitwiseShift', 'bitwiseAnd', 'bitwiseXor', 'bitwiseOr'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const next = [expectTypes.inlineIf.types.inlineIf, inlineIfElse];\n    switch (type) {\n      case 'opHigh':\n        next.push(expectTypes.splitter.types.opHigh);\n      case 'op':\n        next.push(expectTypes.splitter.types.op);\n      case 'comparitor':\n        next.push(expectTypes.splitter.types.comparitor);\n      case 'bitwiseShift':\n        next.push(expectTypes.splitter.types.bitwiseShift);\n      case 'bitwiseAnd':\n        next.push(expectTypes.splitter.types.bitwiseAnd);\n      case 'bitwiseXor':\n        next.push(expectTypes.splitter.types.bitwiseXor);\n      case 'bitwiseOr':\n        next.push(expectTypes.splitter.types.bitwiseOr);\n        next.push(expectTypes.splitter.types.boolOpAnd);\n        next.push(expectTypes.splitter.types.boolOpOr);\n    }\n    const extract = restOfExp(constants, part.substring(res[0].length), next);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<\n        | BitAnd\n        | BitOr\n        | BitNegate\n        | BitShiftLeft\n        | BitShiftRight\n        | BitUnsignedShiftRight\n        | SmallerEqualThan\n        | LargerEqualThan\n        | SmallerThan\n        | LargerThan\n        | StrictNotEqual\n        | NotEqual\n        | StrictEqual\n        | Equal\n        | Plus\n        | Minus\n        | Divide\n        | Power\n        | Multiply\n        | Modulus\n      >({\n        op: opTypes[res[0]],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      }),\n    );\n  },\n);\n\nsetLispType(['inlineIf'] as const, (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  const extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while (!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse,\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++;\n    } else {\n      quoteCount--;\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = createLisp<InlineIf>({\n    op: LispType.InlineIf,\n    a: ctx.lispTree,\n    b: createLisp<InlineIfCase>({\n      op: LispType.InlineIfCase,\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1)),\n    }),\n  });\n});\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString | undefined;\n  let first = true;\n  let elseReg: RegExpExecArray | null;\n  let details: restDetails = {};\n  while (\n    (found = restOfExp(\n      constants,\n      part.substring(found.end - part.start),\n      [elseIf, ifElse, semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details,\n    )).length ||\n    first\n  ) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n\n    if (f.startsWith('if')) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if ((elseReg = /^;?\\s*else(?![\\w$])/.exec(f))) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      const ie = extractIfElse(\n        constants,\n        part.substring(found.end - part.start + (/^;?\\s*else(?![\\w$])/.exec(f)?.[0].length || 0)),\n      );\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {\n    all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start),\n    true: foundTrue,\n    false: foundElse,\n  };\n}\n\nsetLispType(['if'] as const, (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], '(');\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n\n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n\n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === '{') trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === '{') elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = createLisp<If>({\n    op: LispType.If,\n    a: lispifyExpr(constants, condition),\n    b: createLisp<IfCase>({\n      op: LispType.IfCase,\n      a: lispifyBlock(trueBlock, constants),\n      b: lispifyBlock(elseBlock, constants),\n    }),\n  });\n});\n\nsetLispType(['switch'] as const, (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], '(');\n  let start = part.toString().indexOf('{', res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError('Invalid switch');\n  let statement = insertSemicolons(\n    constants,\n    restOfExp(constants, part.substring(start + 1), [], '{'),\n  );\n  let caseFound: RegExpExecArray | null;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  const cases: SwitchCase[] = [];\n  let defaultFound = false;\n  while ((caseFound = caseTest.exec(statement.toString()))) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError('Only one default switch case allowed');\n      defaultFound = true;\n    }\n    const cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = (start = caseFound[0].length + cond.length + 1);\n    const bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs: Lisp[] = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], '{');\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      const notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while ((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(\n      createLisp<SwitchCase>({\n        op: LispType.SwitchCase,\n        a: caseFound[1] === 'default' ? LispType.None : lispifyExpr(constants, cond),\n        b: exprs,\n      }),\n    );\n  }\n  ctx.lispTree = createLisp<Switch>({\n    op: LispType.Switch,\n    a: lispifyExpr(constants, test),\n    b: cases,\n  });\n});\n\nsetLispType(['dot', 'prop'] as const, (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    const matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length;\n    } else {\n      throw new SyntaxError('Hanging dot');\n    }\n  } else {\n    if (reservedWords.has(prop) && prop !== 'this') {\n      throw new SyntaxError(`Unexpected token '${prop}'`);\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(index),\n    expectTypes[expect].next,\n    createLisp<Prop | PropOptional>({\n      op: typesCreate[op],\n      a: ctx.lispTree,\n      b: prop,\n    }),\n  );\n});\n\nsetLispType(['spreadArray', 'spreadObject'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<SpreadArray | SpreadObject>({\n    op: type === 'spreadArray' ? LispType.SpreadArray : LispType.SpreadObject,\n    a: LispType.None,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n  });\n});\n\nsetLispType(['return', 'throw'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Return | Throw>({\n    op: type === 'return' ? LispType.Return : LispType.Throw,\n    a: LispType.None,\n    b: lispifyExpr(constants, part.substring(res[0].length)),\n  });\n});\n\nsetLispType(\n  ['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Number | BigInt | GlobalSymbol>({\n        op:\n          type === 'number' ? (res[12] ? LispType.BigInt : LispType.Number) : LispType.GlobalSymbol,\n        a: LispType.None,\n        b: res[12] ? res[1] : res[0],\n      }),\n    );\n  },\n);\n\nsetLispType(['string', 'literal', 'regex'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<StringIndex | LiteralIndex | RegexIndex>({\n      op:\n        type === 'string'\n          ? LispType.StringIndex\n          : type === 'literal'\n            ? LispType.LiteralIndex\n            : LispType.RegexIndex,\n      a: LispType.None,\n      b: res[1],\n    }),\n  );\n});\n\nsetLispType(['initialize'] as const, (constants, type, part, res, expect, ctx) => {\n  const lt = res[1] === 'var' ? LispType.Var : res[1] === 'let' ? LispType.Let : LispType.Const;\n  if (!res[3]) {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Var | Let | Const>({\n        op: lt,\n        a: res[2],\n        b: LispType.None,\n      }),\n    );\n  } else {\n    ctx.lispTree = createLisp<Var | Let | Const>({\n      op: lt,\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  }\n});\n\nsetLispType(\n  ['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const isArrow = type !== 'function' && type !== 'inlineFunction';\n    const isReturn = isArrow && !res[res.length - 1];\n    const argPos = isArrow ? 2 : 3;\n    const isAsync = res[1] ? LispType.True : LispType.None;\n    const args: string[] = res[argPos] ? res[argPos].replace(/\\s+/g, '').split(/,/g) : [];\n    if (!isArrow) {\n      args.unshift((res[2] || '').trimStart());\n    }\n    let ended = false;\n    args.forEach((arg: string) => {\n      if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n      if (arg.startsWith('...')) ended = true;\n    });\n    const f = restOfExp(\n      constants,\n      part.substring(res[0].length),\n      !isReturn ? [/^}/] : [/^[,)}\\]]/, semiColon],\n    );\n    const func = isReturn ? 'return ' + f : f.toString();\n    args.forEach((arg: string) => {\n      if (reservedWords.has(arg.replace(/^\\.\\.\\./, ''))) {\n        throw new SyntaxError(`Unexpected token '${arg}'`);\n      }\n    });\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length + func.length + 1),\n      expectTypes[expect].next,\n      createLisp<Function | InlineFunction | ArrowFunction>({\n        op: isArrow\n          ? LispType.ArrowFunction\n          : type === 'function'\n            ? LispType.Function\n            : LispType.InlineFunction,\n        a: [isAsync, ...args],\n        b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func,\n      }),\n    );\n  },\n);\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s+(in|of)(?![\\w$])/;\nsetLispType(['for', 'do', 'while'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = LispType.True;\n  let startInternal: Lisp[] = [];\n  let getIterator: Lisp | LispType.None = LispType.None;\n  let beforeStep: LispItem = LispType.None;\n  let checkFirst = LispType.True;\n  let condition: LispItem;\n  let step: LispItem = LispType.True;\n  let body: CodeString;\n  switch (type) {\n    case 'while': {\n      i = part.toString().indexOf('(') + 1;\n      const extract = restOfExp(constants, part.substring(i), [], '(');\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n      break;\n    }\n    case 'for': {\n      i = part.toString().indexOf('(') + 1;\n      const args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++) {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === ')') break;\n      }\n      let iterator: RegExpExecArray | null;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          ((getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [ofStart2, ofStart3]));\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$next.value'),\n            ['initialize'],\n          );\n        } else {\n          ((getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [inStart2, inStart3]));\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'),\n            ['initialize'],\n          );\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift()!, startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift()!);\n        step = lispifyExpr(constants, args.shift()!);\n      } else {\n        throw new SyntaxError('Invalid for loop definition');\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n\n      break;\n    }\n    case 'do': {\n      checkFirst = LispType.None;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(\n        constants,\n        restOfExp(\n          constants,\n          part.substring(part.toString().indexOf('(', res[0].length + body.length) + 1),\n          [],\n          '(',\n        ),\n      );\n      break;\n    }\n  }\n  const a = [\n    checkFirst,\n    startInternal,\n    getIterator,\n    startStep,\n    step,\n    condition,\n    beforeStep,\n  ] as LispItem;\n  ctx.lispTree = createLisp<Loop>({\n    op: LispType.Loop,\n    a,\n    b: lispifyBlock(body, constants),\n  });\n});\n\nsetLispType(['block'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Block>({\n    op: LispType.Block,\n    a: lispifyBlock(restOfExp(constants, part.substring(1), [], '{'), constants),\n    b: LispType.None,\n  });\n});\n\nsetLispType(['loopAction'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<LoopAction>({\n    op: LispType.LoopAction,\n    a: res[1],\n    b: LispType.None,\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\))?|finally)\\s*\\{/;\nsetLispType(['try'] as const, (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], '{');\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception = '';\n  let catchBody;\n  let offset = 0;\n  if (catchRes![1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes![2];\n    catchBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{',\n    );\n    offset = res[0].length + body.length + 1 + catchRes![0].length + catchBody.length + 1;\n    if (\n      (catchRes = catchReg.exec(part.substring(offset).toString())) &&\n      catchRes[1].startsWith('finally')\n    ) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], '{');\n    }\n  } else {\n    finallyBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{',\n    );\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ] as LispItem;\n  ctx.lispTree = createLisp<Try>({\n    op: LispType.Try,\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b,\n  });\n});\n\nsetLispType(['void', 'await'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length + extract.length),\n    expectTypes[expect].next,\n    createLisp<Void | Await>({\n      op: type === 'void' ? LispType.Void : LispType.Await,\n      a: lispify(constants, extract),\n      b: LispType.None,\n    }),\n  );\n});\n\nsetLispType(['new'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, '(');\n  i += obj.length + 1;\n  const args: CodeString[] = [];\n  if (part.char(i - 1) === '(') {\n    const argsString = restOfExp(constants, part.substring(i), [], '(');\n    i += argsString.length + 1;\n    let found: CodeString;\n    let j = 0;\n    while ((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(i),\n    expectTypes.expEdge.next,\n    createLisp({\n      op: LispType.New,\n      a: lispify(constants, obj, expectTypes.initialize.next),\n      b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n    }),\n  );\n});\n\nconst ofStart2 = lispify(\n  undefined as any,\n  new CodeString('let $$iterator = $$obj[Symbol.iterator]()'),\n  ['initialize'],\n);\nconst ofStart3 = lispify(undefined as any, new CodeString('let $$next = $$iterator.next()'), [\n  'initialize',\n]);\nconst ofCondition = lispify(undefined as any, new CodeString('return !$$next.done'), [\n  'initialize',\n]);\nconst ofStep = lispify(undefined as any, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined as any, new CodeString('let $$keys = Object.keys($$obj)'), [\n  'initialize',\n]);\nconst inStart3 = lispify(undefined as any, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined as any, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined as any, new CodeString('return $$keyIndex < $$keys.length'), [\n  'initialize',\n]);\n\nfunction lispify(\n  constants: IConstants,\n  part: CodeString,\n  expected?: readonly string[],\n  lispTree?: Lisp,\n  topLevel = false,\n): Lisp {\n  lispTree = lispTree || NullLisp;\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError('Unexpected end of expression');\n  }\n  if (!part.length) return lispTree;\n\n  const ctx = { lispTree: lispTree };\n\n  let res: any;\n  for (const expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (const type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if ((res = expectTypes[expect].types[type].exec(str))) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)?.(constants, type, part, res, expect, ctx);\n        } catch (e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: readonly string[]): Lisp {\n  if (!str.trimStart().length) return NullLisp;\n  const subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    const defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return createLisp<Block>({\n        op: LispType.Block,\n        a: subExpressions.map((str, i) =>\n          lispify(\n            constants,\n            i ? new CodeString(defined![1] + ' ' + str) : str,\n            ['initialize'],\n            undefined,\n            true,\n          ),\n        ),\n        b: LispType.None,\n      });\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = subExpressions.map((str) => lispify(constants, str, expected, undefined, true));\n  return createLisp<Expression>({ op: LispType.Expression, a: exprs, b: LispType.None });\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return createLisp<Return>({\n    op: LispType.Return,\n    a: LispType.None,\n    b: lispifyExpr(constants, str),\n  });\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return [];\n  const parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while (\n    (part = restOfExp(\n      constants,\n      str.substring(pos),\n      [semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details,\n    )).length\n  ) {\n    isInserted = !!(str.char(pos + part.length) && str.char(pos + part.length) !== ';');\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (\n      details['words']?.includes('do') &&\n      /^\\s*while(?![\\w$])/.test(str.substring(pos).toString())\n    ) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return parts\n    .map((str) => str.trimStart())\n    .filter((str) => str.length)\n    .map((str) => {\n      return lispifyExpr(constants, str.trimStart(), startingExecpted);\n    });\n}\n\nexport function lispifyFunction(\n  str: CodeString,\n  constants: IConstants,\n  expression = false,\n): Lisp[] {\n  if (!str.trim().length) return [];\n  const tree = lispifyBlock(str, constants, expression);\n  hoist(tree);\n  return tree;\n}\n\nfunction hoist(item: LispItem, res: Lisp[] = []): boolean {\n  if (isLisp(item)) {\n    if (!isLisp<LispFamily>(item)) return false;\n    const [op, a, b] = item;\n    if (\n      op === LispType.Try ||\n      op === LispType.If ||\n      op === LispType.Loop ||\n      op === LispType.Switch\n    ) {\n      hoist(a, res);\n      hoist(b, res);\n    } else if (op === LispType.Var) {\n      res.push(createLisp({ op: LispType.Var, a: a, b: LispType.None }));\n    } else if (op === LispType.Function && a[1]) {\n      res.push(item);\n      return true;\n    }\n  } else if (Array.isArray(item)) {\n    const rep: LispItemSingle[] = [];\n    for (const it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...res, ...rep);\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w$])/;\n//  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5\nconst colonsRegex = /^((([\\w$\\])\"'`]|\\+\\+|--)\\s*\\r?\\n\\s*([\\w$+\\-!~]))|(\\}\\s*[\\w$!~+\\-{(\"'`]))/;\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while (\n    (sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length\n  ) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [, , a, , , b] = details.regRes;\n      edge = details.regRes[3] === '++' || details.regRes[3] === '--' ? sub.length + 1 : sub.length;\n      part = rest.substring(0, edge);\n      if (b) {\n        const res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (\n          details.lastWord === 'function' &&\n          details.regRes[5][0] === '}' &&\n          details.regRes[5].slice(-1) === '('\n        ) {\n          valid = false;\n        }\n      } else if (a) {\n        if (\n          details.lastWord === 'if' ||\n          details.lastWord === 'while' ||\n          details.lastWord === 'for' ||\n          details.lastWord === 'else'\n        ) {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = str[i] === '/' && !escape;\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  const after = str.substring(i);\n  cancel = cancel || !done || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  const flags = /^[a-z]*/.exec(after);\n  if (/^\\s+[\\w$]/.test(str.substring(i + flags![0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i - 1),\n    flags: (flags && flags[0]) || '',\n    length: i + ((flags && flags[0].length) || 0),\n  };\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/;\nconst possibleDivide = /^([\\w$\\])]|\\+\\+|--)[\\s/]/;\nexport function extractConstants(\n  constants: IConstants,\n  str: string,\n  currentEnclosure = '',\n): { str: string; length: number } {\n  let quote;\n  let extract: (string | number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx | null;\n  let comment = '';\n  let commentStart = -1;\n  let currJs: string[] = [];\n  let char = '';\n  const strRes: (string | number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray | null = null;\n  let i = 0;\n  for (i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === '*' && str[i + 1] === '/') {\n          comment = '';\n          i++;\n        } else if (comment === '\\n') {\n          comment = '';\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === '`' && char === '$' && str[i + 1] === '{') {\n          const skip = extractConstants(constants, str.substring(i + 2), '{');\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            const li = createLisp<Literal>({\n              op: LispType.Literal,\n              a: unraw(extract.join('')),\n              b: [],\n            });\n            li.tempJsStrings = currJs;\n            constants.literals.push(li);\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join('')));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if (char === \"'\" || char === '\"' || char === '`') {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return { str: strRes.join(''), length: i };\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length - 1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === '/' && (str[i + 1] === '*' || str[i + 1] === '/')) {\n          comment = str[i + 1] === '*' ? '*' : '\\n';\n          commentStart = i;\n        } else if (\n          char === '/' &&\n          !isPossibleDivide &&\n          (regexFound = checkRegex(str.substring(i)))\n        ) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if ((isPossibleDivide = possibleDivide.exec(str.substring(i)))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = !!(quote && char === '\\\\');\n    }\n  }\n\n  if (comment) {\n    if (comment === '*') {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`);\n    }\n  }\n  return { str: strRes.join(''), length: i };\n}\n\nexport default function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = { strings: [], literals: [], regexes: [], eager };\n  str = extractConstants(constants, str).str;\n\n  for (const l of constants.literals) {\n    l[2] = l.tempJsStrings!.map((js: string) => lispifyExpr(constants, new CodeString(js)));\n    delete l.tempJsStrings;\n  }\n  return { tree: lispifyFunction(new CodeString(str), constants, expression), constants };\n}\n","import { createFunction, createFunctionAsync, currentTicks } from './executor.js';\nimport parse, { lispifyFunction } from './parser.js';\nimport { IExecContext, Ticks } from './utils.js';\n\nexport interface IEvalContext {\n  sandboxFunction: typeof sandboxFunction;\n  sandboxAsyncFunction: typeof sandboxAsyncFunction;\n  sandboxedEval: typeof sandboxedEval;\n  sandboxedSetTimeout: typeof sandboxedSetTimeout;\n  sandboxedSetInterval: typeof sandboxedSetInterval;\n  sandboxedClearTimeout: typeof sandboxedClearTimeout;\n  sandboxedClearInterval: typeof sandboxedClearInterval;\n  lispifyFunction: typeof lispifyFunction;\n}\nexport type SandboxFunction = (code: string, ...args: string[]) => () => unknown;\nexport type SandboxEval = (code: string) => unknown;\nexport type SandboxSetTimeout = (\n  handler: TimerHandler,\n  timeout?: number,\n  ...args: unknown[]\n) => any;\nexport type SandboxSetInterval = (\n  handler: TimerHandler,\n  timeout?: number,\n  ...args: unknown[]\n) => any;\nexport type SandboxClearTimeout = (handle: number) => void;\nexport type SandboxClearInterval = (handle: number) => void;\n\nexport function createEvalContext(): IEvalContext {\n  return {\n    sandboxFunction,\n    sandboxAsyncFunction,\n    sandboxedEval,\n    sandboxedSetTimeout,\n    sandboxedSetInterval,\n    sandboxedClearTimeout,\n    sandboxedClearInterval,\n    lispifyFunction,\n  };\n}\n\nexport function sandboxFunction(context: IExecContext, ticks?: Ticks): SandboxFunction {\n  return SandboxFunction;\n  function SandboxFunction(...params: string[]) {\n    const code = params.pop() || '';\n    const parsed = parse(code);\n    return createFunction(\n      params,\n      parsed.tree,\n      ticks || currentTicks.current,\n      {\n        ...context,\n        constants: parsed.constants,\n        tree: parsed.tree,\n      },\n      undefined,\n      'anonymous',\n    );\n  }\n}\n\nexport type SandboxAsyncFunction = (code: string, ...args: string[]) => () => Promise<unknown>;\nexport function sandboxAsyncFunction(context: IExecContext, ticks?: Ticks): SandboxAsyncFunction {\n  return SandboxAsyncFunction;\n  function SandboxAsyncFunction(...params: string[]) {\n    const code = params.pop() || '';\n    const parsed = parse(code);\n    return createFunctionAsync(\n      params,\n      parsed.tree,\n      ticks || currentTicks.current,\n      {\n        ...context,\n        constants: parsed.constants,\n        tree: parsed.tree,\n      },\n      undefined,\n      'anonymous',\n    );\n  }\n}\n\nexport function sandboxedEval(func: SandboxFunction): SandboxEval {\n  return sandboxEval;\n  function sandboxEval(code: string) {\n    return func(code)();\n  }\n}\n\nexport function sandboxedSetTimeout(\n  func: SandboxFunction,\n  context: IExecContext,\n): SandboxSetTimeout {\n  return function sandboxSetTimeout(handler, timeout, ...args) {\n    const sandbox = context.ctx.sandbox;\n    const exec = (...a: any[]) => {\n      const h = typeof handler === 'string' ? func(handler) : handler;\n      haltsub.unsubscribe();\n      contsub.unsubscribe();\n      sandbox.setTimeoutHandles.delete(sandBoxhandle);\n      return h(...a);\n    };\n\n    const sandBoxhandle = ++sandbox.timeoutHandleCounter;\n\n    let start = Date.now();\n    let handle: number = setTimeout(exec, timeout, ...args);\n\n    let elapsed = 0;\n    const haltsub = sandbox.subscribeHalt(() => {\n      elapsed = Date.now() - start + elapsed;\n      clearTimeout(handle);\n    });\n    const contsub = sandbox.subscribeResume(() => {\n      start = Date.now();\n      const remaining = Math.floor((timeout || 0) - elapsed);\n      handle = setTimeout(exec, remaining, ...args);\n      sandbox.setTimeoutHandles.set(sandBoxhandle, {\n        handle,\n        haltsub,\n        contsub,\n      });\n    });\n    sandbox.setTimeoutHandles.set(sandBoxhandle, {\n      handle,\n      haltsub,\n      contsub,\n    });\n    return sandBoxhandle;\n  };\n}\n\nexport function sandboxedClearTimeout(context: IExecContext): SandboxClearTimeout {\n  return function sandboxClearTimeout(handle: number) {\n    const sandbox = context.ctx.sandbox;\n    const timeoutHandle = sandbox.setTimeoutHandles.get(handle);\n    if (timeoutHandle) {\n      clearTimeout(timeoutHandle.handle);\n      timeoutHandle.haltsub.unsubscribe();\n      timeoutHandle.contsub.unsubscribe();\n      sandbox.setTimeoutHandles.delete(handle);\n    }\n  };\n}\nexport function sandboxedClearInterval(context: IExecContext): SandboxClearInterval {\n  return function sandboxClearInterval(handle: number) {\n    const sandbox = context.ctx.sandbox;\n    const intervalHandle = sandbox.setIntervalHandles.get(handle);\n    if (intervalHandle) {\n      clearInterval(intervalHandle.handle);\n      intervalHandle.haltsub.unsubscribe();\n      intervalHandle.contsub.unsubscribe();\n      sandbox.setIntervalHandles.delete(handle);\n    }\n  };\n}\n\nexport function sandboxedSetInterval(\n  func: SandboxFunction,\n  context: IExecContext,\n): SandboxSetInterval {\n  return function sandboxSetInterval(handler, timeout, ...args) {\n    const sandbox = context.ctx.sandbox;\n    const h = typeof handler === 'string' ? func(handler) : handler;\n    const exec = (...a: any[]) => {\n      start = Date.now();\n      elapsed = 0;\n      return h(...a);\n    };\n\n    const sandBoxhandle = ++sandbox.timeoutHandleCounter;\n\n    let start = Date.now();\n    let handle: number = setInterval(exec, timeout, ...args);\n\n    let elapsed = 0;\n    const haltsub = sandbox.subscribeHalt(() => {\n      elapsed = Date.now() - start + elapsed;\n      clearInterval(handle);\n    });\n    const contsub = sandbox.subscribeResume(() => {\n      start = Date.now();\n      handle = setTimeout(\n        () => {\n          start = Date.now();\n          elapsed = 0;\n          handle = setInterval(exec, timeout, ...args);\n          exec(...args);\n        },\n        Math.floor((timeout || 0) - elapsed),\n        ...args,\n      );\n      handlObj.handle = handle;\n    });\n\n    const handlObj = {\n      handle,\n      haltsub,\n      contsub,\n    };\n    sandbox.setIntervalHandles.set(sandBoxhandle, handlObj);\n    return sandBoxhandle;\n  };\n}\n","import { IEvalContext } from './eval.js';\nimport { Change, ExecReturn, executeTree, executeTreeAsync } from './executor.js';\nimport {\n  createContext,\n  IContext,\n  IExecContext,\n  IGlobals,\n  IOptionParams,\n  IOptions,\n  IScope,\n  replacementCallback,\n  SandboxExecutionQuotaExceededError,\n  SandboxGlobal,\n  Scope,\n  SubscriptionSubject,\n  Ticks,\n} from './utils.js';\n\nexport {\n  IOptions,\n  IContext,\n  IExecContext,\n  LocalScope,\n  SandboxExecutionTreeError,\n  SandboxCapabilityError,\n  SandboxAccessError,\n  SandboxError,\n} from './utils.js';\n\nfunction subscribeSet(\n  obj: object,\n  name: string,\n  callback: (modification: Change) => void,\n  context: {\n    setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  },\n): { unsubscribe: () => void } {\n  const names =\n    context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  const val = (obj as any)[name] as unknown;\n  if (val instanceof Object) {\n    changeCbs = context.changeSubscriptions.get(val) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(val, changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    },\n  };\n}\n\nexport default class SandboxExec {\n  public readonly context: IContext;\n  public readonly setSubscriptions: WeakMap<\n    SubscriptionSubject,\n    Map<string, Set<(modification: Change) => void>>\n  > = new WeakMap();\n  public readonly changeSubscriptions: WeakMap<\n    SubscriptionSubject,\n    Set<(modification: Change) => void>\n  > = new WeakMap();\n  public readonly sandboxFunctions: WeakMap<Function, IExecContext> = new WeakMap();\n  private haltSubscriptions: Set<\n    (args?: { error: Error; ticks: Ticks; scope: Scope; context: IExecContext }) => void\n  > = new Set();\n  private resumeSubscriptions: Set<() => void> = new Set();\n  public halted = false;\n  timeoutHandleCounter = 0;\n  public readonly setTimeoutHandles = new Map<number, {\n    handle: number,\n    haltsub: { unsubscribe: () => void },\n    contsub: { unsubscribe: () => void },\n  }>();\n  public readonly setIntervalHandles = new Map<\n    number,\n    {\n      handle: number;\n      haltsub: { unsubscribe: () => void };\n      contsub: { unsubscribe: () => void };\n    }\n  >();\n  constructor(\n    options?: IOptionParams,\n    public evalContext?: IEvalContext,\n  ) {\n    const opt: IOptions = Object.assign(\n      {\n        audit: false,\n        forbidFunctionCalls: false,\n        forbidFunctionCreation: false,\n        globals: SandboxExec.SAFE_GLOBALS,\n        prototypeWhitelist: SandboxExec.SAFE_PROTOTYPES,\n        prototypeReplacements: new Map<new () => any, replacementCallback>(),\n      },\n      options || {},\n    );\n    this.context = createContext(this, opt);\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      globalThis,\n      Function,\n      eval,\n      console: {\n        debug: console.debug,\n        error: console.error,\n        info: console.info,\n        log: console.log,\n        table: console.table,\n        warn: console.warn,\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp,\n    };\n  }\n\n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    const protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp,\n    ];\n    const map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(\n      Object,\n      new Set([\n        'constructor',\n        'name',\n        'entries',\n        'fromEntries',\n        'getOwnPropertyNames',\n        'is',\n        'keys',\n        'hasOwnProperty',\n        'isPrototypeOf',\n        'propertyIsEnumerable',\n        'toLocaleString',\n        'toString',\n        'valueOf',\n        'values',\n      ]),\n    );\n    return map;\n  }\n\n  subscribeGet(\n    callback: (obj: SubscriptionSubject, name: string) => void,\n    context: IExecContext,\n  ): { unsubscribe: () => void } {\n    context.getSubscriptions.add(callback);\n    return { unsubscribe: () => context.getSubscriptions.delete(callback) };\n  }\n\n  subscribeSet(\n    obj: object,\n    name: string,\n    callback: (modification: Change) => void,\n    context: SandboxExec | IExecContext,\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(\n    obj: SubscriptionSubject,\n    name: string,\n    callback: (modification: Change) => void,\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  subscribeHalt(\n    cb: (args?: { error: Error; ticks: Ticks; scope: Scope; context: IExecContext }) => void,\n  ) {\n    this.haltSubscriptions.add(cb);\n    return {\n      unsubscribe: () => {\n        this.haltSubscriptions.delete(cb);\n      },\n    };\n  }\n  subscribeResume(cb: () => void) {\n    this.resumeSubscriptions.add(cb);\n    return {\n      unsubscribe: () => {\n        this.resumeSubscriptions.delete(cb);\n      },\n    };\n  }\n\n  haltExecution(haltContext?: { error: Error; ticks: Ticks; scope: Scope; context: IExecContext }) {\n    if (this.halted) return;\n    this.halted = true;\n    for (const cb of this.haltSubscriptions) {\n      cb(haltContext);\n    }\n  }\n\n  resumeExecution() {\n    if (!this.halted) return;\n    if (this.context.ticks.tickLimit && this.context.ticks.ticks >= this.context.ticks.tickLimit) {\n      throw new SandboxExecutionQuotaExceededError('Cannot resume execution: tick limit exceeded');\n    }\n    this.halted = false;\n    for (const cb of this.resumeSubscriptions) {\n      cb();\n    }\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: IScope[] = []): ExecReturn<T> {\n    return executeTree(context.ctx.ticks, context, context.tree, scopes);\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: IScope[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync(context.ctx.ticks, context, context.tree, scopes);\n  }\n}\n","import { createExecContext, IExecContext, IOptionParams, IScope } from './utils.js';\nimport { createEvalContext } from './eval.js';\nimport { ExecReturn } from './executor.js';\nimport parse from './parser.js';\nimport SandboxExec from './SandboxExec.js';\nexport {\n  LocalScope,\n  SandboxExecutionTreeError,\n  SandboxCapabilityError,\n  SandboxAccessError,\n  SandboxError,\n} from './utils.js';\n\nexport default class Sandbox extends SandboxExec {\n  constructor(options?: IOptionParams) {\n    super(options, createEvalContext());\n  }\n\n  static audit<T>(code: string, scopes: IScope[] = []): ExecReturn<T> {\n    const globals: Record<string, unknown> = {};\n    for (const i of Object.getOwnPropertyNames(globalThis) as [keyof typeof globalThis]) {\n      globals[i] = globalThis[i];\n    }\n    const sandbox = new SandboxExec({\n      globals,\n      audit: true,\n    });\n    return sandbox.executeTree(\n      createExecContext(sandbox, parse(code, true), createEvalContext()),\n      scopes,\n    );\n  }\n\n  static parse(code: string) {\n    return parse(code);\n  }\n\n  compile<T>(\n    code: string,\n    optimize = false,\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => T } {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return { context, run: () => this.executeTree<T>(context, [...scopes]).result };\n    };\n    return exec;\n  }\n\n  compileAsync<T>(\n    code: string,\n    optimize = false,\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => Promise<T> } {\n    const parsed = parse(code, optimize);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {\n        context,\n        run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result),\n      };\n    };\n    return exec;\n  }\n\n  compileExpression<T>(\n    code: string,\n    optimize = false,\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => T } {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return { context, run: () => this.executeTree<T>(context, [...scopes]).result };\n    };\n    return exec;\n  }\n\n  compileExpressionAsync<T>(\n    code: string,\n    optimize = false,\n  ): (...scopes: IScope[]) => { context: IExecContext; run: () => Promise<T> } {\n    const parsed = parse(code, optimize, true);\n    const exec = (...scopes: IScope[]) => {\n      const context = createExecContext(this, parsed, this.evalContext);\n      return {\n        context,\n        run: () => this.executeTreeAsync<T>(context, [...scopes]).then((ret) => ret.result),\n      };\n    };\n    return exec;\n  }\n}\n"],"names":["AsyncFunction","Object","getPrototypeOf","async","constructor","GeneratorFunction","AsyncGeneratorFunction","SandboxGlobal","globals","i","this","ExecContext","ctx","constants","tree","getSubscriptions","setSubscriptions","changeSubscriptions","setSubscriptionsGlobal","changeSubscriptionsGlobal","evals","registerSandboxFunction","allowJit","evalContext","createContext","sandbox","options","sandboxGlobal","context","globalsWhitelist","Set","values","prototypeWhitelist","Map","map","a","prototype","globalScope","Scope","ticks","tickLimit","executionQuota","sandboxedFunctions","WeakSet","set","Symbol","iterator","createExecContext","executionTree","execContext","WeakMap","fn","sandboxFunctions","func","sandboxFunction","asyncFunc","sandboxAsyncFunction","Function","eval","sandboxedEval","setTimeout","sandboxedSetTimeout","setInterval","sandboxedSetInterval","clearTimeout","sandboxedClearTimeout","clearInterval","sandboxedClearInterval","key","value","CodeString","str","ref","start","end","length","substring","undefined","code","len","char","toString","trimStart","found","exec","slice","trim","valueOf","keysOnly","obj","ret","assign","reservedWords","parent","vars","functionThis","const","let","var","isFuncScope","allVars","get","isThis","scope","getWhereValScope","Prop","val","SyntaxError","has","prop","ReferenceError","TypeError","isConst","isGlobal","SandboxError","hasOwnProperty","getWhereVarScope","localScope","declare","type","existingScope","LocalScope","Error","SandboxExecutionQuotaExceededError","SandboxExecutionTreeError","SandboxCapabilityError","SandboxAccessError","isLisp","item","Array","isArray","isVariable","forEach","cb","call","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","optional","generateArgs","argNames","args","arg","startsWith","createFunction","parsed","name","forbidFunctionCreation","executeTree","add","createFunctionAsync","Promise","executeTreeAsync","assignCheck","op","arrayChange","push","pop","shift","unshift","splice","reverse","sort","copyWithin","KeyVal","SpreadObject","SpreadArray","If","t","f","literalRegex","ops","addOps","isPropertyKey","includes","hasPossibleProperties","getGlobalProp","isFunc","p","globalThis","e","valueOrProp","execMany","done","inLoopOrSwitch","execSync","_execManySync","_execManyAsync","catch","res","syncDone","d","ad","asyncDone","execAsync","isInstant","instant","callback","resolve","reject","err","r","doneOriginal","_execNoneRecurse","bobj","b","performOp","checkHaltAsync","promise","subres","subhalt","halted","doResolve","interupted","unsubscribe","subscribeHalt","subscribeResume","finally","allSettled","then","checkHaltExpectedTicks","params","expectTicks","sub","o","haltOnSandboxError","haltExecution","error","BigInt","audit","globalsAccess","prototypeAccess","prot","whitelist","replace","prototypeReplacements","size","g","forbidFunctionCalls","vals","flat","JSON","stringify","cache","recurse","x","y","keys","change","changed","added","removed","startIndex","deleteCount","Math","min","endIndex","NaN","Infinity","Number","strings","parseInt","reg","regexes","RegExp","regex","flags","literals","js","resnums","processed","reses","num","match","$$","$","s","lispifyFunction","isAsync","checkFirst","startInternal","getIterator","startStep","step","condition","beforeStep","loop","loopScope","internalVars","$$obj","interalScope","innerLoopVars","toTest","isTrue","caseItem","exception","catchBody","finallyBody","executeTreeWithDone","unexecTypes","currentTicks","current","scopes","_executeWithDoneSync","_executeWithDoneAsync","parseHexToInt","hex","validateAndParseHex","errorName","enforcedLength","parsedHex","isNaN","parseHexadecimalCode","parsedCode","String","fromCharCode","parseUnicodeCode","surrogateCode","parsedSurrogateCode","isCurlyBraced","text","charAt","parseUnicodeCodePointCode","codePoint","fromCodePoint","RangeError","singleCharacterEscapes","parseSingleCharacterCode","escapeMatch","unraw","raw","_","backslash","unicodeWithSurrogate","surrogate","unicode","octal","singleCharacter","createLisp","NullLisp","lispTypes","ParseError","message","super","lastType","inlineIfElse","elseIf","ifElse","space","expectTypes","splitter","types","opHigh","comparitor","bitwiseShift","bitwiseAnd","bitwiseXor","bitwiseOr","boolOpAnd","boolOpOr","nullishCoalescing","next","inlineIf","assignment","assignModify","incrementerBefore","expEdge","incrementerAfter","modifier","not","inverse","negative","positive","typeof","delete","dot","arrayProp","createObject","createArray","number","string","literal","boolean","null","und","arrowFunctionSingle","arrowFunction","inlineFunction","group","void","await","new","initialize","return","throw","spreadObject","spreadArray","expEnd","expFunction","function","expSingle","for","do","while","loopAction","if","try","block","switch","closings","testMultiple","tests","emptyString","okFirstChars","aNumber","wordReg","semiColon","insertedSemicolons","quoteCache","restOfExp","part","quote","firstOpening","closingsTests","details","words","isStart","hasSemiTest","filter","insertedSemis","escape","lastChar","isOneLiner","lastInertedSemi","skip","regRes","foundWord","foundNumber","lastAnyWord","lastWord","test","oneliner","startingExecpted","setLispType","closingsCreate","typesCreate","expect","extract","l","funcFound","lispifyExpr","lispify","lisptype","lispTree","modifierTypes","incrementTypes","adderTypes","instanceof","in","opTypes","extractIfElse","foundTrue","elseReg","count","foundElse","first","all","max","true","false","quoteCount","ie","startTrue","trueBlock","elseBlock","lispifyBlock","indexOf","caseFound","statement","insertSemicolons","caseTest","cases","defaultFound","cond","bracketFound","exprs","notEmpty","index","matches","lt","isArrow","isReturn","argPos","split","ended","eager","iteratorRegex","body","lispifyReturnExpr","extract2","k","ofStart2","ofStart3","ofCondition","ofStep","inStart2","inStart3","inStep","inCondition","isBlock","catchReg","catchRes","offset","argsString","j","expected","topLevel","startingExpectedWithoutSingle","subExpressions","pos","defined","expression","parts","skipped","isInserted","hoist","rep","it","closingsNoInsertion","colonsRegex","rest","inserted","valid","edge","checkRegex","cancel","after","notDivide","possibleDivide","extractConstants","currentEnclosure","regexFound","comment","commentStart","currJs","strRes","enclosures","isPossibleDivide","li","join","tempJsStrings","parse","createEvalContext","SandboxFunction","handler","timeout","h","haltsub","contsub","setTimeoutHandles","sandBoxhandle","timeoutHandleCounter","Date","now","handle","elapsed","remaining","floor","timeoutHandle","intervalHandle","setIntervalHandles","handlObj","subscribeSet","names","callbacks","changeCbs","SandboxExec","haltSubscriptions","resumeSubscriptions","opt","SAFE_GLOBALS","SAFE_PROTOTYPES","console","debug","info","log","table","warn","isFinite","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","unescape","Boolean","EvalError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","protos","proto","subscribeGet","subscribeSetGlobal","haltContext","resumeExecution","getContext","Sandbox","getOwnPropertyNames","compile","optimize","run","compileAsync","compileExpression","compileExpressionAsync"],"mappings":"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"}