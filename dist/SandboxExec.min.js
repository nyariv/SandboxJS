Object.getPrototypeOf(async function(){}).constructor,Object.getPrototypeOf(function*(){}).constructor,Object.getPrototypeOf(async function*(){}).constructor;const t=function(t){for(const e in t)this[e]=t[e]};class e{constructor(t){this.ref={str:""},t instanceof e?(this.ref=t.ref,this.start=t.start,this.end=t.end):(this.ref.str=t,this.start=0,this.end=t.length)}substring(t,o){if(!this.length)return this;(t=this.start+t)<0&&(t=0),t>this.end&&(t=this.end),(o=void 0===o?this.end:this.start+o)<0&&(o=0),o>this.end&&(o=this.end);const n=new e(this);return n.start=t,n.end=o,n}get length(){const t=this.end-this.start;return t<0?0:t}char(t){if(this.start!==this.end)return this.ref.str[this.start+t]}toString(){return this.ref.str.substring(this.start,this.end)}trimStart(){const t=/^\s+/.exec(this.toString()),o=new e(this);return t&&(o.start+=t[0].length),o}slice(t,e){return t<0&&(t=this.end-this.start+t),t<0&&(t=0),void 0===e&&(e=this.end-this.start),e<0&&(e=this.end-this.start+e),e<0&&(e=0),this.substring(t,e)}trim(){const t=this.trimStart(),e=/\s+$/.exec(t.toString());return e&&(t.end-=e[0].length),t}valueOf(){return this.toString()}}function o(t){const e=Object.assign({},t);for(const t in e)e[t]=!0;return e}const n=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","enum","export","extends","false","finally","for","function","if","implements","import","in","instanceof","let","new","null","return","super","switch","this","throw","true","try","typeof","var","void","while","with"]);class i{constructor(t,e={},n){this.const={},this.let={},this.var={};const i=void 0!==n||null===t;this.parent=t,this.allVars=e,this.let=i?this.let:o(e),this.var=i?o(e):this.var,this.globals=null===t?o(e):{},this.functionThis=n}get(t){const e="this"===t,o=this.getWhereValScope(t,e);return o&&e?new u({this:o.functionThis},t,!1,!1,!0):o?new u(o.allVars,t,t in o.const,t in o.globals,!0):new u(void 0,t)}set(t,e){if("this"===t)throw new SyntaxError('"this" cannot be assigned');if(n.has(t))throw new SyntaxError("Unexepected token '"+t+"'");const o=this.get(t);if(void 0===o.context)throw new ReferenceError(`Variable '${t}' was not declared.`);if(null===o.context)throw new TypeError(`Cannot set properties of null, (setting '${t}')`);if(o.isConst)throw new TypeError(`Cannot assign to const variable '${t}'`);if(o.isGlobal)throw new s(`Cannot override global variable '${t}'`);return o.context[o.prop]=e,o}getWhereValScope(t,e){return e?void 0!==this.functionThis?this:this.parent?.getWhereValScope(t,e)||null:!(t in this.allVars)||t in{}&&!f(this.allVars,t)?this.parent?.getWhereValScope(t,e)||null:this}getWhereVarScope(t,e=!1){return!(t in this.allVars)||t in{}&&!f(this.allVars,t)?null===this.parent||e||void 0!==this.functionThis?this:this.parent.getWhereVarScope(t,e):this}declare(t,e,o=void 0,i=!1){if("this"===t)throw new SyntaxError('"this" cannot be declared');if(n.has(t))throw new SyntaxError("Unexepected token '"+t+"'");const r=this.getWhereVarScope(t,"var"!==e);if("var"===e){if(r.var[t])return r.allVars[t]=o,i?r.globals[t]=!0:delete r.globals[t],new u(r.allVars,t,!1,r.globals[t],!0);if(t in r.allVars)throw new SyntaxError(`Identifier '${t}' has already been declared`)}if(t in r.allVars)throw new SyntaxError(`Identifier '${t}' has already been declared`);return i&&(r.globals[t]=!0),r[e][t]=!0,r.allVars[t]=o,new u(this.allVars,t,"const"===e,i,!0)}}class r{}class s extends Error{}class c extends s{}class a extends s{}class d extends s{}class l extends s{}function p(t){return Array.isArray(t)&&"number"==typeof t[0]&&0!==t[0]&&88!==t[0]}class u{constructor(t,e,o=!1,n=!1,i=!1){this.context=t,this.prop=e,this.isConst=o,this.isGlobal=n,this.isVariable=i}get(t){const e=this.context;if(void 0===e)throw new ReferenceError(`${this.prop.toString()} is not defined`);if(null===e)throw new TypeError(`Cannot read properties of null, (reading '${this.prop.toString()}')`);return t.getSubscriptions.forEach(t=>t(e,this.prop.toString())),e[this.prop]}}function f(t,e){return Object.prototype.hasOwnProperty.call(t,e)}class b{constructor(t,e,o,n=!1,i=!1){this.auditReport=t,this.result=e,this.returned=o,this.breakLoop=n,this.continueLoop=i}}const h={};function x(t,e){const o={};return t.forEach((t,n)=>{t.startsWith("...")?o[t.substring(3)]=e.slice(n):o[t]=e[n]}),o}function v(t,e,o,n,r,s){if(n.ctx.options.forbidFunctionCreation)throw new d("Function creation is forbidden");let c;return c=void 0===s?(...s)=>{const c=x(t,s);return G(o,n,e,void 0===r?[]:[new i(r,c)]).result}:function(...s){const c=x(t,s);return G(o,n,e,void 0===r?[]:[new i(r,c,this)]).result},n.registerSandboxFunction(c),n.ctx.sandboxedFunctions.add(c),c}function w(t,e,o,n,r,s){if(n.ctx.options.forbidFunctionCreation)throw new d("Function creation is forbidden");if(!n.ctx.prototypeWhitelist?.has(Promise.prototype))throw new d("Async/await not permitted");let c;return c=void 0===s?async(...s)=>{const c=x(t,s);return(await M(o,n,e,void 0===r?[]:[new i(r,c)])).result}:async function(...s){const c=x(t,s);return(await M(o,n,e,void 0===r?[]:[new i(r,c,this)])).result},n.registerSandboxFunction(c),n.ctx.sandboxedFunctions.add(c),c}function g(t,e,o="assign"){if(void 0===t.context)throw new ReferenceError(`Cannot ${o} value to undefined.`);if(t.isConst)throw new TypeError("Assignment to constant variable.");if(t.isGlobal)throw new l(`Cannot ${o} property '${t.prop.toString()}' of a global object`);if(null===t.context)throw new TypeError("Cannot set properties of null");if("function"==typeof t.context[t.prop]&&!f(t.context,t.prop))throw new l(`Override prototype property '${t.prop.toString()}' not allowed`);"delete"===o?f(t.context,t.prop)&&(e.changeSubscriptions.get(t.context)?.forEach(e=>e({type:"delete",prop:t.prop.toString()})),e.changeSubscriptionsGlobal.get(t.context)?.forEach(e=>e({type:"delete",prop:t.prop.toString()}))):f(t.context,t.prop)?(e.setSubscriptions.get(t.context)?.get(t.prop.toString())?.forEach(t=>t({type:"replace"})),e.setSubscriptionsGlobal.get(t.context)?.get(t.prop.toString())?.forEach(t=>t({type:"replace"}))):(e.changeSubscriptions.get(t.context)?.forEach(e=>e({type:"create",prop:t.prop.toString()})),e.changeSubscriptionsGlobal.get(t.context)?.forEach(e=>e({type:"create",prop:t.prop.toString()})))}const y=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]);class S{constructor(t,e){this.key=t,this.val=e}}class m{constructor(t){this.item=t}}class E{constructor(t){this.item=t}}class k{constructor(t,e){this.t=t,this.f=e}}const j=/(\$\$)*(\$)?\${(\d+)}/g,A=new Map;function I(t,e){A.set(t,e)}function R(t,e,o){if(!t)return;const n="function"==typeof t;t instanceof u&&(o||(o=t),t=t.get(e));const i=o?.prop||"prop";if(t===globalThis)return new u({[i]:e.ctx.sandboxGlobal},i,o?.isConst||!1,!1,o?.isVariable||!1);const r=n&&e.evals.get(t);return r?new u({[i]:r},i,o?.isConst||!1,!0,o?.isVariable||!1):void 0}function O(t,e){return t instanceof u?t.get(e):t!==h?t:void 0}function F(t,e,o,n,i,r,s){e===U?function(t,e,o,n,i,r){const s=[];for(let c=0;c<e.length;c++){let a;try{a=$(o=>U(t,e[c],n,i,o,r)).result}catch(t){return void o(t)}if(a instanceof b&&(a.returned||a.breakLoop||a.continueLoop))return void o(void 0,a);if(p(e[c])&&8===e[c][0])return void o(void 0,new b(i.ctx.auditReport,a,!0));s.push(a)}o(void 0,s)}(t,o,n,i,r,s):async function(t,e,o,n,i,r){const s=[];for(let c=0;c<e.length;c++){let a;try{let o;a=!0===(o=C(o=>W(t,e[c],n,i,o,r))).isInstant?o.instant:(await o.p).result}catch(t){return void o(t)}if(a instanceof b&&(a.returned||a.breakLoop||a.continueLoop))return void o(void 0,a);if(p(e[c])&&8===e[c][0])return void o(void 0,new b(i.ctx.auditReport,a,!0));s.push(a)}o(void 0,s)}(t,o,n,i,r,s).catch(n)}function C(t){let e,o=!1;const n=new Promise((n,i)=>{t((t,r)=>{t?i(t):(o=!0,e=r,n({result:r}))})});return{isInstant:o,instant:e,p:n}}function $(t){let e,o;if(t((t,n)=>{o=t,e=n}),o)throw o;return{result:e}}async function W(t,e,o,n,i,r){let s=i;const c=new Promise(t=>{s=(e,o)=>{i(e,o),t()}});if(!V(t,e,o,n,s,!0,r)&&p(e)){let i,c=e[0];try{let s;i=!0===(s=C(i=>W(t,e[1],o,n,i,r))).isInstant?s.instant:(await s.p).result}catch(t){return void s(t)}let a,d=i;try{d=i instanceof u?i.get(n):i}catch(t){return void s(t)}if(20===c||21===c){if(null==d)return void s(void 0,h);c=20===c?1:5}if(d===h){if(1===c||5===c)return void s(void 0,d);d=void 0}if(89===c&&null!=d)return void s(void 0,d);try{let i;a=!0===(i=C(i=>W(t,e[2],o,n,i,r))).isInstant?i.instant:(await i.p).result}catch(t){return void s(t)}let l=a;try{l=a instanceof u?a.get(n):a}catch(t){return void s(t)}l===h&&(l=void 0),L({op:c,exec:W,done:s,ticks:t,a:d,b:l,obj:i,context:n,scope:o,bobj:a,inLoopOrSwitch:r,tree:e})}await c}function U(t,e,o,n,i,r){if(!V(t,e,o,n,i,!1,r)&&p(e)){let s,c=e[0];try{s=$(i=>U(t,e[1],o,n,i,r)).result}catch(t){return void i(t)}let a,d=s;try{d=s instanceof u?s.get(n):s}catch(t){return void i(t)}if(20===c||21===c){if(null==d)return void i(void 0,h);c=20===c?1:5}if(d===h){if(1===c||5===c)return void i(void 0,d);d=void 0}if(89===c&&null!=d)return void i(void 0,d);try{a=$(i=>U(t,e[2],o,n,i,r)).result}catch(t){return void i(t)}let l=a;try{l=a instanceof u?a.get(n):a}catch(t){return void i(t)}l===h&&(l=void 0),L({op:c,exec:U,done:i,ticks:t,a:d,b:l,obj:s,context:n,scope:o,bobj:a,inLoopOrSwitch:r,tree:e})}}function T(t,e){let o,n,i=!1,r=t.ctx.sandbox.halted,s=()=>{};const c=new Promise(e=>{s=()=>{n.unsubscribe(),o.unsubscribe(),e()},n=t.ctx.sandbox.subscribeHalt(()=>{r=!0}),o=t.ctx.sandbox.subscribeResume(()=>{r=!1,i&&s()})});return e.finally(()=>{i=!0,r||s()}).catch(()=>{}),Promise.allSettled([e,c]).then(()=>e)}function L(t){const{done:e,op:o,ticks:n,context:i,scope:r}=t;n.ticks++;const d=i.ctx.sandbox;if(!function(t,e=0){const o=t.context.ctx.sandbox,n=t.context.ctx.options,{ticks:i,scope:r,context:a,done:d,op:l}=t;if(o.halted){const e=o.subscribeResume(()=>{e.unsubscribe();try{const e=A.get(l);if(!e)return void d(new SyntaxError("Unknown operator: "+l));e(t)}catch(t){if(n.haltOnSandboxError&&t instanceof s){const e=o.subscribeResume(()=>{e.unsubscribe(),d(t)});o.haltExecution({error:t,ticks:i,scope:r,context:a})}else d(t)}});return!0}if(i.tickLimit&&i.tickLimit<=i.ticks+BigInt(e)){const e=o.subscribeResume(()=>{e.unsubscribe();try{const e=A.get(l);if(!e)return void d(new SyntaxError("Unknown operator: "+l));e(t)}catch(t){if(a.ctx.options.haltOnSandboxError&&t instanceof s){const e=o.subscribeResume(()=>{e.unsubscribe(),d(t)});o.haltExecution({error:t,ticks:i,scope:r,context:a})}else d(t)}}),n=new c("Execution quota exceeded");return o.haltExecution({error:n,ticks:i,scope:r,context:a}),!0}return!1}(t))try{const n=A.get(o);if(!n)return void e(new a("Unknown operator: "+o));n(t)}catch(t){if(i.ctx.options.haltOnSandboxError&&t instanceof s){const o=d.subscribeResume(()=>{o.unsubscribe(),e(t)});d.haltExecution({error:t,ticks:n,scope:r,context:i})}else e(t)}}I(1,({done:t,a:e,b:o,obj:n,context:i,scope:r})=>{if(null===e)throw new TypeError(`Cannot read properties of null (reading '${o?.toString()}')`);if(!function(t){return["string","number","symbol"].includes(typeof t)}(o))try{o=`${o}`}catch(e){return void t(e)}if(void 0===e&&void 0===n&&"string"==typeof o){const e=r.get(o);e.context===i.ctx.sandboxGlobal&&i.ctx.options.audit&&i.ctx.auditReport?.globalsAccess.add(o);return void t(void 0,R(e.context?e.context[e.prop]:void 0,i,e)||e)}if(void 0===e)throw new TypeError(`Cannot read properties of undefined (reading '${o.toString()}')`);if(!function(t){return null!=t}(e))return void t(void 0,new u(void 0,o));const s="function"==typeof e||!f(e,o);if(i.ctx.options.audit&&s){let t=Object.getPrototypeOf(e);do{f(t,o)&&(i.ctx.auditReport&&!i.ctx.auditReport.prototypeAccess[t.constructor.name]&&(i.ctx.auditReport.prototypeAccess[t.constructor.name]=new Set),i.ctx.auditReport?.prototypeAccess[t.constructor.name].add(o))}while(t=Object.getPrototypeOf(t))}if(s){if("function"==typeof e&&f(e,o)){const n=i.ctx.prototypeWhitelist.get(e.prototype),r=i.ctx.options.prototypeReplacements.get(e);if(r)return void t(void 0,new u(r(e,!0),o));if((!n||n.size&&!n.has(o))&&!i.ctx.sandboxedFunctions.has(e))throw new l(`Static method or property access not permitted: ${e.name}.${o.toString()}`)}let n=e;for(;n=Object.getPrototypeOf(n);)if(f(n,o)||"__proto__"===o){const r=i.ctx.prototypeWhitelist.get(n),s=i.ctx.options.prototypeReplacements.get(n.constructor);if(s)return void t(void 0,new u(s(e,!1),o));if(r&&(!r.size||r.has(o))||i.ctx.sandboxedFunctions.has(n.constructor))break;if("__proto__"===o)throw new l("Access to prototype of global object is not permitted");throw new l(`Method or property access not permitted: ${n.constructor.name}.${o.toString()}`)}}const c=e[o];if("function"==typeof e&&"prototype"===o&&!i.ctx.sandboxedFunctions.has(e))throw new l("Access to prototype of global object is not permitted");if("__proto__"===o&&!i.ctx.sandboxedFunctions.has(c?.constructor))throw new l("Access to prototype of global object is not permitted");const a=R(c,i);if(a)return void t(void 0,a);const d=n instanceof u&&n.isGlobal||"function"==typeof e&&!i.ctx.sandboxedFunctions.has(e)||i.ctx.globalsWhitelist.has(e);t(void 0,new u(e,o,!1,d,!1))}),I(5,({done:t,a:e,b:o,obj:n,context:i})=>{if(i.ctx.options.forbidFunctionCalls)throw new d("Function invocations are not allowed");if("function"!=typeof e)throw new TypeError(`${"symbol"==typeof n.prop?"Symbol":n.prop} is not a function`);const r=o.map(t=>t instanceof E?[...t.item]:[t]).flat().map(t=>O(t,i));if("function"==typeof n){let e=n(...r);return e=e instanceof Promise?T(i,e):R(e,i)||e,void t(void 0,e)}if(n.context[n.prop]===JSON.stringify&&i.getSubscriptions.size){const t=new Set,e=o=>{if(o&&"object"==typeof o&&!t.has(o)){t.add(o);for(const t of Object.keys(o))i.getSubscriptions.forEach(e=>e(o,t)),e(o[t])}};e(r[0])}if(n.context instanceof Array&&y.has(n.context[n.prop])&&(i.changeSubscriptions.get(n.context)||i.changeSubscriptionsGlobal.get(n.context))){let t,e=!1;if("push"===n.prop)t={type:"push",added:r},e=!!r.length;else if("pop"===n.prop)t={type:"pop",removed:n.context.slice(-1)},e=!!t.removed.length;else if("shift"===n.prop)t={type:"shift",removed:n.context.slice(0,1)},e=!!t.removed.length;else if("unshift"===n.prop)t={type:"unshift",added:r},e=!!r.length;else if("splice"===n.prop)t={type:"splice",startIndex:r[0],deleteCount:void 0===r[1]?n.context.length:r[1],added:r.slice(2),removed:n.context.slice(r[0],void 0===r[1]?void 0:r[0]+r[1])},e=!!t.added.length||!!t.removed.length;else if("reverse"===n.prop||"sort"===n.prop)t={type:n.prop},e=!!n.context.length;else if("copyWithin"===n.prop){const o=void 0===r[2]?n.context.length-r[1]:Math.min(n.context.length,r[2]-r[1]);t={type:"copyWithin",startIndex:r[0],endIndex:r[0]+o,added:n.context.slice(r[1],r[1]+o),removed:n.context.slice(r[0],r[0]+o)},e=!!t.added.length||!!t.removed.length}e&&(i.changeSubscriptions.get(n.context)?.forEach(e=>e(t)),i.changeSubscriptionsGlobal.get(n.context)?.forEach(e=>e(t)))}n.get(i);let s=n.context[n.prop](...r);s=s instanceof Promise?T(i,s):R(s,i)||s,t(void 0,s)}),I(22,({done:t,b:e})=>{let o={};for(const t of e)t.key instanceof m?o={...o,...t.key.item}:o[t.key]=t.val;t(void 0,o)}),I(6,({done:t,a:e,b:o})=>t(void 0,new S(e,o))),I(12,({done:t,b:e,context:o})=>{t(void 0,e.map(t=>t instanceof E?[...t.item]:[t]).flat().map(t=>O(t,o)))}),I(23,({done:t,b:e})=>t(void 0,e)),I(35,({done:t,b:e})=>{switch(e){case"true":return t(void 0,!0);case"false":return t(void 0,!1);case"null":return t(void 0,null);case"undefined":return t(void 0,void 0);case"NaN":return t(void 0,NaN);case"Infinity":return t(void 0,1/0)}t(new Error("Unknown symbol: "+e))}),I(7,({done:t,b:e})=>t(void 0,Number(e.replace(/_/g,"")))),I(83,({done:t,b:e})=>t(void 0,BigInt(e.replace(/_/g,"")))),I(2,({done:t,b:e,context:o})=>t(void 0,o.constants.strings[parseInt(e)])),I(85,({done:t,b:e,context:o})=>{const n=o.constants.regexes[parseInt(e)];if(!o.ctx.globalsWhitelist.has(RegExp))throw new d("Regex not permitted");t(void 0,new RegExp(n.regex,n.flags))}),I(84,({exec:t,done:e,ticks:o,b:n,context:i,scope:r})=>{const s=i.constants.literals[parseInt(n)],[,c,a]=s,d=[];let l;const p=[];for(;l=j.exec(c);)l[2]||(d.push(a[parseInt(l[3],10)]),p.push(l[3]));t(o,d,r,i,(t,o)=>{const n={};if(t)e(t);else{for(const t of Object.keys(o)){const e=p[t];n[e]=o[t]}e(void 0,c.replace(/(\\\\)*(\\)?\${(\d+)}/g,(t,e,o,r)=>{if(o)return t;return(e||"")+`${O(n[r],i)}`}))}})}),I(18,({done:t,b:e})=>{t(void 0,new E(e))}),I(17,({done:t,b:e})=>{t(void 0,new m(e))}),I(24,({done:t,b:e})=>t(void 0,!e)),I(64,({done:t,b:e})=>t(void 0,~e)),I(25,({done:t,obj:e,context:o})=>{g(e,o),t(void 0,++e.context[e.prop])}),I(26,({done:t,obj:e,context:o})=>{g(e,o),t(void 0,e.context[e.prop]++)}),I(27,({done:t,obj:e,context:o})=>{g(e,o),t(void 0,--e.context[e.prop])}),I(28,({done:t,obj:e,context:o})=>{g(e,o),t(void 0,e.context[e.prop]--)}),I(9,({done:t,b:e,obj:o,context:n,scope:i,bobj:r})=>{if(g(o,n),o.isGlobal=r?.isGlobal||!1,o.isVariable){const n=i.getWhereValScope(o.prop,"this"===o.prop);if(null===n)throw new ReferenceError(`Cannot assign to undeclared variable '${o.prop.toString()}'`);return n.set(o.prop,e),o.isGlobal?n.globals[o.prop.toString()]=!0:delete n.globals[o.prop.toString()],void t(void 0,e)}t(void 0,o.context[o.prop]=e)}),I(66,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]+=e)}),I(65,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]-=e)}),I(67,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]/=e)}),I(69,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]*=e)}),I(68,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]**=e)}),I(70,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]%=e)}),I(71,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]^=e)}),I(72,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]&=e)}),I(73,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]|=e)}),I(76,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]<<=e)}),I(75,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]>>=e)}),I(74,({done:t,b:e,obj:o,context:n})=>{g(o,n),t(void 0,o.context[o.prop]>>>=e)}),I(57,({done:t,a:e,b:o})=>t(void 0,e>o)),I(56,({done:t,a:e,b:o})=>t(void 0,e<o)),I(55,({done:t,a:e,b:o})=>t(void 0,e>=o)),I(54,({done:t,a:e,b:o})=>t(void 0,e<=o)),I(52,({done:t,a:e,b:o})=>t(void 0,e==o)),I(32,({done:t,a:e,b:o})=>t(void 0,e===o)),I(53,({done:t,a:e,b:o})=>t(void 0,e!=o)),I(31,({done:t,a:e,b:o})=>t(void 0,e!==o)),I(29,({done:t,a:e,b:o})=>t(void 0,e&&o)),I(30,({done:t,a:e,b:o})=>t(void 0,e||o)),I(89,({done:t,a:e,b:o})=>t(void 0,e??o)),I(77,({done:t,a:e,b:o})=>t(void 0,e&o)),I(78,({done:t,a:e,b:o})=>t(void 0,e|o)),I(33,({done:t,a:e,b:o})=>t(void 0,e+o)),I(47,({done:t,a:e,b:o})=>t(void 0,e-o)),I(59,({done:t,b:e})=>t(void 0,+e)),I(58,({done:t,b:e})=>t(void 0,-e)),I(48,({done:t,a:e,b:o})=>t(void 0,e/o)),I(49,({done:t,a:e,b:o})=>t(void 0,e**o)),I(79,({done:t,a:e,b:o})=>t(void 0,e^o)),I(50,({done:t,a:e,b:o})=>t(void 0,e*o)),I(51,({done:t,a:e,b:o})=>t(void 0,e%o)),I(80,({done:t,a:e,b:o})=>t(void 0,e<<o)),I(81,({done:t,a:e,b:o})=>t(void 0,e>>o)),I(82,({done:t,a:e,b:o})=>t(void 0,e>>>o)),I(60,({exec:t,done:e,ticks:o,b:n,context:i,scope:r})=>{t(o,n,r,i,(t,o)=>{e(void 0,typeof O(o,i))})}),I(62,({done:t,a:e,b:o})=>t(void 0,e instanceof o)),I(63,({done:t,a:e,b:o})=>t(void 0,e in o)),I(61,({done:t,context:e,bobj:o})=>{o instanceof u?(g(o,e,"delete"),o.isVariable?t(void 0,!1):t(void 0,delete o.context?.[o.prop])):t(void 0,!0)}),I(8,({done:t,b:e})=>t(void 0,e)),I(34,({done:t,a:e,b:o,scope:n,bobj:i})=>{t(void 0,n.declare(e,"var",o,i?.isGlobal||!1))}),I(3,({done:t,a:e,b:o,scope:n,bobj:i})=>{t(void 0,n.declare(e,"let",o,i?.isGlobal||!1))}),I(4,({done:t,a:e,b:o,scope:n,bobj:i})=>{t(void 0,n.declare(e,"const",o,i?.isGlobal||!1))}),I(11,({done:t,ticks:o,a:n,b:i,obj:r,context:s,scope:c})=>{if(n=[...n],"string"==typeof r[2]||r[2]instanceof e){if(!s.allowJit||!s.evalContext)throw new d("Unevaluated code detected, JIT not allowed");r[2]=i=s.evalContext.lispifyFunction(new e(r[2]),s.constants)}n.shift()?t(void 0,w(n,i,o,s,c)):t(void 0,v(n,i,o,s,c))}),I(37,({done:t,ticks:o,a:n,b:i,obj:r,context:s,scope:c})=>{if("string"==typeof r[2]||r[2]instanceof e){if(!s.allowJit||!s.evalContext)throw new d("Unevaluated code detected, JIT not allowed");r[2]=i=s.evalContext.lispifyFunction(new e(r[2]),s.constants)}const a=n.shift(),l=n.shift();let p;p=88===a?w(n,i,o,s,c,l):v(n,i,o,s,c,l),l&&c.declare(l,"var",p),t(void 0,p)}),I(10,({done:t,ticks:o,a:n,b:r,obj:s,context:c,scope:a})=>{if("string"==typeof s[2]||s[2]instanceof e){if(!c.allowJit||!c.evalContext)throw new d("Unevaluated code detected, JIT not allowed");s[2]=r=c.evalContext.lispifyFunction(new e(s[2]),c.constants)}const l=n.shift(),p=n.shift();let u;p&&(a=new i(a,{})),u=88===l?w(n,r,o,c,a,p):v(n,r,o,c,a,p),p&&a.declare(p,"let",u),t(void 0,u)}),I(38,({exec:t,done:e,ticks:o,a:n,b:r,context:s,scope:c})=>{const[a,d,l,p,u,f,h]=n;let x=!0;const v=new i(c,{}),w={$$obj:void 0},g=new i(v,w);if(t===W)(async()=>{let n;for(n=C(e=>t(o,p,v,s,e)),w.$$obj=!0===(n=C(e=>t(o,l,v,s,e))).isInstant?n.instant:(await n.p).result,n=C(e=>t(o,d,g,s,e)),a&&(x=!0===(n=C(e=>t(o,f,g,s,e))).isInstant?n.instant:(await n.p).result);x;){const c={};n=C(e=>t(o,h,new i(g,c),s,e)),!0===n.isInstant?n.instant:(await n.p).result;const a=await M(o,s,r,[new i(v,c)],"loop");if(a instanceof b&&a.returned)return void e(void 0,a);if(a instanceof b&&a.breakLoop)break;n=C(e=>t(o,u,g,s,e)),x=!0===(n=C(e=>t(o,f,g,s,e))).isInstant?n.instant:(await n.p).result}e()})().catch(e);else{for($(e=>t(o,p,v,s,e)),w.$$obj=$(e=>t(o,l,v,s,e)).result,$(e=>t(o,d,g,s,e)),a&&(x=$(e=>t(o,f,g,s,e)).result);x;){const n={};$(e=>t(o,h,new i(g,n),s,e));const c=G(o,s,r,[new i(v,n)],"loop");if(c instanceof b&&c.returned)return void e(void 0,c);if(c instanceof b&&c.breakLoop)break;$(e=>t(o,u,g,s,e)),x=$(e=>t(o,f,g,s,e)).result}e()}}),I(86,({done:t,a:e,context:o,inLoopOrSwitch:n})=>{if("switch"===n&&"continue"===e||!n)throw new TypeError("Illegal "+e+" statement");t(void 0,new b(o.ctx.auditReport,void 0,!1,"break"===e,"continue"===e))}),I(13,({exec:t,done:e,ticks:o,a:n,b:i,context:r,scope:s,inLoopOrSwitch:c})=>{t(o,O(n,r)?i.t:i.f,s,r,e,c)}),I(15,({exec:t,done:e,ticks:o,a:n,b:i,context:r,scope:s})=>{t(o,O(n,r)?i.t:i.f,s,r,e,void 0)}),I(16,({done:t,a:e,b:o})=>t(void 0,new k(e,o))),I(14,({done:t,a:e,b:o})=>t(void 0,new k(e,o))),I(40,({exec:t,done:e,ticks:o,a:n,b:i,context:r,scope:s})=>{t(o,n,s,r,(n,c)=>{if(n)e(n);else if(c=O(c,r),t===U){let n,a=!1;for(const d of i)if(a||(a=!d[1]||c===O($(e=>t(o,d[1],s,r,e)).result,r))){if(!d[2])continue;if(n=G(o,r,d[2],[s],"switch"),n.breakLoop)break;if(n.returned)return void e(void 0,n);if(!d[1])break}e()}else(async()=>{let n,a=!1;for(const d of i){let i;if(a||(a=!d[1]||c===O(!0===(i=C(e=>t(o,d[1],s,r,e))).isInstant?i.instant:(await i.p).result,r))){if(!d[2])continue;if(n=await M(o,r,d[2],[s],"switch"),n.breakLoop)break;if(n.returned)return void e(void 0,n);if(!d[1])break}}e()})().catch(e)})}),I(39,({exec:t,done:e,ticks:o,a:n,b:r,context:s,scope:c,inLoopOrSwitch:a})=>{const[d,l,p]=r;_(t,(n,r)=>{_(t,d=>{d?e(d):n?_(t,e,o,s,l,[new i(c)],a):e(void 0,r)},o,s,p,[new i(c,{})])},o,s,n,[new i(c)],a)}),I(87,({done:t})=>{t()}),I(45,({done:t,a:e,b:o,context:n})=>{if(!n.ctx.globalsWhitelist.has(e)&&!n.ctx.sandboxedFunctions.has(e))throw new l(`Object construction not allowed: ${e.constructor.name}`);t(void 0,new e(...o))}),I(46,({done:t,b:e})=>{t(e)}),I(43,({done:t,a:e})=>t(void 0,e.pop())),I(0,({done:t})=>t());const P=new Set([11,37,10,38,39,40,14,16,60]);function V(t,e,o,n,i,r,s){const c=r?W:U;if(e instanceof u)try{i(void 0,e.get(n))}catch(t){i(t)}else if(e===h)i();else if(Array.isArray(e)&&!p(e))0===e[0]?i():F(t,c,e,i,o,n,s);else if(p(e))if(42===e[0])F(t,c,e[1],i,o,n,s);else if(44===e[0])r?n.ctx.prototypeWhitelist?.has(Promise.prototype)?W(t,e[1],o,n,async(t,e)=>{if(t)i(t);else try{i(void 0,await O(e,n))}catch(t){i(t)}},s).catch(i):i(new d("Async/await is not permitted")):i(new SyntaxError("Illegal use of 'await', must be inside async function"));else{if(!P.has(e[0]))return!1;L({op:e[0],exec:c,done:i,ticks:t,a:e[1],b:e[2],obj:e,tree:e,context:n,scope:o,bobj:void 0,inLoopOrSwitch:s})}else i(void 0,e);return!0}function G(t,e,o,n=[],i){return $(r=>_(U,r,t,e,o,n,i)).result}async function M(t,e,o,n=[],i){let r;return!0===(r=C(r=>_(W,r,t,e,o,n,i))).isInstant?r.instant:(await r.p).result}function _(t,e,o,n,s,c=[],a){if(!s)return void e();if(!(s instanceof Array))throw new SyntaxError("Bad execution tree");let d,l=n.ctx.globalScope;for(;d=c.shift();)"object"==typeof d&&(l=d instanceof i?d:new i(l,d,d instanceof r?void 0:null));n.ctx.options.audit&&!n.ctx.auditReport&&(n.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),t===U?function(t,e,o,n,i,r){if(!(n instanceof Array))throw new SyntaxError("Bad execution tree");let s=0;for(s=0;s<n.length;s++){let c,a;const d=n[s];try{U(e,d,i,o,(t,e)=>{a=t,c=e},r)}catch(t){a=t}if(a)return void t(a);if(c instanceof b)return void t(void 0,c);if(p(d)&&8===d[0])return void t(void 0,new b(o.ctx.auditReport,c,!0))}t(void 0,new b(o.ctx.auditReport,void 0,!1))}(e,o,n,s,l,a):async function(t,e,o,n,i,r){if(!(n instanceof Array))throw new SyntaxError("Bad execution tree");let s=0;for(s=0;s<n.length;s++){let c,a;const d=n[s];try{await W(e,d,i,o,(t,e)=>{a=t,c=e},r)}catch(t){a=t}if(a)return void t(a);if(c instanceof b)return void t(void 0,c);if(p(d)&&8===d[0])return void t(void 0,new b(o.ctx.auditReport,c,!0))}t(void 0,new b(o.ctx.auditReport,void 0,!1))}(e,o,n,s,l,a).catch(e)}function N(t,e,o,n){const i=n.setSubscriptions.get(t)||new Map;n.setSubscriptions.set(t,i);const r=i.get(e)||new Set;let s;i.set(e,r),r.add(o);const c=t[e];return c instanceof Object&&(s=n.changeSubscriptions.get(c)||new Set,s.add(o),n.changeSubscriptions.set(c,s)),{unsubscribe:()=>{r.delete(o),s?.delete(o)}}}BigInt(0);class B{constructor(e,o){this.evalContext=o,this.setSubscriptions=new WeakMap,this.changeSubscriptions=new WeakMap,this.sandboxFunctions=new WeakMap,this.haltSubscriptions=new Set,this.resumeSubscriptions=new Set,this.halted=!1,this.timeoutHandleCounter=0,this.setTimeoutHandles=new Map,this.setIntervalHandles=new Map;const n=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:B.SAFE_GLOBALS,prototypeWhitelist:B.SAFE_PROTOTYPES,prototypeReplacements:new Map},e||{});this.context=function(e,o){const n=new t(o.globals),r={sandbox:e,globalsWhitelist:new Set(Object.values(o.globals)),prototypeWhitelist:new Map([...o.prototypeWhitelist].map(t=>[t[0].prototype,t[1]])),options:o,globalScope:new i(null,o.globals,n),sandboxGlobal:n,ticks:{ticks:0n,tickLimit:o.executionQuota},sandboxedFunctions:new WeakSet};return r.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()),new Set),r}(this,n)}static get SAFE_GLOBALS(){return{globalThis:globalThis,Function:Function,eval:eval,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite:isFinite,isNaN:isNaN,parseFloat:parseFloat,parseInt:parseInt,decodeURI:decodeURI,decodeURIComponent:decodeURIComponent,encodeURI:encodeURI,encodeURIComponent:encodeURIComponent,escape:escape,unescape:unescape,Boolean:Boolean,Number:Number,BigInt:BigInt,String:String,Object:Object,Array:Array,Symbol:Symbol,Error:Error,EvalError:EvalError,RangeError:RangeError,ReferenceError:ReferenceError,SyntaxError:SyntaxError,TypeError:TypeError,URIError:URIError,Int8Array:Int8Array,Uint8Array:Uint8Array,Uint8ClampedArray:Uint8ClampedArray,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array,Map:Map,Set:Set,WeakMap:WeakMap,WeakSet:WeakSet,Promise:Promise,Intl:Intl,JSON:JSON,Math:Math,Date:Date,RegExp:RegExp}}static get SAFE_PROTOTYPES(){const e=[t,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],o=new Map;return e.forEach(t=>{o.set(t,new Set)}),o.set(Object,new Set(["constructor","name","entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),o}subscribeGet(t,e){return e.getSubscriptions.add(t),{unsubscribe:()=>e.getSubscriptions.delete(t)}}subscribeSet(t,e,o,n){return N(t,e,o,n)}subscribeSetGlobal(t,e,o){return N(t,e,o,this)}subscribeHalt(t){return this.haltSubscriptions.add(t),{unsubscribe:()=>{this.haltSubscriptions.delete(t)}}}subscribeResume(t){return this.resumeSubscriptions.add(t),{unsubscribe:()=>{this.resumeSubscriptions.delete(t)}}}haltExecution(t){if(!this.halted){this.halted=!0;for(const e of this.haltSubscriptions)e(t)}}resumeExecution(){if(this.halted){if(this.context.ticks.tickLimit&&this.context.ticks.ticks>=this.context.ticks.tickLimit)throw new c("Cannot resume execution: tick limit exceeded");this.halted=!1;for(const t of this.resumeSubscriptions)t()}}getContext(t){return this.sandboxFunctions.get(t)}executeTree(t,e=[]){return G(t.ctx.ticks,t,t.tree,e)}executeTreeAsync(t,e=[]){return M(t.ctx.ticks,t,t.tree,e)}}export{r as LocalScope,l as SandboxAccessError,d as SandboxCapabilityError,s as SandboxError,a as SandboxExecutionTreeError,B as default};
//# sourceMappingURL=SandboxExec.min.js.map
