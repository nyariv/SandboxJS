{"version":3,"file":"SandboxExec.min.js","sources":["../src/utils.ts","../src/executor.ts","../src/SandboxExec.ts"],"sourcesContent":["// Reusable AsyncFunction constructor reference\nexport const AsyncFunction: Function = Object.getPrototypeOf(async function () {}).constructor;\nexport const GeneratorFunction: Function = Object.getPrototypeOf(function* () {}).constructor;\nexport const AsyncGeneratorFunction: Function = Object.getPrototypeOf(async function* () {}).constructor;\n\nimport { IEvalContext } from './eval';\nimport { Change, Unknown } from './executor';\nimport { IConstants, IExecutionTree, Lisp, LispItem } from './parser';\nimport SandboxExec from './SandboxExec';\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any;\n\nexport interface IOptionParams {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (\n    ticks: Ticks,\n    scope: Scope,\n    context: IExecutionTree,\n    tree: LispItem\n  ) => boolean | void;\n}\n\nexport interface IOptions {\n  audit: boolean;\n  forbidFunctionCalls: boolean;\n  forbidFunctionCreation: boolean;\n  prototypeReplacements: Map<new () => any, replacementCallback>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  onExecutionQuotaReached?: (\n    ticks: Ticks,\n    scope: Scope,\n    context: IExecutionTree,\n    tree: LispItem\n  ) => boolean | void;\n}\n\nexport interface IContext {\n  sandbox: SandboxExec;\n  globalScope: Scope;\n  sandboxGlobal: ISandboxGlobal;\n  globalsWhitelist: Set<any>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<unknown>;\n  prototypeAccess: { [name: string]: Set<string> };\n}\n\nexport interface Ticks {\n  ticks: bigint;\n}\n\nexport type SubscriptionSubject = object;\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext;\n  getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<\n    SubscriptionSubject,\n    Map<string, Set<(modification: Change) => void>>\n  >;\n  changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n  allowJit: boolean;\n  evalContext?: IEvalContext;\n}\n\nexport interface ISandboxGlobal {\n  [key: string]: unknown;\n}\ninterface SandboxGlobalConstructor {\n  new (globals: IGlobals): ISandboxGlobal;\n}\n\nexport const SandboxGlobal = function SandboxGlobal(this: ISandboxGlobal, globals: IGlobals) {\n  if (globals === (globalThis as any)) return globalThis;\n  for (const i in globals) {\n    this[i] = globals[i];\n  }\n} as any as SandboxGlobalConstructor;\n\nexport type IGlobals = ISandboxGlobal;\n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: Lisp[],\n    public getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>,\n    public setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Set<(modification: Change) => void>\n    >,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void,\n    public allowJit: boolean,\n    public evalContext?: IEvalContext\n  ) {}\n}\n\nexport function createContext(sandbox: SandboxExec, options: IOptions): IContext {\n  const sandboxGlobal = new SandboxGlobal(options.globals);\n  const context = {\n    sandbox: sandbox,\n    globalsWhitelist: new Set(Object.values(options.globals)),\n    prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n    options,\n    globalScope: new Scope(null, options.globals, sandboxGlobal),\n    sandboxGlobal,\n  };\n  context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()) as Object, new Set());\n  return context;\n}\n\nexport function createExecContext(\n  sandbox: {\n    setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n    sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext>;\n    context: IContext;\n  },\n  executionTree: IExecutionTree,\n  evalContext?: IEvalContext\n): IExecContext {\n  const evals = new Map();\n  const execContext: IExecContext = new ExecContext(\n    sandbox.context,\n    executionTree.constants,\n    executionTree.tree,\n    new Set<(obj: SubscriptionSubject, name: string) => void>(),\n    new WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>(),\n    new WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>(),\n    sandbox.setSubscriptions,\n    sandbox.changeSubscriptions,\n    evals,\n    (fn) => sandbox.sandboxFunctions.set(fn, execContext),\n    !!evalContext,\n    evalContext\n  );\n  if (evalContext) {\n    const func = evalContext.sandboxFunction(execContext);\n    const asyncFunc = evalContext.sandboxAsyncFunction(execContext);\n    evals.set(Function, func);\n    evals.set(AsyncFunction, asyncFunc);\n    evals.set(GeneratorFunction, func);\n    evals.set(AsyncGeneratorFunction, asyncFunc);\n    evals.set(eval, evalContext.sandboxedEval(func));\n    evals.set(setTimeout, evalContext.sandboxedSetTimeout(func));\n    evals.set(setInterval, evalContext.sandboxedSetInterval(func));\n\n  }\n  return execContext;\n}\n\nexport class CodeString {\n  start: number;\n  end: number;\n  ref: { str: string };\n  constructor(str: string | CodeString) {\n    this.ref = { str: '' };\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start;\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length() {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\nfunction keysOnly(obj: unknown): Record<string, true> {\n  const ret: Record<string, true> = Object.assign({}, obj);\n  for (const key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nconst reservedWords = new Set([\n  'instanceof',\n  'typeof',\n  'return',\n  'throw',\n  'try',\n  'catch',\n  'if',\n  'finally',\n  'else',\n  'in',\n  'of',\n  'var',\n  'let',\n  'const',\n  'for',\n  'delete',\n  'false',\n  'true',\n  'while',\n  'do',\n  'break',\n  'continue',\n  'new',\n  'function',\n  'async',\n  'await',\n  'switch',\n  'case',\n]);\n\nexport const enum VarType {\n  let = 'let',\n  const = 'const',\n  var = 'var',\n}\n\nexport class Scope {\n  parent: Scope | null;\n  const: { [key: string]: true } = {};\n  let: { [key: string]: true } = {};\n  var: { [key: string]: true } = {};\n  globals: { [key: string]: true };\n  allVars: { [key: string]: unknown } & Object;\n  functionThis?: Unknown;\n  constructor(parent: Scope | null, vars = {}, functionThis?: Unknown) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string, functionScope = false): Prop {\n    const functionThis = this.functionThis;\n    if (key === 'this' && functionThis !== undefined) {\n      return new Prop({ this: functionThis }, key, true, false, true);\n    }\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (this.parent === null || !functionScope || functionThis !== undefined) {\n      if (this.globals.hasOwnProperty(key)) {\n        return new Prop(functionThis, key, false, true, true);\n      }\n      if (key in this.allVars && (!(key in {}) || this.allVars.hasOwnProperty(key))) {\n        return new Prop(\n          this.allVars,\n          key,\n          this.const.hasOwnProperty(key),\n          this.globals.hasOwnProperty(key),\n          true\n        );\n      }\n      if (this.parent === null) {\n        return new Prop(undefined, key);\n      }\n    }\n    return this.parent.get(key, functionScope);\n  }\n\n  set(key: string, val: unknown) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    const prop = this.get(key);\n    if (prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    if (!(prop.context instanceof Object)) throw new SandboxError('Scope is not an object');\n    prop.context[prop.prop] = val;\n    return prop;\n  }\n\n  declare(key: string, type: VarType, value: unknown = undefined, isGlobal = false): Prop {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    if (type === 'var' && this.functionThis === undefined && this.parent !== null) {\n      return this.parent.declare(key, type, value, isGlobal);\n    } else if (\n      (this[type].hasOwnProperty(key) && type !== 'const' && !this.globals.hasOwnProperty(key)) ||\n      !(key in this.allVars)\n    ) {\n      if (isGlobal) {\n        this.globals[key] = true;\n      }\n      this[type][key] = true;\n      this.allVars[key] = value;\n    } else {\n      throw new SandboxError(`Identifier '${key}' has already been declared`);\n    }\n    return new Prop(this.allVars, key, this.const.hasOwnProperty(key), isGlobal);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nexport function isLisp<Type extends Lisp = Lisp>(item: LispItem | LispItem): item is Type {\n  return (\n    Array.isArray(item) &&\n    typeof item[0] === 'number' &&\n    item[0] !== LispType.None &&\n    item[0] !== LispType.True\n  );\n}\n\nexport const enum LispType {\n  None,\n  Prop,\n  StringIndex,\n  Let,\n  Const,\n  Call,\n  KeyVal,\n  Number,\n  Return,\n  Assign,\n  InlineFunction,\n  ArrowFunction,\n  CreateArray,\n  If,\n  IfCase,\n  InlineIf,\n  InlineIfCase,\n  SpreadObject,\n  SpreadArray,\n  ArrayProp,\n  PropOptional,\n  CallOptional,\n  CreateObject,\n  Group,\n  Not,\n  IncrementBefore,\n  IncrementAfter,\n  DecrementBefore,\n  DecrementAfter,\n  And,\n  Or,\n  StrictNotEqual,\n  StrictEqual,\n  Plus,\n  Var,\n  GlobalSymbol,\n  Literal,\n  Function,\n  Loop,\n  Try,\n  Switch,\n  SwitchCase,\n  Block,\n  Expression,\n  Await,\n  New,\n  Throw,\n  Minus,\n  Divide,\n  Power,\n  Multiply,\n  Modulus,\n  Equal,\n  NotEqual,\n  SmallerEqualThan,\n  LargerEqualThan,\n  SmallerThan,\n  LargerThan,\n  Negative,\n  Positive,\n  Typeof,\n  Delete,\n  Instanceof,\n  In,\n  Inverse,\n  SubractEquals,\n  AddEquals,\n  DivideEquals,\n  PowerEquals,\n  MultiplyEquals,\n  ModulusEquals,\n  BitNegateEquals,\n  BitAndEquals,\n  BitOrEquals,\n  UnsignedShiftRightEquals,\n  ShiftRightEquals,\n  ShiftLeftEquals,\n  BitAnd,\n  BitOr,\n  BitNegate,\n  BitShiftLeft,\n  BitShiftRight,\n  BitUnsignedShiftRight,\n  BigInt,\n  LiteralIndex,\n  RegexIndex,\n  LoopAction,\n  Void,\n  True,\n\n  LispEnumSize,\n}\n\nexport class Prop {\n  constructor(\n    public context: Unknown,\n    public prop: string,\n    public isConst = false,\n    public isGlobal = false,\n    public isVariable = false\n  ) {}\n\n  get<T = unknown>(context: IExecContext): T {\n    const ctx = this.context;\n    if (ctx === undefined) throw new ReferenceError(`${this.prop} is not defined`);\n    if (ctx === null)\n      throw new TypeError(`Cannot read properties of null, (reading '${this.prop}')`);\n    context.getSubscriptions.forEach((cb) => cb(ctx, this.prop));\n    return (ctx as any)[this.prop] as T;\n  }\n}\n","import { LispItem, Lisp, IRegEx, LispFamily, ExtractLispOp, SwitchCase } from './parser.js';\nimport {\n  CodeString,\n  IAuditReport,\n  IExecContext,\n  IScope,\n  isLisp,\n  LispType,\n  LocalScope,\n  Prop,\n  SandboxError,\n  Scope,\n  Ticks,\n  VarType,\n} from './utils.js';\n\nexport type Done<T = any> = (err?: any, res?: T | typeof optional) => void;\n\nexport class ExecReturn<T> {\n  constructor(\n    public auditReport: IAuditReport | undefined,\n    public result: T,\n    public returned: boolean,\n    public breakLoop = false,\n    public continueLoop = false\n  ) {}\n}\n\nexport type Unknown = undefined | null | Record<string | number, unknown>;\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: 'create';\n  prop: number | string;\n}\n\nexport interface IReplace extends IChange {\n  type: 'replace';\n}\n\nexport interface IDelete extends IChange {\n  type: 'delete';\n  prop: number | string;\n}\n\nexport interface IReverse extends IChange {\n  type: 'reverse';\n}\n\nexport interface ISort extends IChange {\n  type: 'sort';\n}\n\nexport interface IPush extends IChange {\n  type: 'push';\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: 'pop';\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: 'shift';\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: 'unshift';\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: 'splice';\n  startIndex: number;\n  deleteCount: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport interface ICopyWithin extends IChange {\n  type: 'copyWithin';\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change =\n  | ICreate\n  | IReplace\n  | IDelete\n  | IReverse\n  | ISort\n  | IPush\n  | IPop\n  | IUnShift\n  | IShift\n  | ISplice\n  | ICopyWithin;\n\nconst optional = {};\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: Record<string, unknown> = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nexport const sandboxedFunctions = new WeakSet();\nexport function createFunction(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError('Function creation is forbidden');\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)]\n      );\n      return res.result;\n    };\n  } else {\n    func = function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)]\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxError('Function creation is forbidden');\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxError('Async/await not permitted');\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)]\n      );\n      return res.result;\n    };\n  } else {\n    func = async function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)]\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if (obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`);\n  }\n  if (typeof obj.context !== 'object' && typeof obj.context !== 'function') {\n    throw new SyntaxError(`Cannot ${op} value to a primitive.`);\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Cannot set value to const variable '${obj.prop}'`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxError(`Cannot ${op} property '${obj.prop}' of a global object`);\n  }\n  if (obj.context === null) {\n    throw new TypeError('Cannot set properties of null');\n  }\n  if (typeof obj.context[obj.prop] === 'function' && !obj.context.hasOwnProperty(obj.prop)) {\n    throw new SandboxError(`Override prototype property '${obj.prop}' not allowed`);\n  }\n  if (op === 'delete') {\n    if (obj.context.hasOwnProperty(obj.prop)) {\n      context.changeSubscriptions\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop }));\n      context.changeSubscriptionsGlobal\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop }));\n    }\n  } else if (obj.context.hasOwnProperty(obj.prop)) {\n    context.setSubscriptions\n      .get(obj.context)\n      ?.get(obj.prop)\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        })\n      );\n    context.setSubscriptionsGlobal\n      .get(obj.context)\n      ?.get(obj.prop)\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        })\n      );\n  } else {\n    context.changeSubscriptions\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop }));\n    context.changeSubscriptionsGlobal\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop }));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin,\n]);\n\nexport class KeyVal {\n  constructor(public key: string | SpreadObject, public val: unknown) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: { [key: string]: unknown }) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(public t: Lisp, public f: Lisp) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback = (\n  exec: Execution,\n  done: Done,\n  ticks: Ticks,\n  a: any,\n  b: any,\n  obj: any,\n  context: IExecContext,\n  scope: Scope,\n  bobj?: any,\n  inLoopOrSwitch?: string\n) => void;\n\nexport const ops = new Map<LispType, OpCallback>();\nexport function addOps<Type extends LispFamily>(type: ExtractLispOp<Type>, cb: OpCallback) {\n  ops.set(type, cb);\n}\n\naddOps(LispType.Prop, (exec, done, ticks, a, b: string, obj, context, scope) => {\n  if (a === null) {\n    throw new TypeError(`Cannot get property ${b} of null`);\n  }\n  const type = typeof a;\n  if (type === 'undefined' && obj === undefined) {\n    const prop = scope.get(b);\n    if (prop.context === context.ctx.sandboxGlobal) {\n      if (context.ctx.options.audit) {\n        context.ctx.auditReport?.globalsAccess.add(b);\n      }\n      const rep = context.ctx.globalsWhitelist.has(context.ctx.sandboxGlobal[b])\n        ? context.evals.get(context.ctx.sandboxGlobal[b])\n        : undefined;\n      if (rep) {\n        done(undefined, rep);\n        return;\n      }\n    }\n    if (prop.context && prop.context[b] === globalThis) {\n      done(undefined, context.ctx.globalScope.get('this'));\n      return;\n    }\n\n    done(undefined, prop);\n    return;\n  } else if (a === undefined) {\n    throw new SandboxError(\"Cannot get property '\" + b + \"' of undefined\");\n  }\n\n  if (type !== 'object') {\n    if (type === 'number') {\n      a = new Number(a);\n    } else if (type === 'string') {\n      a = new String(a);\n    } else if (type === 'boolean') {\n      a = new Boolean(a);\n    }\n  } else if (typeof a.hasOwnProperty === 'undefined') {\n    done(undefined, new Prop(undefined, b));\n    return;\n  }\n\n  const isFunction = type === 'function';\n  const prototypeAccess = isFunction || !(a.hasOwnProperty(b) || typeof b === 'number');\n\n  if (context.ctx.options.audit && prototypeAccess) {\n    if (typeof b === 'string') {\n      let prot = Object.getPrototypeOf(a);\n      do {\n        if (prot.hasOwnProperty(b)) {\n          if (\n            context.ctx.auditReport &&\n            !context.ctx.auditReport.prototypeAccess[prot.constructor.name]\n          ) {\n            context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n          }\n          context.ctx.auditReport?.prototypeAccess[prot.constructor.name].add(b);\n        }\n      } while ((prot = Object.getPrototypeOf(prot)));\n    }\n  }\n\n  if (prototypeAccess) {\n    if (isFunction) {\n      if (!['name', 'length', 'constructor'].includes(b) && (a.hasOwnProperty(b) || b === '__proto__')) {\n        const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n        const replace = context.ctx.options.prototypeReplacements.get(a);\n        if (replace) {\n          done(undefined, new Prop(replace(a, true), b));\n          return;\n        }\n        if (!(whitelist && (!whitelist.size || whitelist.has(b)))) {\n          throw new SandboxError(`Static method or property access not permitted: ${a.name}.${b}`);\n        }\n      }\n    } else if (b !== 'constructor') {\n      let prot = a;\n      while ((prot = Object.getPrototypeOf(prot))) {\n        if (prot.hasOwnProperty(b)) {\n          const whitelist = context.ctx.prototypeWhitelist.get(prot);\n          const replace = context.ctx.options.prototypeReplacements.get(prot.constuctor);\n          if (replace) {\n            done(undefined, new Prop(replace(a, false), b));\n            return;\n          }\n          if (whitelist && (!whitelist.size || whitelist.has(b))) {\n            break;\n          }\n          throw new SandboxError(\n            `Method or property access not permitted: ${prot.constructor.name}.${b}`\n          );\n        }\n      }\n    }\n  }\n\n  if (context.evals.has(a[b])) {\n    done(undefined, context.evals.get(a[b]));\n    return;\n  }\n  if (a[b] === globalThis) {\n    done(undefined, context.ctx.globalScope.get('this'));\n    return;\n  }\n\n  const g =\n    obj.isGlobal ||\n    (isFunction && !sandboxedFunctions.has(a)) ||\n    context.ctx.globalsWhitelist.has(a);\n\n  done(undefined, new Prop(a, b, false, g));\n});\n\naddOps(LispType.Call, (exec, done, ticks, a, b: Lisp[], obj, context) => {\n  if (context.ctx.options.forbidFunctionCalls)\n    throw new SandboxError('Function invocations are not allowed');\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    done(undefined, obj(...vals));\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (const y of Object.keys(x) as (keyof typeof x)[]) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (\n    obj.context instanceof Array &&\n    arrayChange.has(obj.context[obj.prop]) &&\n    (context.changeSubscriptions.get(obj.context) ||\n      context.changeSubscriptionsGlobal.get(obj.context))\n  ) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === 'push') {\n      change = {\n        type: 'push',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'pop') {\n      change = {\n        type: 'pop',\n        removed: obj.context.slice(-1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'shift') {\n      change = {\n        type: 'shift',\n        removed: obj.context.slice(0, 1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'unshift') {\n      change = {\n        type: 'unshift',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'splice') {\n      change = {\n        type: 'splice',\n        startIndex: vals[0],\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(vals[0], vals[1] === undefined ? undefined : vals[0] + vals[1]),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === 'reverse' || obj.prop === 'sort') {\n      change = { type: obj.prop };\n      changed = !!obj.context.length;\n    } else if (obj.prop === 'copyWithin') {\n      const len =\n        vals[2] === undefined\n          ? obj.context.length - vals[1]\n          : Math.min(obj.context.length, vals[2] - vals[1]);\n      change = {\n        type: 'copyWithin',\n        startIndex: vals[0],\n        endIndex: vals[0] + len,\n        added: obj.context.slice(vals[1], vals[1] + len),\n        removed: obj.context.slice(vals[0], vals[0] + len),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  done(undefined, obj.context[obj.prop](...vals));\n});\n\naddOps(LispType.CreateObject, (exec, done, ticks, a, b: KeyVal[]) => {\n  let res = {} as any;\n  for (const item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = { ...res, ...item.key.item };\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps(LispType.KeyVal, (exec, done, ticks, a: string, b: LispItem) =>\n  done(undefined, new KeyVal(a, b))\n);\n\naddOps(LispType.CreateArray, (exec, done, ticks, a, b: Lisp[], obj, context) => {\n  const items = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n  done(undefined, items);\n});\n\naddOps(LispType.Group, (exec, done, ticks, a, b) => done(undefined, b));\n\naddOps(LispType.GlobalSymbol, (exec, done, ticks, a, b: string) => {\n  switch (b) {\n    case 'true':\n      return done(undefined, true);\n    case 'false':\n      return done(undefined, false);\n    case 'null':\n      return done(undefined, null);\n    case 'undefined':\n      return done(undefined, undefined);\n    case 'NaN':\n      return done(undefined, NaN);\n    case 'Infinity':\n      return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b));\n});\n\naddOps(LispType.Number, (exec, done, ticks, a, b) => done(undefined, Number(b)));\naddOps(LispType.BigInt, (exec, done, ticks, a, b) => done(undefined, BigInt(b)));\naddOps(LispType.StringIndex, (exec, done, ticks, a, b: string, obj, context) =>\n  done(undefined, context.constants.strings[parseInt(b)])\n);\n\naddOps(LispType.RegexIndex, (exec, done, ticks, a, b: string, obj, context) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxError('Regex not permitted');\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps(LispType.LiteralIndex, (exec, done, ticks, a, b: string, obj, context, scope) => {\n  const item = context.constants.literals[parseInt(b)];\n  const [, name, js] = item;\n  const found: Lisp[] = [];\n  let f: RegExpExecArray | null;\n  const resnums: string[] = [];\n  while ((f = literalRegex.exec(name))) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec<unknown[]>(ticks, found, scope, context, (err, processed) => {\n    const reses: Record<string, unknown> = {};\n    if (err) {\n      done(err);\n      return;\n    }\n    for (const i of Object.keys(processed!) as (keyof typeof processed)[]) {\n      const num = resnums[i];\n      reses[num] = processed![i];\n    }\n    done(\n      undefined,\n      name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        const res = reses[num];\n        return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n      })\n    );\n  });\n});\n\naddOps(LispType.SpreadArray, (exec, done, ticks, a, b) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps(LispType.SpreadObject, (exec, done, ticks, a, b) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps(LispType.Not, (exec, done, ticks, a, b) => done(undefined, !b));\naddOps(LispType.Inverse, (exec, done, ticks, a, b) => done(undefined, ~b));\n\naddOps(LispType.IncrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps(LispType.IncrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps(LispType.DecrementBefore, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps(LispType.DecrementAfter, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps(LispType.Assign, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] = b));\n});\n\naddOps(LispType.AddEquals, (exec, done, ticks, a, b, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] += b));\n});\n\naddOps(LispType.SubractEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] -= b));\n});\n\naddOps(LispType.DivideEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] /= b));\n});\n\naddOps(LispType.MultiplyEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] *= b));\n});\n\naddOps(LispType.PowerEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] **= b));\n});\n\naddOps(LispType.ModulusEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] %= b));\n});\n\naddOps(LispType.BitNegateEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] ^= b));\n});\n\naddOps(LispType.BitAndEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] &= b));\n});\n\naddOps(LispType.BitOrEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] |= b));\n});\n\naddOps(LispType.ShiftLeftEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] <<= b));\n});\n\naddOps(LispType.ShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] >>= b));\n});\n\naddOps(LispType.UnsignedShiftRightEquals, (exec, done, ticks, a, b: number, obj, context) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] >>= b));\n});\n\naddOps(LispType.LargerThan, (exec, done, ticks, a, b) => done(undefined, a > b));\naddOps(LispType.SmallerThan, (exec, done, ticks, a, b) => done(undefined, a < b));\naddOps(LispType.LargerEqualThan, (exec, done, ticks, a, b) => done(undefined, a >= b));\naddOps(LispType.SmallerEqualThan, (exec, done, ticks, a, b) => done(undefined, a <= b));\naddOps(LispType.Equal, (exec, done, ticks, a, b) => done(undefined, a == b));\naddOps(LispType.StrictEqual, (exec, done, ticks, a, b) => done(undefined, a === b));\naddOps(LispType.NotEqual, (exec, done, ticks, a, b) => done(undefined, a != b));\naddOps(LispType.StrictNotEqual, (exec, done, ticks, a, b) => done(undefined, a !== b));\naddOps(LispType.And, (exec, done, ticks, a, b) => done(undefined, a && b));\naddOps(LispType.Or, (exec, done, ticks, a, b) => done(undefined, a || b));\naddOps(LispType.BitAnd, (exec, done, ticks, a: number, b: number) => done(undefined, a & b));\naddOps(LispType.BitOr, (exec, done, ticks, a: number, b: number) => done(undefined, a | b));\naddOps(LispType.Plus, (exec, done, ticks, a: number, b: number) => done(undefined, a + b));\naddOps(LispType.Minus, (exec, done, ticks, a: number, b: number) => done(undefined, a - b));\naddOps(LispType.Positive, (exec, done, ticks, a, b) => done(undefined, +b));\naddOps(LispType.Negative, (exec, done, ticks, a, b) => done(undefined, -b));\naddOps(LispType.Divide, (exec, done, ticks, a: number, b: number) => done(undefined, a / b));\naddOps(LispType.BitNegate, (exec, done, ticks, a: number, b: number) => done(undefined, a ^ b));\naddOps(LispType.Multiply, (exec, done, ticks, a: number, b: number) => done(undefined, a * b));\naddOps(LispType.Modulus, (exec, done, ticks, a: number, b: number) => done(undefined, a % b));\naddOps(LispType.BitShiftLeft, (exec, done, ticks, a: number, b: number) => done(undefined, a << b));\naddOps(LispType.BitShiftRight, (exec, done, ticks, a: number, b: number) =>\n  done(undefined, a >> b)\n);\naddOps(LispType.BitUnsignedShiftRight, (exec, done, ticks, a: number, b: number) =>\n  done(undefined, a >>> b)\n);\naddOps(LispType.Typeof, (exec, done, ticks, a, b: LispItem, obj, context, scope) => {\n  exec(ticks, b, scope, context, (e, prop) => {\n    done(undefined, typeof valueOrProp(prop, context));\n  });\n});\n\naddOps(LispType.Instanceof, (exec, done, ticks, a, b: { new (): unknown }) =>\n  done(undefined, a instanceof b)\n);\naddOps(LispType.In, (exec, done, ticks, a: string, b) => done(undefined, a in b));\n\naddOps(LispType.Delete, (exec, done, ticks, a, b, obj, context, scope, bobj: Prop) => {\n  if (bobj.context === undefined) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete bobj.context?.[bobj.prop]);\n});\n\naddOps(LispType.Return, (exec, done, ticks, a, b) => done(undefined, b));\n\naddOps(LispType.Var, (exec, done, ticks, a: string, b: LispItem, obj, context, scope) => {\n  done(undefined, scope.declare(a, VarType.var, b));\n});\n\naddOps(LispType.Let, (exec, done, ticks, a: string, b: LispItem, obj, context, scope, bobj) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj && bobj.isGlobal));\n});\n\naddOps(LispType.Const, (exec, done, ticks, a: string, b: LispItem, obj, context, scope) => {\n  done(undefined, scope.declare(a, VarType.const, b));\n});\n\naddOps(\n  LispType.ArrowFunction,\n  (exec, done, ticks, a: string[], b: Lisp[], obj: Lisp, context, scope) => {\n    a = [...a];\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  }\n);\n\naddOps(\n  LispType.Function,\n  (exec, done, ticks, a: (string | LispType)[], b: Lisp[], obj: Lisp, context, scope) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  }\n);\n\naddOps(\n  LispType.InlineFunction,\n  (exec, done, ticks, a: (string | LispType)[], b: Lisp[], obj: Lisp, context, scope) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    if (name) {\n      scope = new Scope(scope, {});\n    }\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  }\n);\n\naddOps(LispType.Loop, (exec, done, ticks, a: Lisp[], b: Lisp[], obj, context, scope) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  const internalVars = {\n    $$obj: undefined,\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async () => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] =\n        (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst)\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      while (loop) {\n        const innerLoopVars = {};\n        ad = asyncDone((d) =>\n          exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d)\n        );\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        const res = await executeTreeAsync(\n          ticks,\n          context,\n          b,\n          [new Scope(loopScope, innerLoopVars)],\n          'loop'\n        );\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    while (loop) {\n      const innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      const res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], 'loop');\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    }\n    done();\n  }\n});\n\naddOps(\n  LispType.LoopAction,\n  (exec, done, ticks, a: LispItem, b: LispItem, obj, context, scope, bobj, inLoopOrSwitch) => {\n    if ((inLoopOrSwitch === 'switch' && a === 'continue') || !inLoopOrSwitch) {\n      throw new SandboxError('Illegal ' + a + ' statement');\n    }\n    done(\n      undefined,\n      new ExecReturn(context.ctx.auditReport, undefined, false, a === 'break', a === 'continue')\n    );\n  }\n);\n\naddOps(\n  LispType.If,\n  (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n    exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n  }\n);\n\naddOps(LispType.InlineIf, (exec, done, ticks, a: LispItem, b: If, obj, context, scope) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done);\n});\naddOps(LispType.InlineIfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\naddOps(LispType.IfCase, (exec, done, ticks, a, b) => done(undefined, new If(a, b)));\n\naddOps(LispType.Switch, (exec, done, ticks, a: LispItem, b: SwitchCase[], obj, context, scope) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (const caseItem of b) {\n        if (\n          isTrue ||\n          (isTrue =\n            !caseItem[1] ||\n            toTest ===\n              valueOrProp(\n                syncDone((d) => exec(ticks, caseItem[1], scope, context, d)).result,\n                context\n              ))\n        ) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], 'switch');\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) {\n            // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (const caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (\n            isTrue ||\n            (isTrue =\n              !caseItem[1] ||\n              toTest ===\n                valueOrProp(\n                  (ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant ===\n                    true\n                    ? ad.instant\n                    : (await ad.p).result,\n                  context\n                ))\n          ) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], 'switch');\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) {\n              // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done);\n    }\n  });\n});\n\naddOps(\n  LispType.Try,\n  (\n    exec,\n    done,\n    ticks,\n    a: Lisp[],\n    b: [string, Lisp[], Lisp[]],\n    obj,\n    context,\n    scope,\n    bobj,\n    inLoopOrSwitch\n  ) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(\n      exec,\n      (err, res) => {\n        executeTreeWithDone(\n          exec,\n          (e) => {\n            if (e) done(e);\n            else if (err) {\n              const sc: Record<string, unknown> = {};\n              if (exception) sc[exception] = err;\n              executeTreeWithDone(\n                exec,\n                done,\n                ticks,\n                context,\n                catchBody,\n                [new Scope(scope)],\n                inLoopOrSwitch\n              );\n            } else {\n              done(undefined, res);\n            }\n          },\n          ticks,\n          context,\n          finallyBody,\n          [new Scope(scope, {})]\n        );\n      },\n      ticks,\n      context,\n      a,\n      [new Scope(scope)],\n      inLoopOrSwitch\n    );\n  }\n);\n\naddOps(LispType.Void, (exec, done) => {\n  done();\n});\naddOps(\n  LispType.New,\n  (exec, done, ticks, a: new (...args: unknown[]) => unknown, b: unknown[], obj, context) => {\n    if (!context.ctx.globalsWhitelist.has(a) && !sandboxedFunctions.has(a)) {\n      throw new SandboxError(`Object construction not allowed: ${a.constructor.name}`);\n    }\n    done(undefined, new a(...b));\n  }\n);\n\naddOps(LispType.Throw, (exec, done, ticks, a, b) => {\n  done(b);\n});\naddOps(LispType.Expression, (exec, done, ticks, a: unknown[]) => done(undefined, a.pop()));\naddOps(LispType.None, (exec, done) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): any {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(\n  ticks: Ticks,\n  exec: Execution,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string\n) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res =\n        (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = <T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string\n) => void;\n\nexport interface AsyncDoneRet {\n  isInstant: boolean;\n  instant: any;\n  p: Promise<{ result: any }>;\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({ result });\n      }\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p,\n  };\n}\n\nexport function syncDone(callback: (done: Done) => void): { result: any } {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return { result };\n}\n\nexport async function execAsync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  doneOriginal: Done<T>,\n  inLoopOrSwitch?: string\n): Promise<void> {\n  let done: Done<T> = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    };\n  });\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execAsync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n  await p;\n}\n\nexport function execSync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string\n) {\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    if (ops.has(op)) {\n      try {\n        ops.get(op)?.(execSync, done, ticks, a, b, obj, context, scope, bobj, inLoopOrSwitch);\n      } catch (err) {\n        done(err);\n      }\n    } else {\n      done(new SyntaxError('Unknown operator: ' + op));\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof,\n]);\n\nexport const currentTicks = { current: { ticks: BigInt(0) } as Ticks };\n\nfunction _execNoneRecurse<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  isAsync: boolean,\n  inLoopOrSwitch?: string\n): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  if (context.ctx.options.executionQuota && context.ctx.options.executionQuota <= ticks.ticks) {\n    if (\n      !(\n        typeof context.ctx.options.onExecutionQuotaReached === 'function' &&\n        context.ctx.options.onExecutionQuotaReached(ticks, scope, context, tree)\n      )\n    ) {\n      done(new SandboxError('Execution quota exceeded'));\n      return true;\n    }\n  }\n  ticks.ticks++;\n  currentTicks.current = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SandboxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(\n        ticks,\n        tree[1],\n        scope,\n        context,\n        async (e, r) => {\n          if (e) done(e);\n          else\n            try {\n              done(undefined, await valueOrProp(r, context));\n            } catch (err) {\n              done(err);\n            }\n        },\n        inLoopOrSwitch\n      ).catch(done);\n    } else {\n      done(new SandboxError('Async/await is not permitted'));\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    try {\n      ops.get(tree[0])?.(\n        exec,\n        done,\n        ticks,\n        tree[1],\n        tree[2],\n        tree,\n        context,\n        scope,\n        undefined,\n        inLoopOrSwitch\n      );\n    } catch (err) {\n      done(err);\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string\n): ExecReturn<T> {\n  return syncDone((done) =>\n    executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)\n  ).result;\n}\n\nexport async function executeTreeAsync<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string\n): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) =>\n    executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch)\n  )).isInstant === true\n    ? ad.instant\n    : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(\n  exec: Execution,\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string\n) {\n  if (!executionTree) {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while ((s = scopes.shift())) {\n    if (typeof s !== 'object') continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    };\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      execSync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      await execAsync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { IEvalContext } from './eval.js';\nimport { Change, ExecReturn, executeTree, executeTreeAsync } from './executor.js';\nimport {\n  AsyncFunction,\n  createContext,\n  IContext,\n  IExecContext,\n  IGlobals,\n  IOptionParams,\n  IOptions,\n  IScope,\n  replacementCallback,\n  SandboxGlobal,\n  SubscriptionSubject,\n} from './utils.js';\n\nfunction subscribeSet(\n  obj: unknown,\n  name: string,\n  callback: (modification: Change) => void,\n  context: {\n    setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  }\n): { unsubscribe: () => void } {\n  if (!(obj instanceof Object))\n    throw new Error(\n      'Invalid subscription object, got ' + (typeof obj === 'object' ? 'null' : typeof obj)\n    );\n  const names =\n    context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  const val = (obj as any)[name] as unknown;\n  if (val instanceof Object) {\n    changeCbs = context.changeSubscriptions.get(val) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(val, changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    },\n  };\n}\n\nexport default class SandboxExec {\n  context: IContext;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>> =\n    new WeakMap();\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>> =\n    new WeakMap();\n  sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext> = new WeakMap();\n  constructor(options?: IOptionParams, public evalContext?: IEvalContext) {\n    const opt: IOptions = Object.assign(\n      {\n        audit: false,\n        forbidFunctionCalls: false,\n        forbidFunctionCreation: false,\n        globals: SandboxExec.SAFE_GLOBALS,\n        prototypeWhitelist: SandboxExec.SAFE_PROTOTYPES,\n        prototypeReplacements: new Map<new () => any, replacementCallback>(),\n      },\n      options || {}\n    );\n    this.context = createContext(this, opt);\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      Function,\n      console: {\n        debug: console.debug,\n        error: console.error,\n        info: console.info,\n        log: console.log,\n        table: console.table,\n        warn: console.warn,\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp,\n    };\n  }\n\n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    const protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp,\n    ];\n    const map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(\n      Object,\n      new Set([\n        'entries',\n        'fromEntries',\n        'getOwnPropertyNames',\n        'is',\n        'keys',\n        'hasOwnProperty',\n        'isPrototypeOf',\n        'propertyIsEnumerable',\n        'toLocaleString',\n        'toString',\n        'valueOf',\n        'values',\n      ])\n    );\n    return map;\n  }\n\n  subscribeGet(\n    callback: (obj: SubscriptionSubject, name: string) => void,\n    context: IExecContext\n  ): { unsubscribe: () => void } {\n    context.getSubscriptions.add(callback);\n    return { unsubscribe: () => context.getSubscriptions.delete(callback) };\n  }\n\n  subscribeSet(\n    obj: object,\n    name: string,\n    callback: (modification: Change) => void,\n    context: SandboxExec | IExecContext\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(\n    obj: SubscriptionSubject,\n    name: string,\n    callback: (modification: Change) => void\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: IScope[] = []): ExecReturn<T> {\n    return executeTree(\n      {\n        ticks: BigInt(0),\n      },\n      context,\n      context.tree,\n      scopes\n    );\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: IScope[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync(\n      {\n        ticks: BigInt(0),\n      },\n      context,\n      context.tree,\n      scopes\n    );\n  }\n}\n"],"names":["Object","getPrototypeOf","async","constructor","SandboxGlobal","globals","globalThis","i","this","CodeString","str","ref","start","end","length","substring","undefined","code","len","char","toString","trimStart","found","exec","slice","trim","valueOf","keysOnly","obj","ret","assign","key","reservedWords","Set","Scope","parent","vars","functionThis","const","let","var","isFuncScope","allVars","get","functionScope","Prop","has","SyntaxError","hasOwnProperty","set","val","prop","context","ReferenceError","isConst","TypeError","isGlobal","SandboxError","declare","type","value","LocalScope","Error","isLisp","item","Array","isArray","isVariable","ctx","getSubscriptions","forEach","cb","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","optional","generateArgs","argNames","args","arg","startsWith","sandboxedFunctions","WeakSet","createFunction","parsed","ticks","scope","name","options","forbidFunctionCreation","func","executeTree","registerSandboxFunction","add","createFunctionAsync","prototypeWhitelist","Promise","prototype","executeTreeAsync","assignCheck","op","changeSubscriptions","changeSubscriptionsGlobal","setSubscriptions","setSubscriptionsGlobal","arrayChange","push","pop","shift","unshift","splice","reverse","sort","copyWithin","KeyVal","SpreadObject","SpreadArray","If","t","f","literalRegex","ops","Map","addOps","valueOrProp","a","execMany","tree","done","inLoopOrSwitch","execSync","res","syncDone","d","e","_execManySync","ad","asyncDone","execAsync","isInstant","instant","p","_execManyAsync","catch","callback","resolve","reject","err","r","doneOriginal","_execNoneRecurse","bobj","b","sandboxGlobal","audit","globalsAccess","rep","globalsWhitelist","evals","globalScope","Number","String","Boolean","isFunction","prototypeAccess","prot","includes","whitelist","replace","prototypeReplacements","size","constuctor","g","forbidFunctionCalls","vals","map","flat","JSON","stringify","cache","recurse","x","y","keys","change","changed","added","removed","startIndex","deleteCount","Math","min","endIndex","NaN","Infinity","BigInt","constants","strings","parseInt","reg","regexes","RegExp","regex","flags","literals","js","resnums","processed","reses","num","match","$$","$","allowJit","evalContext","lispifyFunction","isAsync","checkFirst","startInternal","getIterator","startStep","step","condition","beforeStep","loop","loopScope","internalVars","$$obj","interalScope","innerLoopVars","toTest","isTrue","caseItem","exception","catchBody","finallyBody","executeTreeWithDone","unexecTypes","executionQuota","onExecutionQuotaReached","executionTree","scopes","s","current","_executeWithDoneSync","_executeWithDoneAsync","subscribeSet","names","callbacks","changeCbs","unsubscribe","delete","SandboxExec","WeakMap","sandboxFunctions","opt","SAFE_GLOBALS","SAFE_PROTOTYPES","sandbox","values","Symbol","iterator","createContext","Function","console","debug","error","info","log","table","warn","isFinite","isNaN","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape","EvalError","RangeError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","subscribeGet","subscribeSetGlobal","getContext","fn"],"mappings":"AACuCA,OAAOC,eAAeC,iBAAmB,GAAGC,YACxCH,OAAOC,eAAe,YAAc,GAAGE,YAClCH,OAAOC,eAAeC,kBAAoB,GAAGC,YAqFtF,MAAMC,EAAgB,SAA6CC,GACxE,GAAIA,IAAaC,WAAoB,OAAOA,WAC5C,IAAK,MAAMC,KAAKF,EACdG,KAAKD,GAAKF,EAAQE,EAEtB,QAuFaE,EAIX,WAAAN,CAAYO,GACVF,KAAKG,IAAM,CAAED,IAAK,IACdA,aAAeD,GACjBD,KAAKG,IAAMD,EAAIC,IACfH,KAAKI,MAAQF,EAAIE,MACjBJ,KAAKK,IAAMH,EAAIG,MAEfL,KAAKG,IAAID,IAAMA,EACfF,KAAKI,MAAQ,EACbJ,KAAKK,IAAMH,EAAII,OAEnB,CAEA,SAAAC,CAAUH,EAAeC,GACvB,IAAKL,KAAKM,OAAQ,OAAON,MACzBI,EAAQJ,KAAKI,MAAQA,GACT,IACVA,EAAQ,GAENA,EAAQJ,KAAKK,MACfD,EAAQJ,KAAKK,MAEfA,OAAcG,IAARH,EAAoBL,KAAKK,IAAML,KAAKI,MAAQC,GACxC,IACRA,EAAM,GAEJA,EAAML,KAAKK,MACbA,EAAML,KAAKK,KAEb,MAAMI,EAAO,IAAIR,EAAWD,MAG5B,OAFAS,EAAKL,MAAQA,EACbK,EAAKJ,IAAMA,EACJI,CACT,CAEA,UAAIH,GACF,MAAMI,EAAMV,KAAKK,IAAML,KAAKI,MAC5B,OAAOM,EAAM,EAAI,EAAIA,CACvB,CAEA,IAAAC,CAAKZ,GACH,GAAIC,KAAKI,QAAUJ,KAAKK,IACxB,OAAOL,KAAKG,IAAID,IAAIF,KAAKI,MAAQL,EACnC,CAEA,QAAAa,GACE,OAAOZ,KAAKG,IAAID,IAAIK,UAAUP,KAAKI,MAAOJ,KAAKK,IACjD,CAEA,SAAAQ,GACE,MAAMC,EAAQ,OAAOC,KAAKf,KAAKY,YACzBH,EAAO,IAAIR,EAAWD,MAI5B,OAHIc,IACFL,EAAKL,OAASU,EAAM,GAAGR,QAElBG,CACT,CAEA,KAAAO,CAAMZ,EAAeC,GAiBnB,OAhBID,EAAQ,IACVA,EAAQJ,KAAKK,IAAML,KAAKI,MAAQA,GAE9BA,EAAQ,IACVA,EAAQ,QAEEI,IAARH,IACFA,EAAML,KAAKK,IAAML,KAAKI,OAGpBC,EAAM,IACRA,EAAML,KAAKK,IAAML,KAAKI,MAAQC,GAE5BA,EAAM,IACRA,EAAM,GAEDL,KAAKO,UAAUH,EAAOC,EAC/B,CAEA,IAAAY,GACE,MAAMR,EAAOT,KAAKa,YACZC,EAAQ,OAAOC,KAAKN,EAAKG,YAI/B,OAHIE,IACFL,EAAKJ,KAAOS,EAAM,GAAGR,QAEhBG,CACT,CAEA,OAAAS,GACE,OAAOlB,KAAKY,UACd,EAGF,SAASO,EAASC,GAChB,MAAMC,EAA4B7B,OAAO8B,OAAO,CAAA,EAAIF,GACpD,IAAK,MAAMG,KAAOF,EAChBA,EAAIE,IAAO,EAEb,OAAOF,CACT,CAEA,MAAMG,EAAgB,IAAIC,IAAI,CAC5B,aACA,SACA,SACA,QACA,MACA,QACA,KACA,UACA,OACA,KACA,KACA,MACA,MACA,QACA,MACA,SACA,QACA,OACA,QACA,KACA,QACA,WACA,MACA,WACA,QACA,QACA,SACA,eASWC,EAQX,WAAA/B,CAAYgC,EAAsBC,EAAO,CAAA,EAAIC,GAN7C7B,KAAA8B,MAAiC,CAAA,EACjC9B,KAAA+B,IAA+B,CAAA,EAC/B/B,KAAAgC,IAA+B,CAAA,EAK7B,MAAMC,OAA+BzB,IAAjBqB,GAAyC,OAAXF,EAClD3B,KAAK2B,OAASA,EACd3B,KAAKkC,QAAUN,EACf5B,KAAK+B,IAAME,EAAcjC,KAAK+B,IAAMZ,EAASS,GAC7C5B,KAAKgC,IAAMC,EAAcd,EAASS,GAAQ5B,KAAKgC,IAC/ChC,KAAKH,QAAqB,OAAX8B,EAAkBR,EAASS,GAAQ,CAAA,EAClD5B,KAAK6B,aAAeA,CACtB,CAEA,GAAAM,CAAIZ,EAAaa,GAAgB,GAC/B,MAAMP,EAAe7B,KAAK6B,aAC1B,GAAY,SAARN,QAAmCf,IAAjBqB,EACpB,OAAO,IAAIQ,EAAK,CAAErC,KAAM6B,GAAgBN,GAAK,GAAM,GAAO,GAE5D,GAAIC,EAAcc,IAAIf,GAAM,MAAM,IAAIgB,YAAY,sBAAwBhB,EAAM,KAChF,GAAoB,OAAhBvB,KAAK2B,SAAoBS,QAAkC5B,IAAjBqB,EAA4B,CACxE,GAAI7B,KAAKH,QAAQ2C,eAAejB,GAC9B,OAAO,IAAIc,EAAKR,EAAcN,GAAK,GAAO,GAAM,GAElD,GAAIA,KAAOvB,KAAKkC,YAAcX,IAAO,CAAA,IAAOvB,KAAKkC,QAAQM,eAAejB,IACtE,OAAO,IAAIc,EACTrC,KAAKkC,QACLX,EACAvB,KAAK8B,MAAMU,eAAejB,GAC1BvB,KAAKH,QAAQ2C,eAAejB,IAC5B,GAGJ,GAAoB,OAAhBvB,KAAK2B,OACP,OAAO,IAAIU,OAAK7B,EAAWe,EAE/B,CACA,OAAOvB,KAAK2B,OAAOQ,IAAIZ,EAAKa,EAC9B,CAEA,GAAAK,CAAIlB,EAAamB,GACf,GAAY,SAARnB,EAAgB,MAAM,IAAIgB,YAAY,6BAC1C,GAAIf,EAAcc,IAAIf,GAAM,MAAM,IAAIgB,YAAY,sBAAwBhB,EAAM,KAChF,MAAMoB,EAAO3C,KAAKmC,IAAIZ,GACtB,QAAqBf,IAAjBmC,EAAKC,QACP,MAAM,IAAIC,eAAe,aAAatB,wBAExC,GAAIoB,EAAKG,QACP,MAAM,IAAIC,UAAU,oCAAoCxB,MAE1D,GAAIoB,EAAKK,SACP,MAAM,IAAIC,EAAa,oCAAoC1B,MAE7D,KAAMoB,EAAKC,mBAAmBpD,QAAS,MAAM,IAAIyD,EAAa,0BAE9D,OADAN,EAAKC,QAAQD,EAAKA,MAAQD,EACnBC,CACT,CAEA,OAAAO,CAAQ3B,EAAa4B,EAAeC,OAAiB5C,EAAWwC,GAAW,GACzE,GAAY,SAARzB,EAAgB,MAAM,IAAIgB,YAAY,6BAC1C,GAAIf,EAAcc,IAAIf,GAAM,MAAM,IAAIgB,YAAY,sBAAwBhB,EAAM,KAChF,GAAa,QAAT4B,QAAwC3C,IAAtBR,KAAK6B,cAA8C,OAAhB7B,KAAK2B,OAC5D,OAAO3B,KAAK2B,OAAOuB,QAAQ3B,EAAK4B,EAAMC,EAAOJ,GACxC,KACJhD,KAAKmD,GAAMX,eAAejB,IAAiB,UAAT4B,GAAqBnD,KAAKH,QAAQ2C,eAAejB,KAClFA,KAAOvB,KAAKkC,QAQd,MAAM,IAAIe,EAAa,eAAe1B,gCAExC,OARMyB,IACFhD,KAAKH,QAAQ0B,IAAO,GAEtBvB,KAAKmD,GAAM5B,IAAO,EAClBvB,KAAKkC,QAAQX,GAAO6B,EAIf,IAAIf,EAAKrC,KAAKkC,QAASX,EAAKvB,KAAK8B,MAAMU,eAAejB,GAAMyB,EACrE,QASWK,GAEP,MAAOJ,UAAqBK,OAE5B,SAAUC,EAAiCC,GAC/C,OACEC,MAAMC,QAAQF,IACK,iBAAZA,EAAK,IACL,IAAPA,EAAK,IACE,KAAPA,EAAK,EAET,OAgGanB,EACX,WAAA1C,CACSiD,EACAD,EACAG,GAAU,EACVE,GAAW,EACXW,GAAa,GAJb3D,KAAA4C,QAAAA,EACA5C,KAAA2C,KAAAA,EACA3C,KAAA8C,QAAAA,EACA9C,KAAAgD,SAAAA,EACAhD,KAAA2D,WAAAA,CACN,CAEH,GAAAxB,CAAiBS,GACf,MAAMgB,EAAM5D,KAAK4C,QACjB,QAAYpC,IAARoD,EAAmB,MAAM,IAAIf,eAAe,GAAG7C,KAAK2C,uBACxD,GAAY,OAARiB,EACF,MAAM,IAAIb,UAAU,6CAA6C/C,KAAK2C,UAExE,OADAC,EAAQiB,iBAAiBC,QAASC,GAAOA,EAAGH,EAAK5D,KAAK2C,OAC9CiB,EAAY5D,KAAK2C,KAC3B,QCngBWqB,EACX,WAAArE,CACSsE,EACAC,EACAC,EACAC,GAAY,EACZC,GAAe,GAJfrE,KAAAiE,YAAAA,EACAjE,KAAAkE,OAAAA,EACAlE,KAAAmE,SAAAA,EACAnE,KAAAoE,UAAAA,EACApE,KAAAqE,aAAAA,CACN,EAgFL,MAAMC,EAAW,CAAA,EAEjB,SAASC,EAAaC,EAAoBC,GACxC,MAAM7C,EAAgC,CAAA,EAQtC,OAPA4C,EAASV,QAAQ,CAACY,EAAK3E,KACjB2E,EAAIC,WAAW,OACjB/C,EAAK8C,EAAInE,UAAU,IAAMkE,EAAKzD,MAAMjB,GAEpC6B,EAAK8C,GAAOD,EAAK1E,KAGd6B,CACT,CAEO,MAAMgD,EAAqB,IAAIC,QAChC,SAAUC,EACdN,EACAO,EACAC,EACApC,EACAqC,EACAC,GAEA,GAAItC,EAAQgB,IAAIuB,QAAQC,uBACtB,MAAM,IAAInC,EAAa,kCAEzB,IAAIoC,EA0BJ,OAxBEA,OADW7E,IAAT0E,EACK,IAAIT,KACT,MAAM7C,EAAO2C,EAAaC,EAAUC,GAOpC,OANYa,EACVN,EACApC,EACAmC,OACUvE,IAAVyE,EAAsB,GAAK,CAAC,IAAIvD,EAAMuD,EAAOrD,KAEpCsC,QAGN,YAA2CO,GAChD,MAAM7C,EAAO2C,EAAaC,EAAUC,GAOpC,OANYa,EACVN,EACApC,EACAmC,OACUvE,IAAVyE,EAAsB,GAAK,CAAC,IAAIvD,EAAMuD,EAAOrD,EAAM5B,QAE1CkE,MACb,EAEFtB,EAAQ2C,wBAAwBF,GAChCT,EAAmBY,IAAIH,GAChBA,CACT,CAEM,SAAUI,EACdjB,EACAO,EACAC,EACApC,EACAqC,EACAC,GAEA,GAAItC,EAAQgB,IAAIuB,QAAQC,uBACtB,MAAM,IAAInC,EAAa,kCAEzB,IAAKL,EAAQgB,IAAI8B,oBAAoBpD,IAAIqD,QAAQC,WAC/C,MAAM,IAAI3C,EAAa,6BAEzB,IAAIoC,EA0BJ,OAxBEA,OADW7E,IAAT0E,EACKxF,SAAU+E,KACf,MAAM7C,EAAO2C,EAAaC,EAAUC,GAOpC,aANkBoB,EAChBb,EACApC,EACAmC,OACUvE,IAAVyE,EAAsB,GAAK,CAAC,IAAIvD,EAAMuD,EAAOrD,MAEpCsC,QAGNxE,kBAAiD+E,GACtD,MAAM7C,EAAO2C,EAAaC,EAAUC,GAOpC,aANkBoB,EAChBb,EACApC,EACAmC,OACUvE,IAAVyE,EAAsB,GAAK,CAAC,IAAIvD,EAAMuD,EAAOrD,EAAM5B,SAE1CkE,MACb,EAEFtB,EAAQ2C,wBAAwBF,GAChCT,EAAmBY,IAAIH,GAChBA,CACT,CAEM,SAAUS,EAAY1E,EAAWwB,EAAuBmD,EAAK,UACjE,QAAoBvF,IAAhBY,EAAIwB,QACN,MAAM,IAAIC,eAAe,UAAUkD,yBAErC,GAA2B,iBAAhB3E,EAAIwB,SAA+C,mBAAhBxB,EAAIwB,QAChD,MAAM,IAAIL,YAAY,UAAUwD,2BAElC,GAAI3E,EAAI0B,QACN,MAAM,IAAIC,UAAU,uCAAuC3B,EAAIuB,SAEjE,GAAIvB,EAAI4B,SACN,MAAM,IAAIC,EAAa,UAAU8C,eAAgB3E,EAAIuB,4BAEvD,GAAoB,OAAhBvB,EAAIwB,QACN,MAAM,IAAIG,UAAU,iCAEtB,GAAqC,mBAA1B3B,EAAIwB,QAAQxB,EAAIuB,QAAyBvB,EAAIwB,QAAQJ,eAAepB,EAAIuB,MACjF,MAAM,IAAIM,EAAa,gCAAgC7B,EAAIuB,qBAElD,WAAPoD,EACE3E,EAAIwB,QAAQJ,eAAepB,EAAIuB,QACjCC,EAAQoD,oBACL7D,IAAIf,EAAIwB,UACPkB,QAASC,GAAOA,EAAG,CAAEZ,KAAM,SAAUR,KAAMvB,EAAIuB,QACnDC,EAAQqD,0BACL9D,IAAIf,EAAIwB,UACPkB,QAASC,GAAOA,EAAG,CAAEZ,KAAM,SAAUR,KAAMvB,EAAIuB,SAE5CvB,EAAIwB,QAAQJ,eAAepB,EAAIuB,OACxCC,EAAQsD,iBACL/D,IAAIf,EAAIwB,UACPT,IAAIf,EAAIuB,OACRmB,QAASC,GACTA,EAAG,CACDZ,KAAM,aAGZP,EAAQuD,uBACLhE,IAAIf,EAAIwB,UACPT,IAAIf,EAAIuB,OACRmB,QAASC,GACTA,EAAG,CACDZ,KAAM,eAIZP,EAAQoD,oBACL7D,IAAIf,EAAIwB,UACPkB,QAASC,GAAOA,EAAG,CAAEZ,KAAM,SAAUR,KAAMvB,EAAIuB,QACnDC,EAAQqD,0BACL9D,IAAIf,EAAIwB,UACPkB,QAASC,GAAOA,EAAG,CAAEZ,KAAM,SAAUR,KAAMvB,EAAIuB,QAEvD,CACA,MAAMyD,EAAc,IAAI3E,IAAI,CAC1B,GAAG4E,KACH,GAAGC,IACH,GAAGC,MACH,GAAGC,QACH,GAAGC,OACH,GAAGC,QACH,GAAGC,KACH,GAAGC,mBAGQC,EACX,WAAAlH,CAAmB4B,EAAmCmB,GAAnC1C,KAAAuB,IAAAA,EAAmCvB,KAAA0C,IAAAA,CAAe,QAG1DoE,EACX,WAAAnH,CAAmB6D,GAAAxD,KAAAwD,KAAAA,CAAmC,QAG3CuD,EACX,WAAApH,CAAmB6D,GAAAxD,KAAAwD,KAAAA,CAAkB,QAG1BwD,EACX,WAAArH,CAAmBsH,EAAgBC,GAAhBlH,KAAAiH,EAAAA,EAAgBjH,KAAAkH,EAAAA,CAAU,EAG/C,MAAMC,EAAe,yBAcRC,EAAM,IAAIC,IACjB,SAAUC,EAAgCnE,EAA2BY,GACzEqD,EAAI3E,IAAIU,EAAMY,EAChB,CA2xBA,SAASwD,EAAYC,EAAY5E,GAC/B,OAAI4E,aAAanF,EAAamF,EAAErF,IAAIS,GAChC4E,IAAMlD,EACHkD,OADP,CAEF,CAEM,SAAUC,EACdzC,EACAjE,EACA2G,EACAC,EACA1C,EACArC,EACAgF,GAEI7G,IAAS8G,EAOf,SACE7C,EACA0C,EACAC,EACA1C,EACArC,EACAgF,GAEA,MAAMvG,EAAa,GACnB,IAAK,IAAItB,EAAI,EAAGA,EAAI2H,EAAKpH,OAAQP,IAAK,CACpC,IAAI+H,EACJ,IACEA,EAAMC,EAAUC,GAAMH,EAAS7C,EAAO0C,EAAK3H,GAAIkF,EAAOrC,EAASoF,EAAGJ,IAAiB1D,MACrF,CAAE,MAAO+D,GAEP,YADAN,EAAKM,EAEP,CACA,GAAIH,aAAe9D,IAAe8D,EAAI3D,UAAY2D,EAAI1D,WAAa0D,EAAIzD,cAErE,YADAsD,OAAKnH,EAAWsH,GAGlB,GAAIvE,EAAOmE,EAAK3H,KAAiB,IAAV2H,EAAK3H,GAAG,GAE7B,YADA4H,OAAKnH,EAAW,IAAIwD,EAAWpB,EAAQgB,IAAIK,YAAa6D,GAAK,IAG/DzG,EAAIgF,KAAKyB,EACX,CACAH,OAAKnH,EAAWa,EAClB,CAlCI6G,CAAclD,EAAO0C,EAAMC,EAAM1C,EAAOrC,EAASgF,GAoCrDlI,eACEsF,EACA0C,EACAC,EACA1C,EACArC,EACAgF,GAEA,MAAMvG,EAAa,GACnB,IAAK,IAAItB,EAAI,EAAGA,EAAI2H,EAAKpH,OAAQP,IAAK,CACpC,IAAI+H,EACJ,IACE,IAAIK,EACJL,GAEmB,KADhBK,EAAKC,EAAWJ,GAAMK,EAAUrD,EAAO0C,EAAK3H,GAAIkF,EAAOrC,EAASoF,EAAGJ,KACjEU,UACCH,EAAGI,eACIJ,EAAGK,GAAGtE,MACrB,CAAE,MAAO+D,GAEP,YADAN,EAAKM,EAEP,CACA,GAAIH,aAAe9D,IAAe8D,EAAI3D,UAAY2D,EAAI1D,WAAa0D,EAAIzD,cAErE,YADAsD,OAAKnH,EAAWsH,GAGlB,GAAIvE,EAAOmE,EAAK3H,KAAiB,IAAV2H,EAAK3H,GAAG,GAE7B,YADA4H,OAAKnH,EAAW,IAAIwD,EAAWpB,EAAQgB,IAAIK,YAAa6D,GAAK,IAG/DzG,EAAIgF,KAAKyB,EACX,CACAH,OAAKnH,EAAWa,EAClB,CAnEIoH,CAAezD,EAAO0C,EAAMC,EAAM1C,EAAOrC,EAASgF,GAAgBc,MAAMf,EAE5E,CAkFM,SAAUS,EAAUO,GACxB,IACIJ,EADAD,GAAY,EAEhB,MAAME,EAAI,IAAI7C,QAAa,CAACiD,EAASC,KACnCF,EAAS,CAACG,EAAK5E,KACT4E,EAAKD,EAAOC,IAEdR,GAAY,EACZC,EAAUrE,EACV0E,EAAQ,CAAE1E,gBAIhB,MAAO,CACLoE,YACAC,UACAC,IAEJ,CAEM,SAAUT,EAASY,GACvB,IAAIzE,EACA4E,EAKJ,GAJAH,EAAS,CAACV,EAAGc,KACXD,EAAMb,EACN/D,EAAS6E,IAEPD,EAAK,MAAMA,EACf,MAAO,CAAE5E,SACX,CAEOxE,eAAe2I,EACpBrD,EACA0C,EACAzC,EACArC,EACAoG,EACApB,GAEA,IAAID,EAAgBqB,EACpB,MAAMR,EAAI,IAAI7C,QAAeiD,IAC3BjB,EAAO,CAACM,EAAGc,KACTC,EAAaf,EAAGc,GAChBH,OAGJ,IAAKK,EAAiBjE,EAAO0C,EAAMzC,EAAOrC,EAAS+E,GAAM,EAAMC,IAAmBrE,EAAOmE,GAAO,CAC9F,IACItG,EADA2E,EAAK2B,EAAK,GAEd,IACE,IAAIS,EACJ/G,GAEmB,KADhB+G,EAAKC,EAAWJ,GAAMK,EAAUrD,EAAO0C,EAAK,GAAIzC,EAAOrC,EAASoF,EAAGJ,KACjEU,UACCH,EAAGI,eACIJ,EAAGK,GAAGtE,MACrB,CAAE,MAAO+D,GAEP,YADAN,EAAKM,EAEP,CACA,IAsBIiB,EAtBA1B,EAAIpG,EACR,IACEoG,EAAIpG,aAAeiB,EAAOjB,EAAIe,IAAIS,GAAWxB,CAC/C,CAAE,MAAO6G,GAEP,YADAN,EAAKM,EAEP,CACA,GAAM,KAAFlC,GAAkC,KAAFA,EAA8B,CAChE,GAAIyB,QAEF,YADAG,OAAKnH,EAAW8D,GAGlByB,EAAO,KAAFA,EAA8B,GACrC,CACA,GAAIyB,IAAMlD,EAAU,CAClB,GAAM,IAAFyB,GAA0B,IAAFA,EAE1B,YADA4B,OAAKnH,EAAWgH,GAGhBA,OAAIhH,CAER,CAEA,IACE,IAAI2H,EACJe,GAEmB,KADhBf,EAAKC,EAAWJ,GAAMK,EAAUrD,EAAO0C,EAAK,GAAIzC,EAAOrC,EAASoF,EAAGJ,KACjEU,UACCH,EAAGI,eACIJ,EAAGK,GAAGtE,MACrB,CAAE,MAAO+D,GAEP,YADAN,EAAKM,EAEP,CACA,IAAIkB,EAAID,EACR,IACEC,EAAID,aAAgB7G,EAAO6G,EAAK/G,IAAIS,GAAWsG,CACjD,CAAE,MAAOjB,GAEP,YADAN,EAAKM,EAEP,CAIA,GAHIkB,IAAM7E,IACR6E,OAAI3I,GAEF4G,EAAI9E,IAAIyD,GACV,IACEqB,EAAIjF,IAAI4D,EAARqB,GAAciB,EAAWV,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,EAASqC,EAAOiE,EAAMtB,EACzE,CAAE,MAAOkB,GACPnB,EAAKmB,EACP,MAEAnB,EAAK,IAAIpF,YAAY,qBAAuBwD,GAEhD,OACMyC,CACR,CAEM,SAAUX,EACd7C,EACA0C,EACAzC,EACArC,EACA+E,EACAC,GAEA,IAAKqB,EAAiBjE,EAAO0C,EAAMzC,EAAOrC,EAAS+E,GAAM,EAAOC,IAAmBrE,EAAOmE,GAAO,CAC/F,IACItG,EADA2E,EAAK2B,EAAK,GAEd,IACEtG,EAAM2G,EAAUC,GAAMH,EAAS7C,EAAO0C,EAAK,GAAIzC,EAAOrC,EAASoF,EAAGJ,IAAiB1D,MACrF,CAAE,MAAO+D,GAEP,YADAN,EAAKM,EAEP,CACA,IAsBIiB,EAtBA1B,EAAIpG,EACR,IACEoG,EAAIpG,aAAeiB,EAAOjB,EAAIe,IAAIS,GAAWxB,CAC/C,CAAE,MAAO6G,GAEP,YADAN,EAAKM,EAEP,CACA,GAAM,KAAFlC,GAAkC,KAAFA,EAA8B,CAChE,GAAIyB,QAEF,YADAG,OAAKnH,EAAW8D,GAGlByB,EAAO,KAAFA,EAA8B,GACrC,CACA,GAAIyB,IAAMlD,EAAU,CAClB,GAAM,IAAFyB,GAA0B,IAAFA,EAE1B,YADA4B,OAAKnH,EAAWgH,GAGhBA,OAAIhH,CAER,CAEA,IACE0I,EAAOnB,EAAUC,GAAMH,EAAS7C,EAAO0C,EAAK,GAAIzC,EAAOrC,EAASoF,EAAGJ,IAAiB1D,MACtF,CAAE,MAAO+D,GAEP,YADAN,EAAKM,EAEP,CACA,IAAIkB,EAAID,EACR,IACEC,EAAID,aAAgB7G,EAAO6G,EAAK/G,IAAIS,GAAWsG,CACjD,CAAE,MAAOjB,GAEP,YADAN,EAAKM,EAEP,CAIA,GAHIkB,IAAM7E,IACR6E,OAAI3I,GAEF4G,EAAI9E,IAAIyD,GACV,IACEqB,EAAIjF,IAAI4D,EAARqB,GAAcS,EAAUF,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,EAASqC,EAAOiE,EAAMtB,EACxE,CAAE,MAAOkB,GACPnB,EAAKmB,EACP,MAEAnB,EAAK,IAAIpF,YAAY,qBAAuBwD,GAEhD,CACF,CAtjCAuB,IAAsB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,EAASqC,KACpE,GAAU,OAANuC,EACF,MAAM,IAAIzE,UAAU,uBAAuBoG,aAE7C,MAAMhG,SAAcqE,EACpB,GAAa,cAATrE,QAAgC3C,IAARY,EAAmB,CAC7C,MAAMuB,EAAOsC,EAAM9C,IAAIgH,GACvB,GAAIxG,EAAKC,UAAYA,EAAQgB,IAAIwF,cAAe,CAC1CxG,EAAQgB,IAAIuB,QAAQkE,OACtBzG,EAAQgB,IAAIK,aAAaqF,cAAc9D,IAAI2D,GAE7C,MAAMI,EAAM3G,EAAQgB,IAAI4F,iBAAiBlH,IAAIM,EAAQgB,IAAIwF,cAAcD,IACnEvG,EAAQ6G,MAAMtH,IAAIS,EAAQgB,IAAIwF,cAAcD,SAC5C3I,EACJ,GAAI+I,EAEF,YADA5B,OAAKnH,EAAW+I,EAGpB,CACA,OAAI5G,EAAKC,SAAWD,EAAKC,QAAQuG,KAAOrJ,gBACtC6H,OAAKnH,EAAWoC,EAAQgB,IAAI8F,YAAYvH,IAAI,cAI9CwF,OAAKnH,EAAWmC,EAElB,CAAO,QAAUnC,IAANgH,EACT,MAAM,IAAIvE,EAAa,wBAA0BkG,EAAI,kBAGvD,GAAa,WAAThG,EACW,WAATA,EACFqE,EAAI,IAAImC,OAAOnC,GACG,WAATrE,EACTqE,EAAI,IAAIoC,OAAOpC,GACG,YAATrE,IACTqE,EAAI,IAAIqC,QAAQrC,SAEb,QAAgC,IAArBA,EAAEhF,eAElB,YADAmF,OAAKnH,EAAW,IAAI6B,OAAK7B,EAAW2I,IAItC,MAAMW,EAAsB,aAAT3G,EACb4G,EAAkBD,KAAgBtC,EAAEhF,eAAe2G,IAAmB,iBAANA,GAEtE,GAAIvG,EAAQgB,IAAIuB,QAAQkE,OAASU,GACd,iBAANZ,EAAgB,CACzB,IAAIa,EAAOxK,OAAOC,eAAe+H,GACjC,GACMwC,EAAKxH,eAAe2G,KAEpBvG,EAAQgB,IAAIK,cACXrB,EAAQgB,IAAIK,YAAY8F,gBAAgBC,EAAKrK,YAAYuF,QAE1DtC,EAAQgB,IAAIK,YAAY8F,gBAAgBC,EAAKrK,YAAYuF,MAAQ,IAAIzD,KAEvEmB,EAAQgB,IAAIK,aAAa8F,gBAAgBC,EAAKrK,YAAYuF,MAAMM,IAAI2D,UAE9Da,EAAOxK,OAAOC,eAAeuK,GACzC,CAGF,GAAID,EACF,GAAID,GACF,IAAK,CAAC,OAAQ,SAAU,eAAeG,SAASd,KAAO3B,EAAEhF,eAAe2G,IAAY,cAANA,GAAoB,CAChG,MAAMe,EAAYtH,EAAQgB,IAAI8B,mBAAmBvD,IAAIqF,EAAE5B,WACjDuE,EAAUvH,EAAQgB,IAAIuB,QAAQiF,sBAAsBjI,IAAIqF,GAC9D,GAAI2C,EAEF,YADAxC,OAAKnH,EAAW,IAAI6B,EAAK8H,EAAQ3C,GAAG,GAAO2B,IAG7C,IAAMe,GAAeA,EAAUG,OAAQH,EAAU5H,IAAI6G,GACnD,MAAM,IAAIlG,EAAa,mDAAmDuE,EAAEtC,QAAQiE,IAExF,OACK,GAAU,gBAANA,EAAqB,CAC9B,IAAIa,EAAOxC,EACX,KAAQwC,EAAOxK,OAAOC,eAAeuK,IACnC,GAAIA,EAAKxH,eAAe2G,GAAI,CAC1B,MAAMe,EAAYtH,EAAQgB,IAAI8B,mBAAmBvD,IAAI6H,GAC/CG,EAAUvH,EAAQgB,IAAIuB,QAAQiF,sBAAsBjI,IAAI6H,EAAKM,YACnE,GAAIH,EAEF,YADAxC,OAAKnH,EAAW,IAAI6B,EAAK8H,EAAQ3C,GAAG,GAAQ2B,IAG9C,GAAIe,KAAeA,EAAUG,MAAQH,EAAU5H,IAAI6G,IACjD,MAEF,MAAM,IAAIlG,EACR,4CAA4C+G,EAAKrK,YAAYuF,QAAQiE,IAEzE,CAEJ,CAGF,GAAIvG,EAAQ6G,MAAMnH,IAAIkF,EAAE2B,IAEtB,YADAxB,OAAKnH,EAAWoC,EAAQ6G,MAAMtH,IAAIqF,EAAE2B,KAGtC,GAAI3B,EAAE2B,KAAOrJ,WAEX,YADA6H,OAAKnH,EAAWoC,EAAQgB,IAAI8F,YAAYvH,IAAI,SAI9C,MAAMoI,EACJnJ,EAAI4B,UACH8G,IAAelF,EAAmBtC,IAAIkF,IACvC5E,EAAQgB,IAAI4F,iBAAiBlH,IAAIkF,GAEnCG,OAAKnH,EAAW,IAAI6B,EAAKmF,EAAG2B,GAAG,EAAOoB,MAGxCjD,IAAsB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KAC3D,GAAIA,EAAQgB,IAAIuB,QAAQqF,oBACtB,MAAM,IAAIvH,EAAa,wCACzB,GAAiB,mBAANuE,EACT,MAAM,IAAIzE,UAAU,GAAuB,iBAAb3B,EAAIuB,KAAoB,SAAWvB,EAAIuB,0BAEvE,MAAM8H,EAAOtB,EACVuB,IAAKlH,GACAA,aAAgBuD,EACX,IAAIvD,EAAKA,MAET,CAACA,IAGXmH,OACAD,IAAKlH,GAAS+D,EAAY/D,EAAMZ,IAEnC,GAAmB,mBAARxB,EAAX,CAIA,GAAIA,EAAIwB,QAAQxB,EAAIuB,QAAUiI,KAAKC,WAAajI,EAAQiB,iBAAiBwG,KAAM,CAC7E,MAAMS,EAAQ,IAAIrJ,IACZsJ,EAAWC,IACf,GAAKA,GAAoB,iBAANA,IAAmBF,EAAMxI,IAAI0I,GAAhD,CACAF,EAAMtF,IAAIwF,GACV,IAAK,MAAMC,KAAKzL,OAAO0L,KAAKF,GAC1BpI,EAAQiB,iBAAiBC,QAASC,GAAOA,EAAGiH,EAAGC,IAC/CF,EAAQC,EAAEC,GAJwC,GAOtDF,EAAQN,EAAK,GACf,CAEA,GACErJ,EAAIwB,mBAAmBa,OACvB2C,EAAY9D,IAAIlB,EAAIwB,QAAQxB,EAAIuB,SAC/BC,EAAQoD,oBAAoB7D,IAAIf,EAAIwB,UACnCA,EAAQqD,0BAA0B9D,IAAIf,EAAIwB,UAC5C,CACA,IAAIuI,EACAC,GAAU,EACd,GAAiB,SAAbhK,EAAIuB,KACNwI,EAAS,CACPhI,KAAM,OACNkI,MAAOZ,GAETW,IAAYX,EAAKnK,YACZ,GAAiB,QAAbc,EAAIuB,KACbwI,EAAS,CACPhI,KAAM,MACNmI,QAASlK,EAAIwB,QAAQ5B,OAAM,IAE7BoK,IAAYD,EAAOG,QAAQhL,YACtB,GAAiB,UAAbc,EAAIuB,KACbwI,EAAS,CACPhI,KAAM,QACNmI,QAASlK,EAAIwB,QAAQ5B,MAAM,EAAG,IAEhCoK,IAAYD,EAAOG,QAAQhL,YACtB,GAAiB,YAAbc,EAAIuB,KACbwI,EAAS,CACPhI,KAAM,UACNkI,MAAOZ,GAETW,IAAYX,EAAKnK,YACZ,GAAiB,WAAbc,EAAIuB,KACbwI,EAAS,CACPhI,KAAM,SACNoI,WAAYd,EAAK,GACjBe,iBAAyBhL,IAAZiK,EAAK,GAAmBrJ,EAAIwB,QAAQtC,OAASmK,EAAK,GAC/DY,MAAOZ,EAAKzJ,MAAM,GAClBsK,QAASlK,EAAIwB,QAAQ5B,MAAMyJ,EAAK,QAAgBjK,IAAZiK,EAAK,QAAmBjK,EAAYiK,EAAK,GAAKA,EAAK,KAEzFW,IAAYD,EAAOE,MAAM/K,UAAY6K,EAAOG,QAAQhL,YAC/C,GAAiB,YAAbc,EAAIuB,MAAmC,SAAbvB,EAAIuB,KACvCwI,EAAS,CAAEhI,KAAM/B,EAAIuB,MACrByI,IAAYhK,EAAIwB,QAAQtC,YACnB,GAAiB,eAAbc,EAAIuB,KAAuB,CACpC,MAAMjC,OACQF,IAAZiK,EAAK,GACDrJ,EAAIwB,QAAQtC,OAASmK,EAAK,GAC1BgB,KAAKC,IAAItK,EAAIwB,QAAQtC,OAAQmK,EAAK,GAAKA,EAAK,IAClDU,EAAS,CACPhI,KAAM,aACNoI,WAAYd,EAAK,GACjBkB,SAAUlB,EAAK,GAAK/J,EACpB2K,MAAOjK,EAAIwB,QAAQ5B,MAAMyJ,EAAK,GAAIA,EAAK,GAAK/J,GAC5C4K,QAASlK,EAAIwB,QAAQ5B,MAAMyJ,EAAK,GAAIA,EAAK,GAAK/J,IAEhD0K,IAAYD,EAAOE,MAAM/K,UAAY6K,EAAOG,QAAQhL,MACtD,CACI8K,IACFxI,EAAQoD,oBAAoB7D,IAAIf,EAAIwB,UAAUkB,QAASC,GAAOA,EAAGoH,IACjEvI,EAAQqD,0BAA0B9D,IAAIf,EAAIwB,UAAUkB,QAASC,GAAOA,EAAGoH,IAE3E,CACA/J,EAAIe,IAAIS,GACR+E,OAAKnH,EAAWY,EAAIwB,QAAQxB,EAAIuB,SAAS8H,GA9EzC,MAFE9C,OAAKnH,EAAWY,KAAOqJ,MAmF3BnD,EAAM,GAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,KACnD,IAAIrB,EAAM,CAAA,EACV,IAAK,MAAMtE,KAAQ2F,EACb3F,EAAKjC,eAAeuF,EACtBgB,EAAM,IAAKA,KAAQtE,EAAKjC,IAAIiC,MAE5BsE,EAAItE,EAAKjC,KAAOiC,EAAKd,IAGzBiF,OAAKnH,EAAWsH,KAGlBR,EAAM,EAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IACrDxB,OAAKnH,EAAW,IAAIqG,EAAOW,EAAG2B,KAGhC7B,KAA6B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KAWlE+E,OAAKnH,EAVS2I,EACXuB,IAAKlH,GACAA,aAAgBuD,EACX,IAAIvD,EAAKA,MAET,CAACA,IAGXmH,OACAD,IAAKlH,GAAS+D,EAAY/D,EAAMZ,OAIrC0E,EAAM,GAAiB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAW2I,IAEpE7B,EAAM,GAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,KACnD,OAAQA,GACN,IAAK,OACH,OAAOxB,OAAKnH,GAAW,GACzB,IAAK,QACH,OAAOmH,OAAKnH,GAAW,GACzB,IAAK,OACH,OAAOmH,OAAKnH,EAAW,MACzB,IAAK,YACH,OAAOmH,OAAKnH,OAAWA,GACzB,IAAK,MACH,OAAOmH,OAAKnH,EAAWoL,KACzB,IAAK,WACH,OAAOjE,OAAKnH,EAAWqL,KAE3BlE,EAAK,IAAIrE,MAAM,mBAAqB6F,MAGtC7B,EAAM,EAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWmJ,OAAOR,KAC5E7B,EAAM,GAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWsL,OAAO3C,KAC5E7B,EAAM,EAAuB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,IAClE+E,OAAKnH,EAAWoC,EAAQmJ,UAAUC,QAAQC,SAAS9C,MAGrD7B,KAA4B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACjE,MAAMsJ,EAActJ,EAAQmJ,UAAUI,QAAQF,SAAS9C,IACvD,IAAKvG,EAAQgB,IAAI4F,iBAAiBlH,IAAI8J,QACpC,MAAM,IAAInJ,EAAa,uBAEvB0E,OAAKnH,EAAW,IAAI4L,OAAOF,EAAIG,MAAOH,EAAII,UAI9ChF,KAA8B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,EAASqC,KAC5E,MAAMzB,EAAOZ,EAAQmJ,UAAUQ,SAASN,SAAS9C,KAC3C,CAAGjE,EAAMsH,GAAMhJ,EACf1C,EAAgB,GACtB,IAAIoG,EACJ,MAAMuF,EAAoB,GAC1B,KAAQvF,EAAIC,EAAapG,KAAKmE,IACvBgC,EAAE,KACLpG,EAAMuF,KAAKmG,EAAGP,SAAS/E,EAAE,GAAI,MAC7BuF,EAAQpG,KAAKa,EAAE,KAInBnG,EAAgBiE,EAAOlE,EAAOmE,EAAOrC,EAAS,CAACkG,EAAK4D,KAClD,MAAMC,EAAiC,CAAA,EACvC,GAAI7D,EACFnB,EAAKmB,OADP,CAIA,IAAK,MAAM/I,KAAKP,OAAO0L,KAAKwB,GAA2C,CACrE,MAAME,EAAMH,EAAQ1M,GACpB4M,EAAMC,GAAOF,EAAW3M,EAC1B,CACA4H,OACEnH,EACA0E,EAAKiF,QAAQ,yBAA0B,CAAC0C,EAAOC,EAAIC,EAAGH,KACpD,GAAIG,EAAG,OAAOF,EAEd,OAAQC,GAAU,IAAM,GAAGvF,EADfoF,EAAMC,GAC0BhK,OAVhD,MAgBJ0E,EAAM,GAAuB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,KAClDxB,OAAKnH,EAAW,IAAIuG,EAAYoC,MAGlC7B,EAAM,GAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,KACnDxB,OAAKnH,EAAW,IAAIsG,EAAaqC,MAGnC7B,EAAM,GAAe,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,GAAY2I,IACnE7B,EAAM,GAAmB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,GAAY2I,IAEvE7B,KAAiC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,KAC9DkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,IAAaY,EAAIwB,QAAQxB,EAAIuB,SAGpC2E,KAAgC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,KAC7DkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAWY,EAAIwB,QAAQxB,EAAIuB,WAGlC2E,KAAiC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,KAC9DkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,IAAaY,EAAIwB,QAAQxB,EAAIuB,SAGpC2E,KAAgC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,KAC7DkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAWY,EAAIwB,QAAQxB,EAAIuB,WAGlC2E,IAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,KACrDkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,MAAQwG,KAG3C7B,KAA2B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,KACxDkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAA+B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACpEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAA8B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACnEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAAgC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACrEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAA6B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KAClEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,QAAUwG,KAG7C7B,KAA+B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACpEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAAiC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACtEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAA8B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACnEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAA6B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KAClEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,OAASwG,KAG5C7B,KAAiC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACtEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,QAAUwG,KAG7C7B,KAAkC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KACvEkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,QAAUwG,KAG7C7B,KAA0C,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAW/H,EAAKwB,KAC/EkD,EAAY1E,EAAKwB,GACjB+E,OAAKnH,EAAYY,EAAIwB,QAAQxB,EAAIuB,QAAUwG,KAG7C7B,EAAM,GAAsB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,EAAI2B,IAC7E7B,EAAM,GAAuB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,EAAI2B,IAC9E7B,EAAM,GAA2B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,GAAK2B,IACnF7B,EAAM,GAA4B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,GAAK2B,IACpF7B,EAAM,GAAiB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,GAAK2B,IACzE7B,EAAM,GAAuB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,IAAM2B,IAChF7B,EAAM,GAAoB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,GAAK2B,IAC5E7B,EAAM,GAA0B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,IAAM2B,IACnF7B,EAAM,GAAe,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,GAAK2B,IACvE7B,EAAM,GAAc,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAWgH,GAAK2B,IACtE7B,EAAM,GAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IACzF7B,EAAM,GAAiB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IACxF7B,EAAM,GAAgB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IACvF7B,EAAM,GAAiB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IACxF7B,EAAM,GAAoB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,GAAY2I,IACxE7B,EAAM,GAAoB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,GAAY2I,IACxE7B,EAAM,GAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IACzF7B,EAAM,GAAqB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IAC5F7B,EAAM,GAAoB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IAC3F7B,EAAM,GAAmB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,EAAI2B,IAC1F7B,EAAM,GAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAcxB,OAAKnH,EAAWgH,GAAK2B,IAChG7B,EAAM,GAAyB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAC5DxB,OAAKnH,EAAWgH,GAAK2B,IAEvB7B,EAAM,GAAiC,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IACpExB,OAAKnH,EAAWgH,IAAM2B,IAExB7B,KAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAa/H,EAAKwB,EAASqC,KACxElE,EAAKiE,EAAOmE,EAAGlE,EAAOrC,EAAS,CAACqF,EAAGtF,KACjCgF,OAAKnH,SAAkB+G,EAAY5E,EAAMC,QAI7C0E,EAAM,GAAsB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IACjDxB,OAAKnH,EAAWgH,aAAa2B,IAE/B7B,EAAM,GAAc,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,IAAMxB,OAAKnH,EAAWgH,KAAK2B,IAE9E7B,EAAM,GAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,EAAG/H,EAAKwB,EAASqC,EAAOiE,UAChD1I,IAAjB0I,EAAKtG,SAITkD,EAAYoD,EAAMtG,EAAS,UACvBsG,EAAKvF,WACPgE,OAAKnH,GAAW,GAGlBmH,OAAKnH,SAAkB0I,EAAKtG,UAAUsG,EAAKvG,QARzCgF,OAAKnH,GAAW,KAWpB8G,EAAM,EAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAW2I,IAErE7B,KAAqB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,EAAa/H,EAAKwB,EAASqC,KAC7E0C,OAAKnH,EAAWyE,EAAM/B,QAAQsE,EAAC,MAAe2B,MAGhD7B,EAAM,EAAe,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,EAAa/H,EAAKwB,EAASqC,EAAOiE,KACpFvB,OAAKnH,EAAWyE,EAAM/B,QAAQsE,EAAC,MAAe2B,EAAGD,GAAQA,EAAKlG,aAGhEsE,IAAuB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,EAAa/H,EAAKwB,EAASqC,KAC/E0C,OAAKnH,EAAWyE,EAAM/B,QAAQsE,EAAC,QAAiB2B,MAGlD7B,KAEE,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAa2B,EAAW/H,EAAWwB,EAASqC,KAE9D,GADAuC,EAAI,IAAIA,GACc,iBAAXpG,EAAI,IAAmBA,EAAI,aAAcnB,EAAY,CAC9D,IAAI2C,EAAQoK,WAAYpK,EAAQqK,YAG9B,MAAM,IAAIhK,EAAa,8CAFvB7B,EAAI,GAAK+H,EAAIvG,EAAQqK,YAAYC,gBAAgB,IAAIjN,EAAWmB,EAAI,IAAKwB,EAAQmJ,UAIrF,CACIvE,EAAEjB,QACJoB,OAAKnH,EAAWiF,EAAoB+B,EAAG2B,EAAGnE,EAAOpC,EAASqC,IAE1D0C,OAAKnH,EAAWsE,EAAe0C,EAAG2B,EAAGnE,EAAOpC,EAASqC,MAK3DqC,KAEE,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAA0B2B,EAAW/H,EAAWwB,EAASqC,KAC3E,GAAsB,iBAAX7D,EAAI,IAAmBA,EAAI,aAAcnB,EAAY,CAC9D,IAAI2C,EAAQoK,WAAYpK,EAAQqK,YAG9B,MAAM,IAAIhK,EAAa,8CAFvB7B,EAAI,GAAK+H,EAAIvG,EAAQqK,YAAYC,gBAAgB,IAAIjN,EAAWmB,EAAI,IAAKwB,EAAQmJ,UAIrF,CACA,MAAMoB,EAAU3F,EAAEjB,QACZrB,EAAOsC,EAAEjB,QACf,IAAIlB,EAEFA,EADS,KAAP8H,EACK1H,EAAoB+B,EAAe2B,EAAGnE,EAAOpC,EAASqC,EAAOC,GAE7DJ,EAAe0C,EAAe2B,EAAGnE,EAAOpC,EAASqC,EAAOC,GAE7DA,GACFD,EAAM/B,QAAQgC,EAAI,MAAeG,GAEnCsC,OAAKnH,EAAW6E,KAIpBiC,KAEE,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAA0B2B,EAAW/H,EAAWwB,EAASqC,KAC3E,GAAsB,iBAAX7D,EAAI,IAAmBA,EAAI,aAAcnB,EAAY,CAC9D,IAAI2C,EAAQoK,WAAYpK,EAAQqK,YAG9B,MAAM,IAAIhK,EAAa,8CAFvB7B,EAAI,GAAK+H,EAAIvG,EAAQqK,YAAYC,gBAAgB,IAAIjN,EAAWmB,EAAI,IAAKwB,EAAQmJ,UAIrF,CACA,MAAMoB,EAAU3F,EAAEjB,QACZrB,EAAOsC,EAAEjB,QAIf,IAAIlB,EAHAH,IACFD,EAAQ,IAAIvD,EAAMuD,EAAO,KAIzBI,EADS,KAAP8H,EACK1H,EAAoB+B,EAAe2B,EAAGnE,EAAOpC,EAASqC,EAAOC,GAE7DJ,EAAe0C,EAAe2B,EAAGnE,EAAOpC,EAASqC,EAAOC,GAE7DA,GACFD,EAAM/B,QAAQgC,EAAI,MAAeG,GAEnCsC,OAAKnH,EAAW6E,KAIpBiC,KAAsB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAW2B,EAAW/H,EAAKwB,EAASqC,KAC5E,MAAOmI,EAAYC,EAAeC,EAAaC,EAAWC,EAAMC,EAAWC,GAAclG,EACzF,IAAImG,GAAO,EACX,MAAMC,EAAY,IAAIlM,EAAMuD,EAAO,CAAA,GAC7B4I,EAAe,CACnBC,WAAOtN,GAEHuN,EAAe,IAAIrM,EAAMkM,EAAWC,GAC1C,GAAI9M,IAASsH,EACX,WACE,IAAIF,EAaJ,IAZAA,EAAKC,EAAWJ,GAAMjH,EAAKiE,EAAOuI,EAAWK,EAAWhL,EAASoF,IACjE6F,EAAoB,OACqE,KAAtF1F,EAAKC,EAAWJ,GAAMjH,EAAKiE,EAAOsI,EAAaM,EAAWhL,EAASoF,KAAKM,UACrEH,EAAGI,eACIJ,EAAGK,GAAGtE,OACnBiE,EAAKC,EAAWJ,GAAMjH,EAAKiE,EAAOqI,EAAeU,EAAcnL,EAASoF,IACpEoF,IACFO,GAEE,KADCxF,EAAKC,EAAWJ,GAAMjH,EAAKiE,EAAOyI,EAAWM,EAAcnL,EAASoF,KAAKM,UAEtEH,EAAGI,eACIJ,EAAGK,GAAGtE,QACdyJ,GAAM,CACX,MAAMK,EAAgB,CAAA,EACtB7F,EAAKC,EAAWJ,GACdjH,EAAKiE,EAAO0I,EAAY,IAAIhM,EAAMqM,EAAcC,GAAgBpL,EAASoF,KAE1D,IAAjBG,EAAGG,UAAqBH,EAAGI,eAAiBJ,EAAGK,GAAGtE,OAClD,MAAM4D,QAAYjC,EAChBb,EACApC,EACAuG,EACA,CAAC,IAAIzH,EAAMkM,EAAWI,IACtB,QAEF,GAAIlG,aAAe9D,GAAc8D,EAAI3D,SAEnC,YADAwD,OAAKnH,EAAWsH,GAGlB,GAAIA,aAAe9D,GAAc8D,EAAI1D,UACnC,MAEF+D,EAAKC,EAAWJ,GAAMjH,EAAKiE,EAAOwI,EAAMO,EAAcnL,EAASoF,IAC/D2F,GAEE,KADCxF,EAAKC,EAAWJ,GAAMjH,EAAKiE,EAAOyI,EAAWM,EAAcnL,EAASoF,KAAKM,UAEtEH,EAAGI,eACIJ,EAAGK,GAAGtE,MACrB,CACAyD,GACD,EA1CD,GA0CKe,MAAMf,OACN,CAKL,IAJAI,EAAUC,GAAMjH,EAAKiE,EAAOuI,EAAWK,EAAWhL,EAASoF,IAC3D6F,EAAoB,MAAI9F,EAAUC,GAAMjH,EAAKiE,EAAOsI,EAAaM,EAAWhL,EAASoF,IAAI9D,OACzF6D,EAAUC,GAAMjH,EAAKiE,EAAOqI,EAAeU,EAAcnL,EAASoF,IAC9DoF,IAAYO,EAAO5F,EAAUC,GAAMjH,EAAKiE,EAAOyI,EAAWM,EAAcnL,EAASoF,IAAI9D,QAClFyJ,GAAM,CACX,MAAMK,EAAgB,CAAA,EACtBjG,EAAUC,GAAMjH,EAAKiE,EAAO0I,EAAY,IAAIhM,EAAMqM,EAAcC,GAAgBpL,EAASoF,IACzF,MAAMF,EAAMxC,EAAYN,EAAOpC,EAASuG,EAAG,CAAC,IAAIzH,EAAMkM,EAAWI,IAAiB,QAClF,GAAIlG,aAAe9D,GAAc8D,EAAI3D,SAEnC,YADAwD,OAAKnH,EAAWsH,GAGlB,GAAIA,aAAe9D,GAAc8D,EAAI1D,UACnC,MAEF2D,EAAUC,GAAMjH,EAAKiE,EAAOwI,EAAMO,EAAcnL,EAASoF,IACzD2F,EAAO5F,EAAUC,GAAMjH,EAAKiE,EAAOyI,EAAWM,EAAcnL,EAASoF,IAAI9D,MAC3E,CACAyD,GACF,IAGFL,EAAM,GAEJ,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAa2B,EAAa/H,EAAKwB,EAASqC,EAAOiE,EAAMtB,KACvE,GAAwB,WAAnBA,GAAqC,aAANJ,IAAsBI,EACxD,MAAM,IAAI3E,EAAa,WAAauE,EAAI,cAE1CG,OACEnH,EACA,IAAIwD,EAAWpB,EAAQgB,IAAIK,iBAAazD,GAAW,EAAa,UAANgH,EAAqB,aAANA,MAK/EF,KAEE,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAa2B,EAAO/H,EAAKwB,EAASqC,KACpDlE,EAAKiE,EAAOuC,EAAYC,EAAG5E,GAAWuG,EAAElC,EAAIkC,EAAEjC,EAAGjC,EAAOrC,EAAS+E,KAIrEL,KAA0B,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAa2B,EAAO/H,EAAKwB,EAASqC,KAC9ElE,EAAKiE,EAAOuC,EAAYC,EAAG5E,GAAWuG,EAAElC,EAAIkC,EAAEjC,EAAGjC,EAAOrC,EAAS+E,KAEnEL,EAAM,GAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAW,IAAIwG,EAAGQ,EAAG2B,KACrF7B,EAAM,GAAkB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,IAAMxB,OAAKnH,EAAW,IAAIwG,EAAGQ,EAAG2B,KAE/E7B,KAAwB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAa2B,EAAiB/H,EAAKwB,EAASqC,KACtFlE,EAAKiE,EAAOwC,EAAGvC,EAAOrC,EAAS,CAACkG,EAAKmF,KACnC,GAAInF,EACFnB,EAAKmB,QAIP,GADAmF,EAAS1G,EAAY0G,EAAQrL,GACzB7B,IAAS8G,EAAU,CACrB,IAAIC,EACAoG,GAAS,EACb,IAAK,MAAMC,KAAYhF,EACrB,GACE+E,IACCA,GACEC,EAAS,IACVF,IACE1G,EACEQ,EAAUC,GAAMjH,EAAKiE,EAAOmJ,EAAS,GAAIlJ,EAAOrC,EAASoF,IAAI9D,OAC7DtB,IAEN,CACA,IAAKuL,EAAS,GAAI,SAElB,GADArG,EAAMxC,EAAYN,EAAOpC,EAASuL,EAAS,GAAI,CAAClJ,GAAQ,UACpD6C,EAAI1D,UAAW,MACnB,GAAI0D,EAAI3D,SAEN,YADAwD,OAAKnH,EAAWsH,GAGlB,IAAKqG,EAAS,GAEZ,KAEJ,CAEFxG,GACF,KACE,WACE,IAAIG,EACAoG,GAAS,EACb,IAAK,MAAMC,KAAYhF,EAAG,CACxB,IAAIhB,EACJ,GACE+F,IACCA,GACEC,EAAS,IACVF,IACE1G,GAEI,KADDY,EAAKC,EAAWJ,GAAMjH,EAAKiE,EAAOmJ,EAAS,GAAIlJ,EAAOrC,EAASoF,KAAKM,UAEjEH,EAAGI,eACIJ,EAAGK,GAAGtE,OACjBtB,IAEN,CACA,IAAKuL,EAAS,GAAI,SAElB,GADArG,QAAYjC,EAAiBb,EAAOpC,EAASuL,EAAS,GAAI,CAAClJ,GAAQ,UAC/D6C,EAAI1D,UAAW,MACnB,GAAI0D,EAAI3D,SAEN,YADAwD,OAAKnH,EAAWsH,GAGlB,IAAKqG,EAAS,GAEZ,KAEJ,CACF,CACAxG,GACD,EAhCD,GAgCKe,MAAMf,OAKjBL,EAAM,GAEJ,CACEvG,EACA4G,EACA3C,EACAwC,EACA2B,EACA/H,EACAwB,EACAqC,EACAiE,EACAtB,KAEA,MAAOwG,EAAWC,EAAWC,GAAenF,EAC5CoF,EACExN,EACA,CAAC+H,EAAKhB,KACJyG,EACExN,EACCkH,IACKA,EAAGN,EAAKM,GACHa,EAGPyF,EACExN,EACA4G,EACA3C,EACApC,EACAyL,EACA,CAAC,IAAI3M,EAAMuD,IACX2C,GAGFD,OAAKnH,EAAWsH,IAGpB9C,EACApC,EACA0L,EACA,CAAC,IAAI5M,EAAMuD,EAAO,CAAA,MAGtBD,EACApC,EACA4E,EACA,CAAC,IAAI9F,EAAMuD,IACX2C,KAKNN,KAAsB,CAACvG,EAAM4G,KAC3BA,MAEFL,KAEE,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAwC2B,EAAc/H,EAAKwB,KAC7E,IAAKA,EAAQgB,IAAI4F,iBAAiBlH,IAAIkF,KAAO5C,EAAmBtC,IAAIkF,GAClE,MAAM,IAAIvE,EAAa,oCAAoCuE,EAAE7H,YAAYuF,QAE3EyC,OAAKnH,EAAW,IAAIgH,KAAK2B,MAI7B7B,EAAM,GAAiB,CAACvG,EAAM4G,EAAM3C,EAAOwC,EAAG2B,KAC5CxB,EAAKwB,KAEP7B,EAAM,GAAsB,CAACvG,EAAM4G,EAAM3C,EAAOwC,IAAiBG,OAAKnH,EAAWgH,EAAElB,QACnFgB,EAAM,EAAgB,CAACvG,EAAM4G,IAASA,KAiStC,MAAM6G,EAAc,IAAI/M,IAAI,8BAc5B,SAASwH,EACPjE,EACA0C,EACAzC,EACArC,EACA+E,EACAwF,EACAvF,GAEA,MAAM7G,EAAOoM,EAAU9E,EAAYR,EACnC,GAAIjF,EAAQgB,IAAIuB,QAAQsJ,gBAAkB7L,EAAQgB,IAAIuB,QAAQsJ,gBAAkBzJ,EAAMA,QAGzB,mBAAhDpC,EAAQgB,IAAIuB,QAAQuJ,0BAC3B9L,EAAQgB,IAAIuB,QAAQuJ,wBAAwB1J,EAAOC,EAAOrC,EAAS8E,IAIrE,OADAC,EAAK,IAAI1E,EAAa,8BACf,EAKX,GAFA+B,EAAMA,QAEF0C,aAAgBrF,EAClB,IACEsF,OAAKnH,EAAWkH,EAAKvF,IAAIS,GAC3B,CAAE,MAAOkG,GACPnB,EAAKmB,EACP,MACK,GAAIpB,IAASpD,EAClBqD,SACK,GAAIlE,MAAMC,QAAQgE,KAAUnE,EAAOmE,GAC7B,IAAPA,EAAK,GACPC,IAEAF,EAASzC,EAAOjE,EAAM2G,EAAgBC,EAAM1C,EAAOrC,EAASgF,QAEzD,GAAKrE,EAAOmE,GAEZ,GAAW,KAAPA,EAAK,GACdD,EAASzC,EAAOjE,EAAM2G,EAAK,GAAcC,EAAM1C,EAAOrC,EAASgF,QAC1D,GAAW,KAAPF,EAAK,GACTyF,EAEMvK,EAAQgB,IAAI8B,oBAAoBpD,IAAIqD,QAAQC,WACrDyC,EACErD,EACA0C,EAAK,GACLzC,EACArC,EACAlD,MAAOuI,EAAGc,KACR,GAAId,EAAGN,EAAKM,QAEV,IACEN,OAAKnH,QAAiB+G,EAAYwB,EAAGnG,GACvC,CAAE,MAAOkG,GACPnB,EAAKmB,EACP,GAEJlB,GACAc,MAAMf,GAERA,EAAK,IAAI1E,EAAa,iCAnBtB0E,EAAK,IAAI1E,EAAa,8DAqBnB,KAAIuL,EAAYlM,IAAIoF,EAAK,IAkB9B,OAAO,EAjBP,IACEN,EAAIjF,IAAIuF,EAAK,GAAbN,GACErG,EACA4G,EACA3C,EACA0C,EAAK,GACLA,EAAK,GACLA,EACA9E,EACAqC,OACAzE,EACAoH,EAEJ,CAAE,MAAOkB,GACPnB,EAAKmB,EACP,CAGF,MA7CEnB,OAAKnH,EAAWkH,GA8ClB,OAAO,CACT,CACM,SAAUpC,EACdN,EACApC,EACA+L,EACAC,EAAmB,GACnBhH,GAEA,OAAOG,EAAUJ,GACf4G,EAAoB1G,EAAUF,EAAM3C,EAAOpC,EAAS+L,EAAeC,EAAQhH,IAC3E1D,MACJ,CAEOxE,eAAemG,EACpBb,EACApC,EACA+L,EACAC,EAAmB,GACnBhH,GAEA,IAAIO,EACJ,OAEiB,KAFTA,EAAKC,EAAWT,GACtB4G,EAAoBlG,EAAWV,EAAM3C,EAAOpC,EAAS+L,EAAeC,EAAQhH,KAC3EU,UACCH,EAAGI,eACIJ,EAAGK,GAAGtE,MACnB,CAEA,SAASqK,EACPxN,EACA4G,EACA3C,EACApC,EACA+L,EACAC,EAAmB,GACnBhH,GAEA,IAAK+G,EAEH,YADAhH,IAGF,KAAMgH,aAAyBlL,OAC7B,MAAM,IAAIlB,YAAY,sBAExB,IACIsM,EADA5J,EAAQrC,EAAQgB,IAAI8F,YAExB,KAAQmF,EAAID,EAAOrI,SACA,iBAANsI,IAET5J,EADE4J,aAAanN,EACPmN,EAEA,IAAInN,EAAMuD,EAAO4J,EAAGA,aAAaxL,OAAa7C,EAAY,OAGlEoC,EAAQgB,IAAIuB,QAAQkE,QAAUzG,EAAQgB,IAAIK,cAC5CrB,EAAQgB,IAAIK,YAAc,CACxBqF,cAAe,IAAI7H,IACnBsI,gBAAiB,CAAA,IAGjBhJ,IAAS8G,EAOf,SACEF,EACA3C,EACApC,EACA+L,EACA1J,EACA2C,GAEA,KAAM+G,aAAyBlL,OAAQ,MAAM,IAAIlB,YAAY,sBAC7D,IAAIxC,EAAI,EACR,IAAKA,EAAI,EAAGA,EAAI4O,EAAcrO,OAAQP,IAAK,CACzC,IAAI+H,EACAgB,EACJ,MAAMgG,EAAUH,EAAc5O,GAC9B,IACE8H,EACE7C,EACA8J,EACA7J,EACArC,EACA,CAACqF,EAAGc,KACFD,EAAMb,EACNH,EAAMiB,GAERnB,EAEJ,CAAE,MAAOK,GACPa,EAAMb,CACR,CACA,GAAIa,EAEF,YADAnB,EAAKmB,GAGP,GAAIhB,aAAe9D,EAEjB,YADA2D,OAAKnH,EAAWsH,GAGlB,GAAIvE,EAAOuL,IAAsB,IAAVA,EAAQ,GAE7B,YADAnH,OAAKnH,EAAW,IAAIwD,EAAWpB,EAAQgB,IAAIK,YAAa6D,GAAK,GAGjE,CACAH,OAAKnH,EAAW,IAAIwD,EAAWpB,EAAQgB,IAAIK,iBAAazD,GAAW,GACrE,CAjDIuO,CAAqBpH,EAAM3C,EAAOpC,EAAS+L,EAAe1J,EAAO2C,GAmDrElI,eACEiI,EACA3C,EACApC,EACA+L,EACA1J,EACA2C,GAEA,KAAM+G,aAAyBlL,OAAQ,MAAM,IAAIlB,YAAY,sBAC7D,IAAIxC,EAAI,EACR,IAAKA,EAAI,EAAGA,EAAI4O,EAAcrO,OAAQP,IAAK,CACzC,IAAI+H,EACAgB,EACJ,MAAMgG,EAAUH,EAAc5O,GAC9B,UACQsI,EACJrD,EACA8J,EACA7J,EACArC,EACA,CAACqF,EAAGc,KACFD,EAAMb,EACNH,EAAMiB,GAERnB,EAEJ,CAAE,MAAOK,GACPa,EAAMb,CACR,CACA,GAAIa,EAEF,YADAnB,EAAKmB,GAGP,GAAIhB,aAAe9D,EAEjB,YADA2D,OAAKnH,EAAWsH,GAGlB,GAAIvE,EAAOuL,IAAsB,IAAVA,EAAQ,GAE7B,YADAnH,OAAKnH,EAAW,IAAIwD,EAAWpB,EAAQgB,IAAIK,YAAa6D,GAAK,GAGjE,CACAH,OAAKnH,EAAW,IAAIwD,EAAWpB,EAAQgB,IAAIK,iBAAazD,GAAW,GACrE,CA5FIwO,CAAsBrH,EAAM3C,EAAOpC,EAAS+L,EAAe1J,EAAO2C,GAAgBc,MAAMf,EAE5F,CC3/CA,SAASsH,EACP7N,EACA8D,EACAyD,EACA/F,GAQA,KAAMxB,aAAe5B,QACnB,MAAM,IAAI8D,MACR,qCAAsD,iBAARlC,EAAmB,cAAgBA,IAErF,MAAM8N,EACJtM,EAAQsD,iBAAiB/D,IAAIf,IAAQ,IAAIiG,IAC3CzE,EAAQsD,iBAAiBzD,IAAIrB,EAAK8N,GAClC,MAAMC,EAAYD,EAAM/M,IAAI+C,IAAS,IAAIzD,IAGzC,IAAI2N,EAFJF,EAAMzM,IAAIyC,EAAMiK,GAChBA,EAAU3J,IAAImD,GAEd,MAAMjG,EAAOtB,EAAY8D,GAMzB,OALIxC,aAAelD,SACjB4P,EAAYxM,EAAQoD,oBAAoB7D,IAAIO,IAAQ,IAAIjB,IACxD2N,EAAU5J,IAAImD,GACd/F,EAAQoD,oBAAoBvD,IAAIC,EAAK0M,IAEhC,CACLC,YAAa,KACXF,EAAUG,OAAO3G,GACjByG,GAAWE,OAAO3G,IAGxB,CDg0CgDmD,OAAO,GC9zCzC,MAAOyD,EAOnB,WAAA5P,CAAYwF,EAAgC8H,GAAAjN,KAAAiN,YAAAA,EAL5CjN,KAAAkG,iBACE,IAAIsJ,QACNxP,KAAAgG,oBACE,IAAIwJ,QACNxP,KAAAyP,iBAAmE,IAAID,QAErE,MAAME,EAAgBlQ,OAAO8B,OAC3B,CACE+H,OAAO,EACPmB,qBAAqB,EACrBpF,wBAAwB,EACxBvF,QAAS0P,EAAYI,aACrBjK,mBAAoB6J,EAAYK,gBAChCxF,sBAAuB,IAAI/C,KAE7BlC,GAAW,CAAA,GAEbnF,KAAK4C,QFmDH,SAAwBiN,EAAsB1K,GAClD,MAAMiE,EAAgB,IAAIxJ,EAAcuF,EAAQtF,SAC1C+C,EAAU,CACdiN,QAASA,EACTrG,iBAAkB,IAAI/H,IAAIjC,OAAOsQ,OAAO3K,EAAQtF,UAChD6F,mBAAoB,IAAI2B,IAAI,IAAIlC,EAAQO,oBAAoBgF,IAAKlD,GAAM,CAACA,EAAE,GAAG5B,UAAW4B,EAAE,MAC1FrC,UACAuE,YAAa,IAAIhI,EAAM,KAAMyD,EAAQtF,QAASuJ,GAC9CA,iBAGF,OADAxG,EAAQ8C,mBAAmBjD,IAAIjD,OAAOC,eAAe,GAAGsQ,OAAOC,aAAwB,IAAIvO,KACpFmB,CACT,CE/DmBqN,CAAcjQ,KAAM0P,EACrC,CAEA,uBAAWC,GACT,MAAO,CACLO,kBACAC,QAAS,CACPC,MAAOD,QAAQC,MACfC,MAAOF,QAAQE,MACfC,KAAMH,QAAQG,KACdC,IAAKJ,QAAQI,IACbC,MAAOL,QAAQK,MACfC,KAAMN,QAAQM,MAEhBC,kBACAC,YACAC,sBACA3E,kBACA4E,oBACAC,sCACAC,oBACAC,sCACAC,cACAC,kBACArH,gBACAF,cACAmC,cACAlC,cACApK,cACAiE,YACAsM,cACAzM,YACA6N,oBACAC,sBACAvO,8BACAN,wBACAQ,oBACAsO,kBACAC,oBACAC,sBACAC,oCACAC,sBACAC,wBACAC,sBACAC,wBACAC,0BACAC,0BACAzK,QACA5F,QACA+N,gBACA3K,gBACAc,gBACAoM,UACAnH,UACAa,UACAuG,UACA5F,cAEJ,CAEA,0BAAWwD,GACT,MAAMqC,EAAS,CACbrS,EACAsQ,SACArG,QACAF,OACAmC,OACAlC,OACAoI,KACA1O,MACAG,MACA6N,UACAC,WACAC,kBACAC,WACAC,YACAC,WACAC,YACAC,aACAC,aACAzK,IACA5F,IACA+N,QACA3K,QACAc,QACAoK,OACAiC,KACA5F,QAEI1B,EAAM,IAAIrD,IAqBhB,OApBA4K,EAAOnO,QAASoO,IACdxH,EAAIjI,IAAIyP,EAAO,IAAIzQ,OAErBiJ,EAAIjI,IACFjD,OACA,IAAIiC,IAAI,CACN,UACA,cACA,sBACA,KACA,OACA,iBACA,gBACA,uBACA,iBACA,WACA,UACA,YAGGiJ,CACT,CAEA,YAAAyH,CACExJ,EACA/F,GAGA,OADAA,EAAQiB,iBAAiB2B,IAAImD,GACtB,CAAE0G,YAAa,IAAMzM,EAAQiB,iBAAiByL,OAAO3G,GAC9D,CAEA,YAAAsG,CACE7N,EACA8D,EACAyD,EACA/F,GAEA,OAAOqM,EAAa7N,EAAK8D,EAAMyD,EAAU/F,EAC3C,CAEA,kBAAAwP,CACEhR,EACA8D,EACAyD,GAEA,OAAOsG,EAAa7N,EAAK8D,EAAMyD,EAAU3I,KAC3C,CAEA,UAAAqS,CAAWC,GACT,OAAOtS,KAAKyP,iBAAiBtN,IAAImQ,EACnC,CAEA,WAAAhN,CAAe1C,EAAuBgM,EAAmB,IACvD,OAAOtJ,EACL,CACEN,MAAO8G,OAAO,IAEhBlJ,EACAA,EAAQ8E,KACRkH,EAEJ,CAEA,gBAAA/I,CAAoBjD,EAAuBgM,EAAmB,IAC5D,OAAO/I,EACL,CACEb,MAAO8G,OAAO,IAEhBlJ,EACAA,EAAQ8E,KACRkH,EAEJ"}