{"version":3,"file":"SandboxExec.min.js","sources":["../src/utils.ts","../src/executor.ts","../src/SandboxExec.ts"],"sourcesContent":["// Reusable AsyncFunction constructor reference\nexport const AsyncFunction: Function = Object.getPrototypeOf(async function () {}).constructor;\nexport const GeneratorFunction: Function = Object.getPrototypeOf(function* () {}).constructor;\nexport const AsyncGeneratorFunction: Function = Object.getPrototypeOf(\n  async function* () {},\n).constructor;\n\nimport { IEvalContext } from './eval';\nimport { Change, Unknown } from './executor';\nimport { IConstants, IExecutionTree, Lisp, LispItem } from './parser';\nimport SandboxExec from './SandboxExec';\n\nexport type replacementCallback = (obj: any, isStaticAccess: boolean) => any;\n\nexport interface IOptionParams {\n  audit?: boolean;\n  forbidFunctionCalls?: boolean;\n  forbidFunctionCreation?: boolean;\n  prototypeReplacements?: Map<new () => any, replacementCallback>;\n  prototypeWhitelist?: Map<any, Set<string>>;\n  globals?: IGlobals;\n  executionQuota?: bigint;\n  haltOnSandboxError?: boolean;\n}\n\nexport interface IOptions {\n  audit: boolean;\n  forbidFunctionCalls: boolean;\n  forbidFunctionCreation: boolean;\n  prototypeReplacements: Map<Function, replacementCallback>;\n  prototypeWhitelist: Map<any, Set<string>>;\n  globals: IGlobals;\n  executionQuota?: bigint;\n  haltOnSandboxError?: boolean;\n}\n\nexport interface IContext {\n  sandbox: SandboxExec;\n  globalScope: Scope;\n  sandboxGlobal: ISandboxGlobal;\n  globalsWhitelist: Set<any>;\n  prototypeWhitelist: Map<any, Set<PropertyKey>>;\n  sandboxedFunctions: WeakSet<Function>;\n  options: IOptions;\n  auditReport?: IAuditReport;\n  ticks: Ticks;\n}\n\nexport interface IAuditReport {\n  globalsAccess: Set<unknown>;\n  prototypeAccess: { [name: string]: Set<PropertyKey> };\n}\n\nexport interface Ticks {\n  ticks: bigint;\n  tickLimit?: bigint;\n}\n\nexport type SubscriptionSubject = object;\n\nexport interface IExecContext extends IExecutionTree {\n  ctx: IContext;\n  getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>;\n  setSubscriptions: WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>;\n  changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  setSubscriptionsGlobal: WeakMap<\n    SubscriptionSubject,\n    Map<string, Set<(modification: Change) => void>>\n  >;\n  changeSubscriptionsGlobal: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  registerSandboxFunction: (fn: (...args: any[]) => any) => void;\n  evals: Map<any, any>;\n  allowJit: boolean;\n  evalContext?: IEvalContext;\n}\n\nexport interface ISandboxGlobal {\n  [key: string]: unknown;\n}\ninterface SandboxGlobalConstructor {\n  new (globals: IGlobals): ISandboxGlobal;\n}\n\nexport const SandboxGlobal = function SandboxGlobal(this: ISandboxGlobal, globals: IGlobals) {\n  for (const i in globals) {\n    this[i] = globals[i];\n  }\n} as any as SandboxGlobalConstructor;\n\nexport type IGlobals = ISandboxGlobal;\n\nexport class ExecContext implements IExecContext {\n  constructor(\n    public ctx: IContext,\n    public constants: IConstants,\n    public tree: Lisp[],\n    public getSubscriptions: Set<(obj: SubscriptionSubject, name: string) => void>,\n    public setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>,\n    public setSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >,\n    public changeSubscriptionsGlobal: WeakMap<\n      SubscriptionSubject,\n      Set<(modification: Change) => void>\n    >,\n    public evals: Map<any, any>,\n    public registerSandboxFunction: (fn: (...args: any[]) => any) => void,\n    public allowJit: boolean,\n    public evalContext?: IEvalContext,\n  ) {}\n}\n\nexport function createContext(sandbox: SandboxExec, options: IOptions): IContext {\n  const sandboxGlobal = new SandboxGlobal(options.globals);\n  const context: IContext = {\n    sandbox: sandbox,\n    globalsWhitelist: new Set(Object.values(options.globals)),\n    prototypeWhitelist: new Map([...options.prototypeWhitelist].map((a) => [a[0].prototype, a[1]])),\n    options,\n    globalScope: new Scope(null, options.globals, sandboxGlobal),\n    sandboxGlobal,\n    ticks: { ticks: 0n, tickLimit: options.executionQuota },\n    sandboxedFunctions: new WeakSet<Function>(),\n  };\n  context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()) as object, new Set());\n  return context;\n}\n\nexport function createExecContext(\n  sandbox: {\n    readonly setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    readonly changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n    readonly sandboxFunctions: WeakMap<(...args: any[]) => any, IExecContext>;\n    readonly context: IContext;\n  },\n  executionTree: IExecutionTree,\n  evalContext?: IEvalContext,\n): IExecContext {\n  const evals = new Map();\n  const execContext: IExecContext = new ExecContext(\n    sandbox.context,\n    executionTree.constants,\n    executionTree.tree,\n    new Set<(obj: SubscriptionSubject, name: string) => void>(),\n    new WeakMap<SubscriptionSubject, Map<string, Set<(modification: Change) => void>>>(),\n    new WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>(),\n    sandbox.setSubscriptions,\n    sandbox.changeSubscriptions,\n    evals,\n    (fn) => sandbox.sandboxFunctions.set(fn, execContext),\n    !!evalContext,\n    evalContext,\n  );\n  if (evalContext) {\n    const func = evalContext.sandboxFunction(execContext);\n    const asyncFunc = evalContext.sandboxAsyncFunction(execContext);\n    evals.set(Function, func);\n    evals.set(AsyncFunction, asyncFunc);\n    evals.set(GeneratorFunction, func);\n    evals.set(AsyncGeneratorFunction, asyncFunc);\n    evals.set(eval, evalContext.sandboxedEval(func));\n    evals.set(setTimeout, evalContext.sandboxedSetTimeout(func, execContext));\n    evals.set(setInterval, evalContext.sandboxedSetInterval(func, execContext));\n    evals.set(clearTimeout, evalContext.sandboxedClearTimeout(execContext));\n    evals.set(clearInterval, evalContext.sandboxedClearInterval(execContext));\n\n    for (const [key, value] of evals) {\n      sandbox.context.prototypeWhitelist.set(value.prototype, new Set());\n      sandbox.context.prototypeWhitelist.set(key.prototype, new Set());\n    }\n  }\n  return execContext;\n}\n\nexport class CodeString {\n  start: number;\n  end: number;\n  ref: { str: string };\n  constructor(str: string | CodeString) {\n    this.ref = { str: '' };\n    if (str instanceof CodeString) {\n      this.ref = str.ref;\n      this.start = str.start;\n      this.end = str.end;\n    } else {\n      this.ref.str = str;\n      this.start = 0;\n      this.end = str.length;\n    }\n  }\n\n  substring(start: number, end?: number): CodeString {\n    if (!this.length) return this;\n    start = this.start + start;\n    if (start < 0) {\n      start = 0;\n    }\n    if (start > this.end) {\n      start = this.end;\n    }\n    end = end === undefined ? this.end : this.start + end;\n    if (end < 0) {\n      end = 0;\n    }\n    if (end > this.end) {\n      end = this.end;\n    }\n    const code = new CodeString(this);\n    code.start = start;\n    code.end = end;\n    return code;\n  }\n\n  get length() {\n    const len = this.end - this.start;\n    return len < 0 ? 0 : len;\n  }\n\n  char(i: number) {\n    if (this.start === this.end) return undefined;\n    return this.ref.str[this.start + i];\n  }\n\n  toString() {\n    return this.ref.str.substring(this.start, this.end);\n  }\n\n  trimStart() {\n    const found = /^\\s+/.exec(this.toString());\n    const code = new CodeString(this);\n    if (found) {\n      code.start += found[0].length;\n    }\n    return code;\n  }\n\n  slice(start: number, end?: number) {\n    if (start < 0) {\n      start = this.end - this.start + start;\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (end === undefined) {\n      end = this.end - this.start;\n    }\n\n    if (end < 0) {\n      end = this.end - this.start + end;\n    }\n    if (end < 0) {\n      end = 0;\n    }\n    return this.substring(start, end);\n  }\n\n  trim() {\n    const code = this.trimStart();\n    const found = /\\s+$/.exec(code.toString());\n    if (found) {\n      code.end -= found[0].length;\n    }\n    return code;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n}\n\nfunction keysOnly(obj: unknown): Record<string, true> {\n  const ret: Record<string, true> = Object.assign({}, obj);\n  for (const key in ret) {\n    ret[key] = true;\n  }\n  return ret;\n}\n\nexport const reservedWords = new Set([\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'let',\n  'new',\n  'null',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n]);\n\nexport const enum VarType {\n  let = 'let',\n  const = 'const',\n  var = 'var',\n}\n\nexport class Scope {\n  parent: Scope | null;\n  const: { [key: string]: true } = {};\n  let: { [key: string]: true } = {};\n  var: { [key: string]: true } = {};\n  globals: { [key: string]: true };\n  allVars: { [key: string]: unknown } & object;\n  functionThis?: Unknown;\n  constructor(parent: Scope | null, vars = {}, functionThis?: Unknown) {\n    const isFuncScope = functionThis !== undefined || parent === null;\n    this.parent = parent;\n    this.allVars = vars;\n    this.let = isFuncScope ? this.let : keysOnly(vars);\n    this.var = isFuncScope ? keysOnly(vars) : this.var;\n    this.globals = parent === null ? keysOnly(vars) : {};\n    this.functionThis = functionThis;\n  }\n\n  get(key: string): Prop {\n    const isThis = key === 'this';\n    const scope = this.getWhereValScope(key, isThis);\n    if (scope && isThis) {\n      return new Prop({ this: scope.functionThis }, key, false, false, true);\n    }\n    if (!scope) {\n      return new Prop(undefined, key);\n    }\n    return new Prop(scope.allVars, key, key in scope.const, key in scope.globals, true);\n  }\n\n  set(key: string, val: unknown) {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be assigned');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    const prop = this.get(key);\n    if (prop.context === undefined) {\n      throw new ReferenceError(`Variable '${key}' was not declared.`);\n    }\n    if (prop.context === null) {\n      throw new TypeError(`Cannot set properties of null, (setting '${key}')`);\n    }\n    if (prop.isConst) {\n      throw new TypeError(`Cannot assign to const variable '${key}'`);\n    }\n    if (prop.isGlobal) {\n      throw new SandboxError(`Cannot override global variable '${key}'`);\n    }\n    (prop.context as any)[prop.prop] = val;\n    return prop;\n  }\n\n  getWhereValScope(key: string, isThis: boolean): Scope | null {\n    if (isThis) {\n      if (this.functionThis !== undefined) {\n        return this;\n      } else {\n        return this.parent?.getWhereValScope(key, isThis) || null;\n      }\n    }\n    if (key in this.allVars && !(key in {} && !hasOwnProperty(this.allVars, key))) {\n      return this;\n    }\n    return this.parent?.getWhereValScope(key, isThis) || null;\n  }\n\n  getWhereVarScope(key: string, localScope = false): Scope {\n    if (key in this.allVars && !(key in {} && !hasOwnProperty(this.allVars, key))) {\n      return this;\n    }\n    if (this.parent === null || localScope || this.functionThis !== undefined) {\n      return this;\n    }\n    return this.parent.getWhereVarScope(key, localScope);\n  }\n\n  declare(key: string, type: VarType, value: unknown = undefined, isGlobal = false): Prop {\n    if (key === 'this') throw new SyntaxError('\"this\" cannot be declared');\n    if (reservedWords.has(key)) throw new SyntaxError(\"Unexepected token '\" + key + \"'\");\n    const existingScope = this.getWhereVarScope(key, type !== VarType.var);\n    if (type === VarType.var) {\n      if (existingScope.var[key]) {\n        existingScope.allVars[key] = value;\n        if (!isGlobal) {\n          delete existingScope.globals[key];\n        } else {\n          existingScope.globals[key] = true;\n        }\n        return new Prop(existingScope.allVars, key, false, existingScope.globals[key], true);\n      } else if (key in existingScope.allVars) {\n        throw new SyntaxError(`Identifier '${key}' has already been declared`);\n      }\n    }\n    if (key in existingScope.allVars) {\n      throw new SyntaxError(`Identifier '${key}' has already been declared`);\n    }\n\n    if (isGlobal) {\n      existingScope.globals[key] = true;\n    }\n    existingScope[type][key] = true;\n    existingScope.allVars[key] = value;\n\n    return new Prop(this.allVars, key, type === VarType.const, isGlobal, true);\n  }\n}\n\nexport interface IScope {\n  [key: string]: any;\n}\n\nexport class FunctionScope implements IScope {}\n\nexport class LocalScope implements IScope {}\n\nexport class SandboxError extends Error {}\n\nexport class SandboxExecutionQuotaExceededError extends SandboxError {}\n\nexport class SandboxExecutionTreeError extends SandboxError {}\n\nexport class SandboxCapabilityError extends SandboxError {}\n\nexport class SandboxAccessError extends SandboxError {}\n\nexport function isLisp<Type extends Lisp = Lisp>(item: LispItem | LispItem): item is Type {\n  return (\n    Array.isArray(item) &&\n    typeof item[0] === 'number' &&\n    item[0] !== LispType.None &&\n    item[0] !== LispType.True\n  );\n}\n\nexport const enum LispType {\n  None,\n  Prop,\n  StringIndex,\n  Let,\n  Const,\n  Call,\n  KeyVal,\n  Number,\n  Return,\n  Assign,\n  InlineFunction,\n  ArrowFunction,\n  CreateArray,\n  If,\n  IfCase,\n  InlineIf,\n  InlineIfCase,\n  SpreadObject,\n  SpreadArray,\n  ArrayProp,\n  PropOptional,\n  CallOptional,\n  CreateObject,\n  Group,\n  Not,\n  IncrementBefore,\n  IncrementAfter,\n  DecrementBefore,\n  DecrementAfter,\n  And,\n  Or,\n  StrictNotEqual,\n  StrictEqual,\n  Plus,\n  Var,\n  GlobalSymbol,\n  Literal,\n  Function,\n  Loop,\n  Try,\n  Switch,\n  SwitchCase,\n  Block,\n  Expression,\n  Await,\n  New,\n  Throw,\n  Minus,\n  Divide,\n  Power,\n  Multiply,\n  Modulus,\n  Equal,\n  NotEqual,\n  SmallerEqualThan,\n  LargerEqualThan,\n  SmallerThan,\n  LargerThan,\n  Negative,\n  Positive,\n  Typeof,\n  Delete,\n  Instanceof,\n  In,\n  Inverse,\n  SubractEquals,\n  AddEquals,\n  DivideEquals,\n  PowerEquals,\n  MultiplyEquals,\n  ModulusEquals,\n  BitNegateEquals,\n  BitAndEquals,\n  BitOrEquals,\n  UnsignedShiftRightEquals,\n  ShiftRightEquals,\n  ShiftLeftEquals,\n  BitAnd,\n  BitOr,\n  BitNegate,\n  BitShiftLeft,\n  BitShiftRight,\n  BitUnsignedShiftRight,\n  BigInt,\n  LiteralIndex,\n  RegexIndex,\n  LoopAction,\n  Void,\n  True,\n  NullishCoalescing,\n\n  LispEnumSize,\n}\n\nexport class Prop<T = unknown> {\n  constructor(\n    public context: T,\n    public prop: PropertyKey,\n    public isConst = false,\n    public isGlobal = false,\n    public isVariable = false,\n  ) {}\n\n  get<T = unknown>(context: IExecContext): T {\n    const ctx = this.context;\n    if (ctx === undefined) throw new ReferenceError(`${this.prop.toString()} is not defined`);\n    if (ctx === null)\n      throw new TypeError(`Cannot read properties of null, (reading '${this.prop.toString()}')`);\n    context.getSubscriptions.forEach((cb) => cb(ctx, this.prop.toString()));\n    return (ctx as any)[this.prop] as T;\n  }\n}\n\nexport function hasOwnProperty(obj: unknown, prop: PropertyKey): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","import { LispItem, Lisp, IRegEx, SwitchCase } from './parser.js';\nimport {\n  CodeString,\n  hasOwnProperty,\n  IAuditReport,\n  IExecContext,\n  IScope,\n  isLisp,\n  LispType,\n  LocalScope,\n  Prop,\n  SandboxExecutionQuotaExceededError,\n  SandboxError,\n  SandboxExecutionTreeError,\n  Scope,\n  Ticks,\n  VarType,\n  SandboxCapabilityError,\n  SandboxAccessError,\n} from './utils.js';\n\nexport type Done<T = any> = (err?: any, res?: T | typeof optional) => void;\n\nexport class ExecReturn<T> {\n  constructor(\n    public auditReport: IAuditReport | undefined,\n    public result: T,\n    public returned: boolean,\n    public breakLoop = false,\n    public continueLoop = false,\n  ) {}\n}\n\nexport type Unknown = undefined | null | Record<string | number, unknown>;\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: 'create';\n  prop: number | string;\n}\n\nexport interface IReplace extends IChange {\n  type: 'replace';\n}\n\nexport interface IDelete extends IChange {\n  type: 'delete';\n  prop: number | string;\n}\n\nexport interface IReverse extends IChange {\n  type: 'reverse';\n}\n\nexport interface ISort extends IChange {\n  type: 'sort';\n}\n\nexport interface IPush extends IChange {\n  type: 'push';\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: 'pop';\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: 'shift';\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: 'unshift';\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: 'splice';\n  startIndex: number;\n  deleteCount: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport interface ICopyWithin extends IChange {\n  type: 'copyWithin';\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change =\n  | ICreate\n  | IReplace\n  | IDelete\n  | IReverse\n  | ISort\n  | IPush\n  | IPop\n  | IUnShift\n  | IShift\n  | ISplice\n  | ICopyWithin;\n\nconst optional = {};\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: Record<string, unknown> = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nexport function createFunction(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string,\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxCapabilityError('Function creation is forbidden');\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)],\n      );\n      return res.result;\n    };\n  } else {\n    func = function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)],\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  context.ctx.sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string,\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxCapabilityError('Function creation is forbidden');\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxCapabilityError('Async/await not permitted');\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)],\n      );\n      return res.result;\n    };\n  } else {\n    func = async function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)],\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  context.ctx.sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if (obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`);\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Assignment to constant variable.`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxAccessError(\n      `Cannot ${op} property '${obj.prop.toString()}' of a global object`,\n    );\n  }\n  if (obj.context === null) {\n    throw new TypeError('Cannot set properties of null');\n  }\n  if (\n    typeof (obj.context as any)[obj.prop] === 'function' &&\n    !hasOwnProperty(obj.context, obj.prop)\n  ) {\n    throw new SandboxAccessError(\n      `Override prototype property '${obj.prop.toString()}' not allowed`,\n    );\n  }\n  if (op === 'delete') {\n    if (hasOwnProperty(obj.context, obj.prop)) {\n      context.changeSubscriptions\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop.toString() }));\n      context.changeSubscriptionsGlobal\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop.toString() }));\n    }\n  } else if (hasOwnProperty(obj.context, obj.prop)) {\n    context.setSubscriptions\n      .get(obj.context)\n      ?.get(obj.prop.toString())\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        }),\n      );\n    context.setSubscriptionsGlobal\n      .get(obj.context)\n      ?.get(obj.prop.toString())\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        }),\n      );\n  } else {\n    context.changeSubscriptions\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop.toString() }));\n    context.changeSubscriptionsGlobal\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop.toString() }));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin,\n]);\n\nexport class KeyVal {\n  constructor(\n    public key: string | SpreadObject,\n    public val: unknown,\n  ) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: { [key: string]: unknown }) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(\n    public t: Lisp,\n    public f: Lisp,\n  ) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback<a, b, obj, bobj> = (params: OpsCallbackParams<a, b, obj, bobj>) => void;\n\nexport const ops = new Map<LispType, OpCallback<any, any, any, any>>();\nexport function addOps<a = unknown, b = unknown, obj = unknown, bobj = unknown>(\n  type: LispType,\n  cb: OpCallback<a, b, obj, bobj>,\n) {\n  ops.set(type, cb);\n}\n\nfunction isPropertyKey(val: unknown): val is PropertyKey {\n  return ['string', 'number', 'symbol'].includes(typeof val);\n}\n\nfunction hasPossibleProperties(val: unknown): val is {} {\n  return val !== null && val !== undefined;\n}\n\naddOps<unknown, PropertyKey>(LispType.Prop, ({ done, a, b, obj, context, scope }) => {\n  if (a === null) {\n    throw new TypeError(`Cannot read properties of null (reading '${b?.toString()}')`);\n  }\n\n  if (!isPropertyKey(b)) {\n    try {\n      b = `${b}`;\n    } catch (e) {\n      done(e);\n      return;\n    }\n  }\n\n  if (a === undefined && obj === undefined && typeof b === 'string') {\n    // is variable access\n    const prop = scope.get(b);\n    if (prop.context === context.ctx.sandboxGlobal) {\n      if (context.ctx.options.audit) {\n        context.ctx.auditReport?.globalsAccess.add(b);\n      }\n    }\n    const val = prop.context ? (prop.context as any)[prop.prop] : undefined;\n    const p = getGlobalProp(val, context, prop) || prop;\n\n    done(undefined, p);\n    return;\n  } else if (a === undefined) {\n    throw new TypeError(`Cannot read properties of undefined (reading '${b.toString()}')`);\n  }\n\n  if (!hasPossibleProperties(a)) {\n    done(undefined, new Prop(undefined, b));\n    return;\n  }\n\n  const prototypeAccess = typeof a === 'function' || !hasOwnProperty(a, b);\n\n  if (context.ctx.options.audit && prototypeAccess) {\n    let prot: {} = Object.getPrototypeOf(a);\n    do {\n      if (hasOwnProperty(prot, b)) {\n        if (\n          context.ctx.auditReport &&\n          !context.ctx.auditReport.prototypeAccess[prot.constructor.name]\n        ) {\n          context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n        }\n        context.ctx.auditReport?.prototypeAccess[prot.constructor.name].add(b);\n      }\n    } while ((prot = Object.getPrototypeOf(prot)));\n  }\n\n  if (prototypeAccess) {\n    if (typeof a === 'function') {\n      if (hasOwnProperty(a, b)) {\n        const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n        const replace = context.ctx.options.prototypeReplacements.get(a);\n        if (replace) {\n          done(undefined, new Prop(replace(a, true), b));\n          return;\n        }\n        if (\n          !(whitelist && (!whitelist.size || whitelist.has(b))) &&\n          !context.ctx.sandboxedFunctions.has(a)\n        ) {\n          throw new SandboxAccessError(\n            `Static method or property access not permitted: ${a.name}.${b.toString()}`,\n          );\n        }\n      }\n    }\n\n    let prot: {} = a;\n    while ((prot = Object.getPrototypeOf(prot))) {\n      if (hasOwnProperty(prot, b) || b === '__proto__') {\n        const whitelist = context.ctx.prototypeWhitelist.get(prot);\n        const replace = context.ctx.options.prototypeReplacements.get(prot.constructor);\n        if (replace) {\n          done(undefined, new Prop(replace(a, false), b));\n          return;\n        }\n        if (\n          (whitelist && (!whitelist.size || whitelist.has(b))) ||\n          context.ctx.sandboxedFunctions.has(prot.constructor)\n        ) {\n          break;\n        }\n        if (b === '__proto__') {\n          throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n        }\n        throw new SandboxAccessError(\n          `Method or property access not permitted: ${prot.constructor.name}.${b.toString()}`,\n        );\n      }\n    }\n  }\n\n  const val = a[b as keyof typeof a] as unknown;\n  if (typeof a === 'function') {\n    if (b === 'prototype' && !context.ctx.sandboxedFunctions.has(a)) {\n      throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n    }\n  }\n\n  if (b === '__proto__' && !context.ctx.sandboxedFunctions.has(val?.constructor as any)) {\n    throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n  }\n\n  const p = getGlobalProp(val, context);\n  if (p) {\n    done(undefined, p);\n    return;\n  }\n\n  const g =\n    (obj instanceof Prop && obj.isGlobal) ||\n    (typeof a === 'function' && !context.ctx.sandboxedFunctions.has(a)) ||\n    context.ctx.globalsWhitelist.has(a);\n\n  done(undefined, new Prop(a, b, false, g, false));\n});\n\nfunction getGlobalProp(val: unknown, context: IExecContext, prop?: Prop) {\n  if (!val) return;\n  const isFunc = typeof val === 'function';\n  if (val instanceof Prop) {\n    if (!prop) {\n      prop = val;\n    }\n    val = val.get(context);\n  }\n  const p = prop?.prop || 'prop';\n  if (val === globalThis) {\n    return new Prop(\n      {\n        [p]: context.ctx.sandboxGlobal,\n      },\n      p,\n      prop?.isConst || false,\n      false,\n      prop?.isVariable || false,\n    );\n  }\n  const e = isFunc && context.evals.get(val);\n  if (e) {\n    return new Prop(\n      {\n        [p]: e,\n      },\n      p,\n      prop?.isConst || false,\n      true,\n      prop?.isVariable || false,\n    );\n  }\n}\n\naddOps<unknown, Lisp[], any>(LispType.Call, ({ done, a, b, obj, context }) => {\n  if (context.ctx.options.forbidFunctionCalls)\n    throw new SandboxCapabilityError('Function invocations are not allowed');\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    let ret = obj(...vals);\n    if (ret instanceof Promise) {\n      ret = checkHaltAsync(context, ret);\n    } else {\n      ret = getGlobalProp(ret, context) || ret;\n    }\n    done(undefined, ret);\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (const y of Object.keys(x) as (keyof typeof x)[]) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (\n    obj.context instanceof Array &&\n    arrayChange.has(obj.context[obj.prop]) &&\n    (context.changeSubscriptions.get(obj.context) ||\n      context.changeSubscriptionsGlobal.get(obj.context))\n  ) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === 'push') {\n      change = {\n        type: 'push',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'pop') {\n      change = {\n        type: 'pop',\n        removed: obj.context.slice(-1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'shift') {\n      change = {\n        type: 'shift',\n        removed: obj.context.slice(0, 1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'unshift') {\n      change = {\n        type: 'unshift',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'splice') {\n      change = {\n        type: 'splice',\n        startIndex: vals[0] as number,\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(\n          vals[0],\n          vals[1] === undefined ? undefined : (vals[0] as number) + (vals[1] as number),\n        ),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === 'reverse' || obj.prop === 'sort') {\n      change = { type: obj.prop };\n      changed = !!obj.context.length;\n    } else if (obj.prop === 'copyWithin') {\n      const len =\n        vals[2] === undefined\n          ? obj.context.length - (vals[1] as number)\n          : Math.min(obj.context.length, (vals[2] as number) - (vals[1] as number));\n      change = {\n        type: 'copyWithin',\n        startIndex: vals[0] as number,\n        endIndex: (vals[0] as number) + len,\n        added: obj.context.slice(vals[1] as number, (vals[1] as number) + len),\n        removed: obj.context.slice(vals[0] as number, (vals[0] as number) + len),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  let ret = obj.context[obj.prop](...vals) as unknown;\n  if (ret instanceof Promise) {\n    ret = checkHaltAsync(context, ret);\n  } else {\n    ret = getGlobalProp(ret, context) || ret;\n  }\n  done(undefined, ret);\n});\n\naddOps<unknown, KeyVal[]>(LispType.CreateObject, ({ done, b }) => {\n  let res = {} as any;\n  for (const item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = { ...res, ...item.key.item };\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps<string, LispItem>(LispType.KeyVal, ({ done, a, b }) => done(undefined, new KeyVal(a, b)));\n\naddOps<unknown, Lisp[]>(LispType.CreateArray, ({ done, b, context }) => {\n  const items = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n  done(undefined, items);\n});\n\naddOps<unknown, unknown>(LispType.Group, ({ done, b }) => done(undefined, b));\n\naddOps<unknown, string>(LispType.GlobalSymbol, ({ done, b }) => {\n  switch (b) {\n    case 'true':\n      return done(undefined, true);\n    case 'false':\n      return done(undefined, false);\n    case 'null':\n      return done(undefined, null);\n    case 'undefined':\n      return done(undefined, undefined);\n    case 'NaN':\n      return done(undefined, NaN);\n    case 'Infinity':\n      return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b));\n});\n\naddOps<unknown, string>(LispType.Number, ({ done, b }) =>\n  done(undefined, Number(b.replace(/_/g, ''))),\n);\naddOps<unknown, string>(LispType.BigInt, ({ done, b }) =>\n  done(undefined, BigInt(b.replace(/_/g, ''))),\n);\naddOps<unknown, string>(LispType.StringIndex, ({ done, b, context }) =>\n  done(undefined, context.constants.strings[parseInt(b)]),\n);\n\naddOps<unknown, string>(LispType.RegexIndex, ({ done, b, context }) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxCapabilityError('Regex not permitted');\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps<unknown, string>(LispType.LiteralIndex, ({ exec, done, ticks, b, context, scope }) => {\n  const item = context.constants.literals[parseInt(b)];\n  const [, name, js] = item;\n  const found: Lisp[] = [];\n  let f: RegExpExecArray | null;\n  const resnums: string[] = [];\n  while ((f = literalRegex.exec(name))) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec<unknown[]>(ticks, found, scope, context, (err, processed) => {\n    const reses: Record<string, unknown> = {};\n    if (err) {\n      done(err);\n      return;\n    }\n    for (const i of Object.keys(processed!) as (keyof typeof processed)[]) {\n      const num = resnums[i];\n      reses[num] = processed![i];\n    }\n    done(\n      undefined,\n      name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        const res = reses[num];\n        return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n      }),\n    );\n  });\n});\n\naddOps<unknown, unknown[]>(LispType.SpreadArray, ({ done, b }) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps<unknown, Record<string, unknown>>(LispType.SpreadObject, ({ done, b }) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps<unknown, unknown>(LispType.Not, ({ done, b }) => done(undefined, !b));\naddOps<unknown, number>(LispType.Inverse, ({ done, b }) => done(undefined, ~b));\n\naddOps<unknown, unknown, Prop<any>>(LispType.IncrementBefore, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.IncrementAfter, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.DecrementBefore, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.DecrementAfter, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps<unknown, unknown, Prop<any>, Prop<any>>(\n  LispType.Assign,\n  ({ done, b, obj, context, scope, bobj }) => {\n    assignCheck(obj, context);\n    obj.isGlobal = bobj?.isGlobal || false;\n    if (obj.isVariable) {\n      const s = scope.getWhereValScope(obj.prop as string, obj.prop === 'this');\n      if (s === null) {\n        throw new ReferenceError(`Cannot assign to undeclared variable '${obj.prop.toString()}'`);\n      }\n      s.set(obj.prop as string, b);\n      if (obj.isGlobal) {\n        s.globals[obj.prop.toString()] = true;\n      } else {\n        delete s.globals[obj.prop.toString()];\n      }\n      done(undefined, b);\n      return;\n    }\n    done(undefined, (obj.context[obj.prop] = b));\n  },\n);\n\naddOps<unknown, unknown, Prop<any>>(LispType.AddEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] += b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.SubractEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] -= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.DivideEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] /= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.MultiplyEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] *= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.PowerEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] **= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ModulusEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] %= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitNegateEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] ^= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitAndEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] &= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitOrEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] |= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ShiftLeftEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] <<= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ShiftRightEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] >>= b));\n});\n\naddOps<unknown, number, Prop<any>>(\n  LispType.UnsignedShiftRightEquals,\n  ({ done, b, obj, context }) => {\n    assignCheck(obj, context);\n    done(undefined, (obj.context[obj.prop] >>>= b));\n  },\n);\n\naddOps<number, number>(LispType.LargerThan, ({ done, a, b }) => done(undefined, a > b));\naddOps<number, number>(LispType.SmallerThan, ({ done, a, b }) => done(undefined, a < b));\naddOps<number, number>(LispType.LargerEqualThan, ({ done, a, b }) => done(undefined, a >= b));\naddOps<number, number>(LispType.SmallerEqualThan, ({ done, a, b }) => done(undefined, a <= b));\naddOps<number, number>(LispType.Equal, ({ done, a, b }) => done(undefined, a == b));\naddOps<number, number>(LispType.StrictEqual, ({ done, a, b }) => done(undefined, a === b));\naddOps<number, number>(LispType.NotEqual, ({ done, a, b }) => done(undefined, a != b));\naddOps<number, number>(LispType.StrictNotEqual, ({ done, a, b }) => done(undefined, a !== b));\naddOps<number, number>(LispType.And, ({ done, a, b }) => done(undefined, a && b));\naddOps<number, number>(LispType.Or, ({ done, a, b }) => done(undefined, a || b));\naddOps<number, number>(LispType.NullishCoalescing, ({ done, a, b }) => done(undefined, a ?? b));\naddOps<number, number>(LispType.BitAnd, ({ done, a, b }) => done(undefined, a & b));\naddOps<number, number>(LispType.BitOr, ({ done, a, b }) => done(undefined, a | b));\naddOps<number, number>(LispType.Plus, ({ done, a, b }) => done(undefined, a + b));\naddOps<number, number>(LispType.Minus, ({ done, a, b }) => done(undefined, a - b));\naddOps<number, number>(LispType.Positive, ({ done, b }) => done(undefined, +b));\naddOps<number, number>(LispType.Negative, ({ done, b }) => done(undefined, -b));\naddOps<number, number>(LispType.Divide, ({ done, a, b }) => done(undefined, a / b));\naddOps<number, number>(LispType.Power, ({ done, a, b }) => done(undefined, a ** b));\naddOps<number, number>(LispType.BitNegate, ({ done, a, b }) => done(undefined, a ^ b));\naddOps<number, number>(LispType.Multiply, ({ done, a, b }) => done(undefined, a * b));\naddOps<number, number>(LispType.Modulus, ({ done, a, b }) => done(undefined, a % b));\naddOps<number, number>(LispType.BitShiftLeft, ({ done, a, b }) => done(undefined, a << b));\naddOps<number, number>(LispType.BitShiftRight, ({ done, a, b }) => done(undefined, a >> b));\naddOps<number, number>(LispType.BitUnsignedShiftRight, ({ done, a, b }) =>\n  done(undefined, a >>> b),\n);\naddOps<unknown, LispItem>(LispType.Typeof, ({ exec, done, ticks, b, context, scope }) => {\n  exec(ticks, b, scope, context, (e, prop) => {\n    done(undefined, typeof valueOrProp(prop, context));\n  });\n});\n\naddOps<unknown, { new (): unknown }>(LispType.Instanceof, ({ done, a, b }) =>\n  done(undefined, a instanceof b),\n);\naddOps<string, {}>(LispType.In, ({ done, a, b }) => done(undefined, a in b));\n\naddOps<unknown, unknown>(LispType.Delete, ({ done, context, bobj }) => {\n  if (!(bobj instanceof Prop)) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete (bobj.context as any)?.[bobj.prop]);\n});\n\naddOps(LispType.Return, ({ done, b }) => done(undefined, b));\n\naddOps<string, unknown, unknown, Prop>(LispType.Var, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.var, b, bobj?.isGlobal || false));\n});\n\naddOps<string, unknown, unknown, Prop>(LispType.Let, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj?.isGlobal || false));\n});\n\naddOps<string, unknown, unknown, Prop>(LispType.Const, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.const, b, bobj?.isGlobal || false));\n});\n\naddOps<string[], Lisp[], Lisp>(\n  LispType.ArrowFunction,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    a = [...a];\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  },\n);\n\naddOps<(string | LispType)[], Lisp[], Lisp>(\n  LispType.Function,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n);\n\naddOps<(string | LispType)[], Lisp[], Lisp>(\n  LispType.InlineFunction,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    if (name) {\n      scope = new Scope(scope, {});\n    }\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n);\n\naddOps<Lisp[], Lisp[]>(LispType.Loop, ({ exec, done, ticks, a, b, context, scope }) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  const internalVars = {\n    $$obj: undefined,\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async () => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] =\n        (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst)\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      while (loop) {\n        const innerLoopVars = {};\n        ad = asyncDone((d) =>\n          exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d),\n        );\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        const res = await executeTreeAsync(\n          ticks,\n          context,\n          b,\n          [new Scope(loopScope, innerLoopVars)],\n          'loop',\n        );\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    while (loop) {\n      const innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      const res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], 'loop');\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    }\n    done();\n  }\n});\n\naddOps<LispItem, LispItem>(LispType.LoopAction, ({ done, a, context, inLoopOrSwitch }) => {\n  if ((inLoopOrSwitch === 'switch' && a === 'continue') || !inLoopOrSwitch) {\n    throw new TypeError('Illegal ' + a + ' statement');\n  }\n  done(\n    undefined,\n    new ExecReturn(context.ctx.auditReport, undefined, false, a === 'break', a === 'continue'),\n  );\n});\n\naddOps<LispItem, If>(LispType.If, ({ exec, done, ticks, a, b, context, scope, inLoopOrSwitch }) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done, inLoopOrSwitch);\n});\n\naddOps<LispItem, If>(LispType.InlineIf, ({ exec, done, ticks, a, b, context, scope }) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done, undefined);\n});\n\naddOps<Lisp, Lisp>(LispType.InlineIfCase, ({ done, a, b }) => done(undefined, new If(a, b)));\naddOps<Lisp, Lisp>(LispType.IfCase, ({ done, a, b }) => done(undefined, new If(a, b)));\n\naddOps<LispItem, SwitchCase[]>(LispType.Switch, ({ exec, done, ticks, a, b, context, scope }) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (const caseItem of b) {\n        if (\n          isTrue ||\n          (isTrue =\n            !caseItem[1] ||\n            toTest ===\n              valueOrProp(\n                syncDone((d) => exec(ticks, caseItem[1], scope, context, d)).result,\n                context,\n              ))\n        ) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], 'switch');\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) {\n            // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (const caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (\n            isTrue ||\n            (isTrue =\n              !caseItem[1] ||\n              toTest ===\n                valueOrProp(\n                  (ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant ===\n                    true\n                    ? ad.instant\n                    : (await ad.p).result,\n                  context,\n                ))\n          ) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], 'switch');\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) {\n              // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done);\n    }\n  });\n});\n\naddOps<Lisp[], [string, Lisp[], Lisp[]]>(\n  LispType.Try,\n  ({ exec, done, ticks, a, b, context, scope, inLoopOrSwitch }) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(\n      exec,\n      (err, res) => {\n        executeTreeWithDone(\n          exec,\n          (e) => {\n            if (e) done(e);\n            else if (err) {\n              const sc: Record<string, unknown> = {};\n              if (exception) sc[exception] = err;\n              executeTreeWithDone(\n                exec,\n                done,\n                ticks,\n                context,\n                catchBody,\n                [new Scope(scope)],\n                inLoopOrSwitch,\n              );\n            } else {\n              done(undefined, res);\n            }\n          },\n          ticks,\n          context,\n          finallyBody,\n          [new Scope(scope, {})],\n        );\n      },\n      ticks,\n      context,\n      a,\n      [new Scope(scope)],\n      inLoopOrSwitch,\n    );\n  },\n);\n\naddOps(LispType.Void, ({ done }) => {\n  done();\n});\naddOps<new (...args: unknown[]) => unknown, unknown[]>(LispType.New, ({ done, a, b, context }) => {\n  if (!context.ctx.globalsWhitelist.has(a) && !context.ctx.sandboxedFunctions.has(a)) {\n    throw new SandboxAccessError(`Object construction not allowed: ${a.constructor.name}`);\n  }\n  done(undefined, new a(...b));\n});\n\naddOps(LispType.Throw, ({ done, b }) => {\n  done(b);\n});\naddOps<unknown[]>(LispType.Expression, ({ done, a }) => done(undefined, a.pop()));\naddOps(LispType.None, ({ done }) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): unknown {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(\n  ticks: Ticks,\n  exec: Execution,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res =\n        (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = <T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string,\n) => void;\n\nexport interface AsyncDoneRet {\n  isInstant: boolean;\n  instant: any;\n  p: Promise<{ result: any }>;\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({ result });\n      }\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p,\n  };\n}\n\nexport function syncDone(callback: (done: Done) => void): { result: any } {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return { result };\n}\n\nexport async function execAsync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  doneOriginal: Done<T>,\n  inLoopOrSwitch?: string,\n): Promise<void> {\n  let done: Done<T> = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    };\n  });\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    // Short-circuit for nullish coalescing: if a is not null/undefined, return a without evaluating b\n    if (op === LispType.NullishCoalescing && a !== undefined && a !== null) {\n      done(undefined, a);\n      return;\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    performOp({\n      op,\n      exec: execAsync,\n      done,\n      ticks,\n      a,\n      b,\n      obj,\n      context,\n      scope,\n      bobj,\n      inLoopOrSwitch,\n      tree,\n    });\n  }\n  await p;\n}\n\nexport function execSync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string,\n) {\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    // Short-circuit for nullish coalescing: if a is not null/undefined, return a without evaluating b\n    if (op === LispType.NullishCoalescing && a !== undefined && a !== null) {\n      done(undefined, a);\n      return;\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    performOp({\n      op,\n      exec: execSync,\n      done,\n      ticks,\n      a,\n      b,\n      obj,\n      context,\n      scope,\n      bobj,\n      inLoopOrSwitch,\n      tree,\n    });\n  }\n}\n\nfunction checkHaltAsync<T>(context: IExecContext, promise: Promise<T>): Promise<T> {\n  let done = false;\n  let halted = context.ctx.sandbox.halted;\n  let doResolve = () => {};\n  let subres: { unsubscribe: () => void };\n  let subhalt: { unsubscribe: () => void };\n  const interupted = new Promise<void>((resolve) => {\n    doResolve = () => {\n      subhalt.unsubscribe();\n      subres.unsubscribe();\n      resolve();\n    };\n    subhalt = context.ctx.sandbox.subscribeHalt(() => {\n      halted = true;\n    });\n\n    subres = context.ctx.sandbox.subscribeResume(() => {\n      halted = false;\n      if (done) doResolve();\n    });\n  });\n  promise\n    .finally(() => {\n      done = true;\n      if (!halted) {\n        doResolve();\n      }\n    })\n    .catch(() => {});\n  return Promise.allSettled([promise, interupted]).then(() => {\n    return promise;\n  });\n}\n\ntype OpsCallbackParams<a, b, obj, bobj> = {\n  op: LispType;\n  exec: Execution;\n  a: a;\n  b: b;\n  obj: obj;\n  bobj: bobj;\n  ticks: Ticks;\n  tree: LispItem;\n  scope: Scope;\n  context: IExecContext;\n  done: Done;\n  inLoopOrSwitch?: string;\n};\n\nfunction checkHaltExpectedTicks(\n  params: OpsCallbackParams<any, any, any, any>,\n  expectTicks = 0,\n): boolean {\n  const sandbox = params.context.ctx.sandbox;\n  const options = params.context.ctx.options;\n  const { ticks, scope, context, done, op } = params;\n  if (sandbox.halted) {\n    const sub = sandbox.subscribeResume(() => {\n      sub.unsubscribe();\n      try {\n        const o = ops.get(op);\n        if (!o) {\n          done(new SyntaxError('Unknown operator: ' + op));\n          return;\n        }\n        o(params);\n      } catch (err) {\n        if (options.haltOnSandboxError && err instanceof SandboxError) {\n          const sub = sandbox.subscribeResume(() => {\n            sub.unsubscribe();\n            done(err);\n          });\n          sandbox.haltExecution({\n            error: err as Error,\n            ticks,\n            scope,\n            context,\n          });\n        } else {\n          done(err);\n        }\n      }\n    });\n    return true;\n  } else if (ticks.tickLimit && ticks.tickLimit <= ticks.ticks + BigInt(expectTicks)) {\n    const sub = sandbox.subscribeResume(() => {\n      sub.unsubscribe();\n      try {\n        const o = ops.get(op);\n        if (!o) {\n          done(new SyntaxError('Unknown operator: ' + op));\n          return;\n        }\n        o(params);\n      } catch (err) {\n        if (context.ctx.options.haltOnSandboxError && err instanceof SandboxError) {\n          const sub = sandbox.subscribeResume(() => {\n            sub.unsubscribe();\n            done(err);\n          });\n          sandbox.haltExecution({\n            error: err as Error,\n            ticks,\n            scope,\n            context,\n          });\n        } else {\n          done(err);\n        }\n      }\n    });\n    const error = new SandboxExecutionQuotaExceededError('Execution quota exceeded');\n    sandbox.haltExecution({\n      error,\n      ticks,\n      scope: scope,\n      context,\n    });\n    return true;\n  }\n  return false;\n}\n\nfunction performOp(params: OpsCallbackParams<any, any, any, any>) {\n  const { done, op, ticks, context, scope } = params;\n  ticks.ticks++;\n  const sandbox = context.ctx.sandbox;\n\n  if (checkHaltExpectedTicks(params)) {\n    return;\n  }\n\n  try {\n    const o = ops.get(op);\n    if (!o) {\n      done(new SandboxExecutionTreeError('Unknown operator: ' + op));\n      return;\n    }\n    o(params);\n  } catch (err) {\n    if (context.ctx.options.haltOnSandboxError && err instanceof SandboxError) {\n      const sub = sandbox.subscribeResume(() => {\n        sub.unsubscribe();\n        done(err);\n      });\n      sandbox.haltExecution({\n        error: err as Error,\n        ticks,\n        scope,\n        context,\n      });\n    } else {\n      done(err);\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof,\n]);\n\nexport const currentTicks = { current: { ticks: BigInt(0) } as Ticks };\n\nfunction _execNoneRecurse<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  isAsync: boolean,\n  inLoopOrSwitch?: string,\n): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  currentTicks.current = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SyntaxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(\n        ticks,\n        tree[1],\n        scope,\n        context,\n        async (e, r) => {\n          if (e) done(e);\n          else\n            try {\n              done(undefined, (await valueOrProp(r, context)) as any);\n            } catch (err) {\n              done(err);\n            }\n        },\n        inLoopOrSwitch,\n      ).catch(done);\n    } else {\n      done(new SandboxCapabilityError('Async/await is not permitted'));\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    performOp({\n      op: tree[0],\n      exec,\n      done,\n      ticks,\n      a: tree[1],\n      b: tree[2],\n      obj: tree,\n      tree,\n      context,\n      scope,\n      bobj: undefined,\n      inLoopOrSwitch,\n    });\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n): ExecReturn<T> {\n  return syncDone((done) =>\n    executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch),\n  ).result;\n}\n\nexport async function executeTreeAsync<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) =>\n    executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch),\n  )).isInstant === true\n    ? ad.instant\n    : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(\n  exec: Execution,\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n) {\n  if (!executionTree) {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while ((s = scopes.shift())) {\n    if (typeof s !== 'object') continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    };\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string,\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      execSync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch,\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string,\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      await execAsync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch,\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n","import { IEvalContext } from './eval.js';\nimport { Change, ExecReturn, executeTree, executeTreeAsync } from './executor.js';\nimport {\n  createContext,\n  IContext,\n  IExecContext,\n  IGlobals,\n  IOptionParams,\n  IOptions,\n  IScope,\n  replacementCallback,\n  SandboxExecutionQuotaExceededError,\n  SandboxGlobal,\n  Scope,\n  SubscriptionSubject,\n  Ticks,\n} from './utils.js';\n\nexport {\n  IOptions,\n  IContext,\n  IExecContext,\n  LocalScope,\n  SandboxExecutionTreeError,\n  SandboxCapabilityError,\n  SandboxAccessError,\n  SandboxError,\n} from './utils.js';\n\nfunction subscribeSet(\n  obj: object,\n  name: string,\n  callback: (modification: Change) => void,\n  context: {\n    setSubscriptions: WeakMap<\n      SubscriptionSubject,\n      Map<string, Set<(modification: Change) => void>>\n    >;\n    changeSubscriptions: WeakMap<SubscriptionSubject, Set<(modification: Change) => void>>;\n  },\n): { unsubscribe: () => void } {\n  const names =\n    context.setSubscriptions.get(obj) || new Map<string, Set<(modification: Change) => void>>();\n  context.setSubscriptions.set(obj, names);\n  const callbacks = names.get(name) || new Set();\n  names.set(name, callbacks);\n  callbacks.add(callback);\n  let changeCbs: Set<(modification: Change) => void>;\n  const val = (obj as any)[name] as unknown;\n  if (val instanceof Object) {\n    changeCbs = context.changeSubscriptions.get(val) || new Set();\n    changeCbs.add(callback);\n    context.changeSubscriptions.set(val, changeCbs);\n  }\n  return {\n    unsubscribe: () => {\n      callbacks.delete(callback);\n      changeCbs?.delete(callback);\n    },\n  };\n}\n\nexport default class SandboxExec {\n  public readonly context: IContext;\n  public readonly setSubscriptions: WeakMap<\n    SubscriptionSubject,\n    Map<string, Set<(modification: Change) => void>>\n  > = new WeakMap();\n  public readonly changeSubscriptions: WeakMap<\n    SubscriptionSubject,\n    Set<(modification: Change) => void>\n  > = new WeakMap();\n  public readonly sandboxFunctions: WeakMap<Function, IExecContext> = new WeakMap();\n  private haltSubscriptions: Set<\n    (args?: { error: Error; ticks: Ticks; scope: Scope; context: IExecContext }) => void\n  > = new Set();\n  private resumeSubscriptions: Set<() => void> = new Set();\n  public halted = false;\n  timeoutHandleCounter = 0;\n  public readonly setTimeoutHandles = new Map<number, {\n    handle: number,\n    haltsub: { unsubscribe: () => void },\n    contsub: { unsubscribe: () => void },\n  }>();\n  public readonly setIntervalHandles = new Map<\n    number,\n    {\n      handle: number;\n      haltsub: { unsubscribe: () => void };\n      contsub: { unsubscribe: () => void };\n    }\n  >();\n  constructor(\n    options?: IOptionParams,\n    public evalContext?: IEvalContext,\n  ) {\n    const opt: IOptions = Object.assign(\n      {\n        audit: false,\n        forbidFunctionCalls: false,\n        forbidFunctionCreation: false,\n        globals: SandboxExec.SAFE_GLOBALS,\n        prototypeWhitelist: SandboxExec.SAFE_PROTOTYPES,\n        prototypeReplacements: new Map<new () => any, replacementCallback>(),\n      },\n      options || {},\n    );\n    this.context = createContext(this, opt);\n  }\n\n  static get SAFE_GLOBALS(): IGlobals {\n    return {\n      globalThis,\n      Function,\n      eval,\n      console: {\n        debug: console.debug,\n        error: console.error,\n        info: console.info,\n        log: console.log,\n        table: console.table,\n        warn: console.warn,\n      },\n      isFinite,\n      isNaN,\n      parseFloat,\n      parseInt,\n      decodeURI,\n      decodeURIComponent,\n      encodeURI,\n      encodeURIComponent,\n      escape,\n      unescape,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Object,\n      Array,\n      Symbol,\n      Error,\n      EvalError,\n      RangeError,\n      ReferenceError,\n      SyntaxError,\n      TypeError,\n      URIError,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Intl,\n      JSON,\n      Math,\n      Date,\n      RegExp,\n    };\n  }\n\n  static get SAFE_PROTOTYPES(): Map<any, Set<string>> {\n    const protos = [\n      SandboxGlobal,\n      Function,\n      Boolean,\n      Number,\n      BigInt,\n      String,\n      Date,\n      Error,\n      Array,\n      Int8Array,\n      Uint8Array,\n      Uint8ClampedArray,\n      Int16Array,\n      Uint16Array,\n      Int32Array,\n      Uint32Array,\n      Float32Array,\n      Float64Array,\n      Map,\n      Set,\n      WeakMap,\n      WeakSet,\n      Promise,\n      Symbol,\n      Date,\n      RegExp,\n    ];\n    const map = new Map<any, Set<string>>();\n    protos.forEach((proto) => {\n      map.set(proto, new Set());\n    });\n    map.set(\n      Object,\n      new Set([\n        'constructor',\n        'name',\n        'entries',\n        'fromEntries',\n        'getOwnPropertyNames',\n        'is',\n        'keys',\n        'hasOwnProperty',\n        'isPrototypeOf',\n        'propertyIsEnumerable',\n        'toLocaleString',\n        'toString',\n        'valueOf',\n        'values',\n      ]),\n    );\n    return map;\n  }\n\n  subscribeGet(\n    callback: (obj: SubscriptionSubject, name: string) => void,\n    context: IExecContext,\n  ): { unsubscribe: () => void } {\n    context.getSubscriptions.add(callback);\n    return { unsubscribe: () => context.getSubscriptions.delete(callback) };\n  }\n\n  subscribeSet(\n    obj: object,\n    name: string,\n    callback: (modification: Change) => void,\n    context: SandboxExec | IExecContext,\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, context);\n  }\n\n  subscribeSetGlobal(\n    obj: SubscriptionSubject,\n    name: string,\n    callback: (modification: Change) => void,\n  ): { unsubscribe: () => void } {\n    return subscribeSet(obj, name, callback, this);\n  }\n\n  subscribeHalt(\n    cb: (args?: { error: Error; ticks: Ticks; scope: Scope; context: IExecContext }) => void,\n  ) {\n    this.haltSubscriptions.add(cb);\n    return {\n      unsubscribe: () => {\n        this.haltSubscriptions.delete(cb);\n      },\n    };\n  }\n  subscribeResume(cb: () => void) {\n    this.resumeSubscriptions.add(cb);\n    return {\n      unsubscribe: () => {\n        this.resumeSubscriptions.delete(cb);\n      },\n    };\n  }\n\n  haltExecution(haltContext?: { error: Error; ticks: Ticks; scope: Scope; context: IExecContext }) {\n    if (this.halted) return;\n    this.halted = true;\n    for (const cb of this.haltSubscriptions) {\n      cb(haltContext);\n    }\n  }\n\n  resumeExecution() {\n    if (!this.halted) return;\n    if (this.context.ticks.tickLimit && this.context.ticks.ticks >= this.context.ticks.tickLimit) {\n      throw new SandboxExecutionQuotaExceededError('Cannot resume execution: tick limit exceeded');\n    }\n    this.halted = false;\n    for (const cb of this.resumeSubscriptions) {\n      cb();\n    }\n  }\n\n  getContext(fn: (...args: any[]) => any) {\n    return this.sandboxFunctions.get(fn);\n  }\n\n  executeTree<T>(context: IExecContext, scopes: IScope[] = []): ExecReturn<T> {\n    return executeTree(context.ctx.ticks, context, context.tree, scopes);\n  }\n\n  executeTreeAsync<T>(context: IExecContext, scopes: IScope[] = []): Promise<ExecReturn<T>> {\n    return executeTreeAsync(context.ctx.ticks, context, context.tree, scopes);\n  }\n}\n"],"names":["Object","getPrototypeOf","async","constructor","SandboxGlobal","globals","i","this","CodeString","str","ref","start","end","length","substring","undefined","code","len","char","toString","trimStart","found","exec","slice","trim","valueOf","keysOnly","obj","ret","assign","key","reservedWords","Set","Scope","parent","vars","functionThis","const","let","var","isFuncScope","allVars","get","isThis","scope","getWhereValScope","Prop","set","val","SyntaxError","has","prop","context","ReferenceError","TypeError","isConst","isGlobal","SandboxError","hasOwnProperty","getWhereVarScope","localScope","declare","type","value","existingScope","LocalScope","Error","SandboxExecutionQuotaExceededError","SandboxExecutionTreeError","SandboxCapabilityError","SandboxAccessError","isLisp","item","Array","isArray","isVariable","ctx","getSubscriptions","forEach","cb","prototype","call","ExecReturn","auditReport","result","returned","breakLoop","continueLoop","optional","generateArgs","argNames","args","arg","startsWith","createFunction","parsed","ticks","name","options","forbidFunctionCreation","func","executeTree","registerSandboxFunction","sandboxedFunctions","add","createFunctionAsync","prototypeWhitelist","Promise","executeTreeAsync","assignCheck","op","changeSubscriptions","changeSubscriptionsGlobal","setSubscriptions","setSubscriptionsGlobal","arrayChange","push","pop","shift","unshift","splice","reverse","sort","copyWithin","KeyVal","SpreadObject","SpreadArray","If","t","f","literalRegex","ops","Map","addOps","getGlobalProp","isFunc","p","globalThis","sandboxGlobal","e","evals","valueOrProp","a","execMany","tree","done","inLoopOrSwitch","execSync","res","syncDone","d","_execManySync","ad","asyncDone","execAsync","isInstant","instant","_execManyAsync","catch","callback","resolve","reject","err","r","doneOriginal","_execNoneRecurse","bobj","b","performOp","checkHaltAsync","promise","subres","subhalt","halted","sandbox","doResolve","interupted","unsubscribe","subscribeHalt","subscribeResume","finally","allSettled","then","params","expectTicks","sub","o","haltOnSandboxError","haltExecution","error","tickLimit","BigInt","checkHaltExpectedTicks","includes","isPropertyKey","audit","globalsAccess","hasPossibleProperties","prototypeAccess","prot","whitelist","replace","prototypeReplacements","size","g","globalsWhitelist","forbidFunctionCalls","vals","map","flat","JSON","stringify","cache","recurse","x","y","keys","change","changed","added","removed","startIndex","deleteCount","Math","min","endIndex","NaN","Infinity","Number","constants","strings","parseInt","reg","regexes","RegExp","regex","flags","literals","js","resnums","processed","reses","num","match","$$","$","s","allowJit","evalContext","lispifyFunction","isAsync","checkFirst","startInternal","getIterator","startStep","step","condition","beforeStep","loop","loopScope","internalVars","$$obj","interalScope","innerLoopVars","toTest","isTrue","caseItem","exception","catchBody","finallyBody","executeTreeWithDone","unexecTypes","executionTree","scopes","globalScope","current","_executeWithDoneSync","_executeWithDoneAsync","subscribeSet","names","callbacks","changeCbs","delete","SandboxExec","WeakMap","sandboxFunctions","haltSubscriptions","resumeSubscriptions","timeoutHandleCounter","setTimeoutHandles","setIntervalHandles","opt","SAFE_GLOBALS","SAFE_PROTOTYPES","values","executionQuota","WeakSet","Symbol","iterator","createContext","Function","eval","console","debug","info","log","table","warn","isFinite","isNaN","parseFloat","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","unescape","Boolean","String","EvalError","RangeError","URIError","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Intl","Date","protos","proto","subscribeGet","subscribeSetGlobal","haltContext","resumeExecution","getContext","fn"],"mappings":"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"}