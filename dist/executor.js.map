{"version":3,"file":"executor.js","sources":["../src/executor.ts"],"sourcesContent":["import { LispItem, Lisp, IRegEx, SwitchCase } from './parser.js';\nimport {\n  CodeString,\n  hasOwnProperty,\n  IAuditReport,\n  IExecContext,\n  IScope,\n  isLisp,\n  LispType,\n  LocalScope,\n  Prop,\n  SandboxExecutionQuotaExceededError,\n  SandboxError,\n  SandboxExecutionTreeError,\n  Scope,\n  Ticks,\n  VarType,\n  SandboxCapabilityError,\n  SandboxAccessError,\n} from './utils.js';\n\nexport type Done<T = any> = (err?: any, res?: T | typeof optional) => void;\n\nexport class ExecReturn<T> {\n  constructor(\n    public auditReport: IAuditReport | undefined,\n    public result: T,\n    public returned: boolean,\n    public breakLoop = false,\n    public continueLoop = false,\n  ) {}\n}\n\nexport type Unknown = undefined | null | Record<string | number, unknown>;\n\nexport interface IChange {\n  type: string;\n}\n\nexport interface ICreate extends IChange {\n  type: 'create';\n  prop: number | string;\n}\n\nexport interface IReplace extends IChange {\n  type: 'replace';\n}\n\nexport interface IDelete extends IChange {\n  type: 'delete';\n  prop: number | string;\n}\n\nexport interface IReverse extends IChange {\n  type: 'reverse';\n}\n\nexport interface ISort extends IChange {\n  type: 'sort';\n}\n\nexport interface IPush extends IChange {\n  type: 'push';\n  added: unknown[];\n}\n\nexport interface IPop extends IChange {\n  type: 'pop';\n  removed: unknown[];\n}\n\nexport interface IShift extends IChange {\n  type: 'shift';\n  removed: unknown[];\n}\n\nexport interface IUnShift extends IChange {\n  type: 'unshift';\n  added: unknown[];\n}\n\nexport interface ISplice extends IChange {\n  type: 'splice';\n  startIndex: number;\n  deleteCount: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport interface ICopyWithin extends IChange {\n  type: 'copyWithin';\n  startIndex: number;\n  endIndex: number;\n  added: unknown[];\n  removed: unknown[];\n}\n\nexport type Change =\n  | ICreate\n  | IReplace\n  | IDelete\n  | IReverse\n  | ISort\n  | IPush\n  | IPop\n  | IUnShift\n  | IShift\n  | ISplice\n  | ICopyWithin;\n\nconst optional = {};\n\nfunction generateArgs(argNames: string[], args: unknown[]) {\n  const vars: Record<string, unknown> = {};\n  argNames.forEach((arg, i) => {\n    if (arg.startsWith('...')) {\n      vars[arg.substring(3)] = args.slice(i);\n    } else {\n      vars[arg] = args[i];\n    }\n  });\n  return vars;\n}\n\nexport function createFunction(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string,\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxCapabilityError('Function creation is forbidden');\n  }\n  let func;\n  if (name === undefined) {\n    func = (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)],\n      );\n      return res.result;\n    };\n  } else {\n    func = function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = executeTree(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)],\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  context.ctx.sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function createFunctionAsync(\n  argNames: string[],\n  parsed: Lisp[],\n  ticks: Ticks,\n  context: IExecContext,\n  scope?: Scope,\n  name?: string,\n) {\n  if (context.ctx.options.forbidFunctionCreation) {\n    throw new SandboxCapabilityError('Function creation is forbidden');\n  }\n  if (!context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n    throw new SandboxCapabilityError('Async/await not permitted');\n  }\n  let func;\n  if (name === undefined) {\n    func = async (...args: unknown[]) => {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars)],\n      );\n      return res.result;\n    };\n  } else {\n    func = async function sandboxedObject(this: Unknown, ...args: unknown[]) {\n      const vars = generateArgs(argNames, args);\n      const res = await executeTreeAsync(\n        ticks,\n        context,\n        parsed,\n        scope === undefined ? [] : [new Scope(scope, vars, this)],\n      );\n      return res.result;\n    };\n  }\n  context.registerSandboxFunction(func);\n  context.ctx.sandboxedFunctions.add(func);\n  return func;\n}\n\nexport function assignCheck(obj: Prop, context: IExecContext, op = 'assign') {\n  if (obj.context === undefined) {\n    throw new ReferenceError(`Cannot ${op} value to undefined.`);\n  }\n  if (obj.isConst) {\n    throw new TypeError(`Assignment to constant variable.`);\n  }\n  if (obj.isGlobal) {\n    throw new SandboxAccessError(\n      `Cannot ${op} property '${obj.prop.toString()}' of a global object`,\n    );\n  }\n  if (obj.context === null) {\n    throw new TypeError('Cannot set properties of null');\n  }\n  if (\n    typeof (obj.context as any)[obj.prop] === 'function' &&\n    !hasOwnProperty(obj.context, obj.prop)\n  ) {\n    throw new SandboxAccessError(\n      `Override prototype property '${obj.prop.toString()}' not allowed`,\n    );\n  }\n  if (op === 'delete') {\n    if (hasOwnProperty(obj.context, obj.prop)) {\n      context.changeSubscriptions\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop.toString() }));\n      context.changeSubscriptionsGlobal\n        .get(obj.context)\n        ?.forEach((cb) => cb({ type: 'delete', prop: obj.prop.toString() }));\n    }\n  } else if (hasOwnProperty(obj.context, obj.prop)) {\n    context.setSubscriptions\n      .get(obj.context)\n      ?.get(obj.prop.toString())\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        }),\n      );\n    context.setSubscriptionsGlobal\n      .get(obj.context)\n      ?.get(obj.prop.toString())\n      ?.forEach((cb) =>\n        cb({\n          type: 'replace',\n        }),\n      );\n  } else {\n    context.changeSubscriptions\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop.toString() }));\n    context.changeSubscriptionsGlobal\n      .get(obj.context)\n      ?.forEach((cb) => cb({ type: 'create', prop: obj.prop.toString() }));\n  }\n}\nconst arrayChange = new Set([\n  [].push,\n  [].pop,\n  [].shift,\n  [].unshift,\n  [].splice,\n  [].reverse,\n  [].sort,\n  [].copyWithin,\n]);\n\nexport class KeyVal {\n  constructor(\n    public key: string | SpreadObject,\n    public val: unknown,\n  ) {}\n}\n\nexport class SpreadObject {\n  constructor(public item: { [key: string]: unknown }) {}\n}\n\nexport class SpreadArray {\n  constructor(public item: unknown[]) {}\n}\n\nexport class If {\n  constructor(\n    public t: Lisp,\n    public f: Lisp,\n  ) {}\n}\n\nconst literalRegex = /(\\$\\$)*(\\$)?\\${(\\d+)}/g;\ntype OpCallback<a, b, obj, bobj> = (params: OpsCallbackParams<a, b, obj, bobj>) => void;\n\nexport const ops = new Map<LispType, OpCallback<any, any, any, any>>();\nexport function addOps<a = unknown, b = unknown, obj = unknown, bobj = unknown>(\n  type: LispType,\n  cb: OpCallback<a, b, obj, bobj>,\n) {\n  ops.set(type, cb);\n}\n\nfunction isPropertyKey(val: unknown): val is PropertyKey {\n  return ['string', 'number', 'symbol'].includes(typeof val);\n}\n\nfunction hasPossibleProperties(val: unknown): val is {} {\n  return val !== null && val !== undefined;\n}\n\naddOps<unknown, PropertyKey>(LispType.Prop, ({ done, a, b, obj, context, scope }) => {\n  if (a === null) {\n    throw new TypeError(`Cannot read properties of null (reading '${b?.toString()}')`);\n  }\n\n  if (!isPropertyKey(b)) {\n    try {\n      b = `${b}`;\n    } catch (e) {\n      done(e);\n      return;\n    }\n  }\n\n  if (a === undefined && obj === undefined && typeof b === 'string') {\n    // is variable access\n    const prop = scope.get(b);\n    if (prop.context === context.ctx.sandboxGlobal) {\n      if (context.ctx.options.audit) {\n        context.ctx.auditReport?.globalsAccess.add(b);\n      }\n    }\n    const val = prop.context ? (prop.context as any)[prop.prop] : undefined;\n    const p = getGlobalProp(val, context, prop) || prop;\n\n    done(undefined, p);\n    return;\n  } else if (a === undefined) {\n    throw new TypeError(`Cannot read properties of undefined (reading '${b.toString()}')`);\n  }\n\n  if (!hasPossibleProperties(a)) {\n    done(undefined, new Prop(undefined, b));\n    return;\n  }\n\n  const prototypeAccess = typeof a === 'function' || !hasOwnProperty(a, b);\n\n  if (context.ctx.options.audit && prototypeAccess) {\n    let prot: {} = Object.getPrototypeOf(a);\n    do {\n      if (hasOwnProperty(prot, b)) {\n        if (\n          context.ctx.auditReport &&\n          !context.ctx.auditReport.prototypeAccess[prot.constructor.name]\n        ) {\n          context.ctx.auditReport.prototypeAccess[prot.constructor.name] = new Set();\n        }\n        context.ctx.auditReport?.prototypeAccess[prot.constructor.name].add(b);\n      }\n    } while ((prot = Object.getPrototypeOf(prot)));\n  }\n\n  if (prototypeAccess) {\n    if (typeof a === 'function') {\n      if (hasOwnProperty(a, b)) {\n        const whitelist = context.ctx.prototypeWhitelist.get(a.prototype);\n        const replace = context.ctx.options.prototypeReplacements.get(a);\n        if (replace) {\n          done(undefined, new Prop(replace(a, true), b));\n          return;\n        }\n        if (\n          !(whitelist && (!whitelist.size || whitelist.has(b))) &&\n          !context.ctx.sandboxedFunctions.has(a)\n        ) {\n          throw new SandboxAccessError(\n            `Static method or property access not permitted: ${a.name}.${b.toString()}`,\n          );\n        }\n      }\n    }\n\n    let prot: {} = a;\n    while ((prot = Object.getPrototypeOf(prot))) {\n      if (hasOwnProperty(prot, b) || b === '__proto__') {\n        const whitelist = context.ctx.prototypeWhitelist.get(prot);\n        const replace = context.ctx.options.prototypeReplacements.get(prot.constructor);\n        if (replace) {\n          done(undefined, new Prop(replace(a, false), b));\n          return;\n        }\n        if (\n          (whitelist && (!whitelist.size || whitelist.has(b))) ||\n          context.ctx.sandboxedFunctions.has(prot.constructor)\n        ) {\n          break;\n        }\n        if (b === '__proto__') {\n          throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n        }\n        throw new SandboxAccessError(\n          `Method or property access not permitted: ${prot.constructor.name}.${b.toString()}`,\n        );\n      }\n    }\n  }\n\n  const val = a[b as keyof typeof a] as unknown;\n  if (typeof a === 'function') {\n    if (b === 'prototype' && !context.ctx.sandboxedFunctions.has(a)) {\n      throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n    }\n  }\n\n  if (b === '__proto__' && !context.ctx.sandboxedFunctions.has(val?.constructor as any)) {\n    throw new SandboxAccessError(`Access to prototype of global object is not permitted`);\n  }\n\n  const p = getGlobalProp(val, context);\n  if (p) {\n    done(undefined, p);\n    return;\n  }\n\n  const g =\n    (obj instanceof Prop && obj.isGlobal) ||\n    (typeof a === 'function' && !context.ctx.sandboxedFunctions.has(a)) ||\n    context.ctx.globalsWhitelist.has(a);\n\n  done(undefined, new Prop(a, b, false, g, false));\n});\n\nfunction getGlobalProp(val: unknown, context: IExecContext, prop?: Prop) {\n  if (!val) return;\n  const isFunc = typeof val === 'function';\n  if (val instanceof Prop) {\n    if (!prop) {\n      prop = val;\n    }\n    val = val.get(context);\n  }\n  const p = prop?.prop || 'prop';\n  if (val === globalThis) {\n    return new Prop(\n      {\n        [p]: context.ctx.sandboxGlobal,\n      },\n      p,\n      prop?.isConst || false,\n      false,\n      prop?.isVariable || false,\n    );\n  }\n  const e = isFunc && context.evals.get(val);\n  if (e) {\n    return new Prop(\n      {\n        [p]: e,\n      },\n      p,\n      prop?.isConst || false,\n      true,\n      prop?.isVariable || false,\n    );\n  }\n}\n\naddOps<unknown, Lisp[], any>(LispType.Call, ({ done, a, b, obj, context }) => {\n  if (context.ctx.options.forbidFunctionCalls)\n    throw new SandboxCapabilityError('Function invocations are not allowed');\n  if (typeof a !== 'function') {\n    throw new TypeError(`${typeof obj.prop === 'symbol' ? 'Symbol' : obj.prop} is not a function`);\n  }\n  const vals = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n\n  if (typeof obj === 'function') {\n    let ret = obj(...vals);\n    if (ret instanceof Promise) {\n      ret = checkHaltAsync(context, ret);\n    } else {\n      ret = getGlobalProp(ret, context) || ret;\n    }\n    done(undefined, ret);\n    return;\n  }\n  if (obj.context[obj.prop] === JSON.stringify && context.getSubscriptions.size) {\n    const cache = new Set<any>();\n    const recurse = (x: unknown) => {\n      if (!x || !(typeof x === 'object') || cache.has(x)) return;\n      cache.add(x);\n      for (const y of Object.keys(x) as (keyof typeof x)[]) {\n        context.getSubscriptions.forEach((cb) => cb(x, y));\n        recurse(x[y]);\n      }\n    };\n    recurse(vals[0]);\n  }\n\n  if (\n    obj.context instanceof Array &&\n    arrayChange.has(obj.context[obj.prop]) &&\n    (context.changeSubscriptions.get(obj.context) ||\n      context.changeSubscriptionsGlobal.get(obj.context))\n  ) {\n    let change: Change;\n    let changed = false;\n    if (obj.prop === 'push') {\n      change = {\n        type: 'push',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'pop') {\n      change = {\n        type: 'pop',\n        removed: obj.context.slice(-1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'shift') {\n      change = {\n        type: 'shift',\n        removed: obj.context.slice(0, 1),\n      };\n      changed = !!change.removed.length;\n    } else if (obj.prop === 'unshift') {\n      change = {\n        type: 'unshift',\n        added: vals,\n      };\n      changed = !!vals.length;\n    } else if (obj.prop === 'splice') {\n      change = {\n        type: 'splice',\n        startIndex: vals[0] as number,\n        deleteCount: vals[1] === undefined ? obj.context.length : vals[1],\n        added: vals.slice(2),\n        removed: obj.context.slice(\n          vals[0],\n          vals[1] === undefined ? undefined : (vals[0] as number) + (vals[1] as number),\n        ),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    } else if (obj.prop === 'reverse' || obj.prop === 'sort') {\n      change = { type: obj.prop };\n      changed = !!obj.context.length;\n    } else if (obj.prop === 'copyWithin') {\n      const len =\n        vals[2] === undefined\n          ? obj.context.length - (vals[1] as number)\n          : Math.min(obj.context.length, (vals[2] as number) - (vals[1] as number));\n      change = {\n        type: 'copyWithin',\n        startIndex: vals[0] as number,\n        endIndex: (vals[0] as number) + len,\n        added: obj.context.slice(vals[1] as number, (vals[1] as number) + len),\n        removed: obj.context.slice(vals[0] as number, (vals[0] as number) + len),\n      };\n      changed = !!change.added.length || !!change.removed.length;\n    }\n    if (changed) {\n      context.changeSubscriptions.get(obj.context)?.forEach((cb) => cb(change));\n      context.changeSubscriptionsGlobal.get(obj.context)?.forEach((cb) => cb(change));\n    }\n  }\n  obj.get(context);\n  let ret = obj.context[obj.prop](...vals) as unknown;\n  if (ret instanceof Promise) {\n    ret = checkHaltAsync(context, ret);\n  } else {\n    ret = getGlobalProp(ret, context) || ret;\n  }\n  done(undefined, ret);\n});\n\naddOps<unknown, KeyVal[]>(LispType.CreateObject, ({ done, b }) => {\n  let res = {} as any;\n  for (const item of b) {\n    if (item.key instanceof SpreadObject) {\n      res = { ...res, ...item.key.item };\n    } else {\n      res[item.key] = item.val;\n    }\n  }\n  done(undefined, res);\n});\n\naddOps<string, LispItem>(LispType.KeyVal, ({ done, a, b }) => done(undefined, new KeyVal(a, b)));\n\naddOps<unknown, Lisp[]>(LispType.CreateArray, ({ done, b, context }) => {\n  const items = b\n    .map((item) => {\n      if (item instanceof SpreadArray) {\n        return [...item.item];\n      } else {\n        return [item];\n      }\n    })\n    .flat()\n    .map((item) => valueOrProp(item, context));\n  done(undefined, items);\n});\n\naddOps<unknown, unknown>(LispType.Group, ({ done, b }) => done(undefined, b));\n\naddOps<unknown, string>(LispType.GlobalSymbol, ({ done, b }) => {\n  switch (b) {\n    case 'true':\n      return done(undefined, true);\n    case 'false':\n      return done(undefined, false);\n    case 'null':\n      return done(undefined, null);\n    case 'undefined':\n      return done(undefined, undefined);\n    case 'NaN':\n      return done(undefined, NaN);\n    case 'Infinity':\n      return done(undefined, Infinity);\n  }\n  done(new Error('Unknown symbol: ' + b));\n});\n\naddOps<unknown, string>(LispType.Number, ({ done, b }) =>\n  done(undefined, Number(b.replace(/_/g, ''))),\n);\naddOps<unknown, string>(LispType.BigInt, ({ done, b }) =>\n  done(undefined, BigInt(b.replace(/_/g, ''))),\n);\naddOps<unknown, string>(LispType.StringIndex, ({ done, b, context }) =>\n  done(undefined, context.constants.strings[parseInt(b)]),\n);\n\naddOps<unknown, string>(LispType.RegexIndex, ({ done, b, context }) => {\n  const reg: IRegEx = context.constants.regexes[parseInt(b)];\n  if (!context.ctx.globalsWhitelist.has(RegExp)) {\n    throw new SandboxCapabilityError('Regex not permitted');\n  } else {\n    done(undefined, new RegExp(reg.regex, reg.flags));\n  }\n});\n\naddOps<unknown, string>(LispType.LiteralIndex, ({ exec, done, ticks, b, context, scope }) => {\n  const item = context.constants.literals[parseInt(b)];\n  const [, name, js] = item;\n  const found: Lisp[] = [];\n  let f: RegExpExecArray | null;\n  const resnums: string[] = [];\n  while ((f = literalRegex.exec(name))) {\n    if (!f[2]) {\n      found.push(js[parseInt(f[3], 10)]);\n      resnums.push(f[3]);\n    }\n  }\n\n  exec<unknown[]>(ticks, found, scope, context, (err, processed) => {\n    const reses: Record<string, unknown> = {};\n    if (err) {\n      done(err);\n      return;\n    }\n    for (const i of Object.keys(processed!) as (keyof typeof processed)[]) {\n      const num = resnums[i];\n      reses[num] = processed![i];\n    }\n    done(\n      undefined,\n      name.replace(/(\\\\\\\\)*(\\\\)?\\${(\\d+)}/g, (match, $$, $, num) => {\n        if ($) return match;\n        const res = reses[num];\n        return ($$ ? $$ : '') + `${valueOrProp(res, context)}`;\n      }),\n    );\n  });\n});\n\naddOps<unknown, unknown[]>(LispType.SpreadArray, ({ done, b }) => {\n  done(undefined, new SpreadArray(b));\n});\n\naddOps<unknown, Record<string, unknown>>(LispType.SpreadObject, ({ done, b }) => {\n  done(undefined, new SpreadObject(b));\n});\n\naddOps<unknown, unknown>(LispType.Not, ({ done, b }) => done(undefined, !b));\naddOps<unknown, number>(LispType.Inverse, ({ done, b }) => done(undefined, ~b));\n\naddOps<unknown, unknown, Prop<any>>(LispType.IncrementBefore, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, ++obj.context[obj.prop]);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.IncrementAfter, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]++);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.DecrementBefore, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, --obj.context[obj.prop]);\n});\n\naddOps<unknown, unknown, Prop<any>>(LispType.DecrementAfter, ({ done, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, obj.context[obj.prop]--);\n});\n\naddOps<unknown, unknown, Prop<any>, Prop<any>>(\n  LispType.Assign,\n  ({ done, b, obj, context, scope, bobj }) => {\n    assignCheck(obj, context);\n    obj.isGlobal = bobj?.isGlobal || false;\n    if (obj.isVariable) {\n      const s = scope.getWhereValScope(obj.prop as string, obj.prop === 'this');\n      if (s === null) {\n        throw new ReferenceError(`Cannot assign to undeclared variable '${obj.prop.toString()}'`);\n      }\n      s.set(obj.prop as string, b);\n      if (obj.isGlobal) {\n        s.globals[obj.prop.toString()] = true;\n      } else {\n        delete s.globals[obj.prop.toString()];\n      }\n      done(undefined, b);\n      return;\n    }\n    done(undefined, (obj.context[obj.prop] = b));\n  },\n);\n\naddOps<unknown, unknown, Prop<any>>(LispType.AddEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] += b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.SubractEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] -= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.DivideEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] /= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.MultiplyEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] *= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.PowerEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] **= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ModulusEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] %= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitNegateEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] ^= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitAndEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] &= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.BitOrEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] |= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ShiftLeftEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] <<= b));\n});\n\naddOps<unknown, number, Prop<any>>(LispType.ShiftRightEquals, ({ done, b, obj, context }) => {\n  assignCheck(obj, context);\n  done(undefined, (obj.context[obj.prop] >>= b));\n});\n\naddOps<unknown, number, Prop<any>>(\n  LispType.UnsignedShiftRightEquals,\n  ({ done, b, obj, context }) => {\n    assignCheck(obj, context);\n    done(undefined, (obj.context[obj.prop] >>>= b));\n  },\n);\n\naddOps<number, number>(LispType.LargerThan, ({ done, a, b }) => done(undefined, a > b));\naddOps<number, number>(LispType.SmallerThan, ({ done, a, b }) => done(undefined, a < b));\naddOps<number, number>(LispType.LargerEqualThan, ({ done, a, b }) => done(undefined, a >= b));\naddOps<number, number>(LispType.SmallerEqualThan, ({ done, a, b }) => done(undefined, a <= b));\naddOps<number, number>(LispType.Equal, ({ done, a, b }) => done(undefined, a == b));\naddOps<number, number>(LispType.StrictEqual, ({ done, a, b }) => done(undefined, a === b));\naddOps<number, number>(LispType.NotEqual, ({ done, a, b }) => done(undefined, a != b));\naddOps<number, number>(LispType.StrictNotEqual, ({ done, a, b }) => done(undefined, a !== b));\naddOps<number, number>(LispType.And, ({ done, a, b }) => done(undefined, a && b));\naddOps<number, number>(LispType.Or, ({ done, a, b }) => done(undefined, a || b));\naddOps<number, number>(LispType.NullishCoalescing, ({ done, a, b }) => done(undefined, a ?? b));\naddOps<number, number>(LispType.BitAnd, ({ done, a, b }) => done(undefined, a & b));\naddOps<number, number>(LispType.BitOr, ({ done, a, b }) => done(undefined, a | b));\naddOps<number, number>(LispType.Plus, ({ done, a, b }) => done(undefined, a + b));\naddOps<number, number>(LispType.Minus, ({ done, a, b }) => done(undefined, a - b));\naddOps<number, number>(LispType.Positive, ({ done, b }) => done(undefined, +b));\naddOps<number, number>(LispType.Negative, ({ done, b }) => done(undefined, -b));\naddOps<number, number>(LispType.Divide, ({ done, a, b }) => done(undefined, a / b));\naddOps<number, number>(LispType.Power, ({ done, a, b }) => done(undefined, a ** b));\naddOps<number, number>(LispType.BitNegate, ({ done, a, b }) => done(undefined, a ^ b));\naddOps<number, number>(LispType.Multiply, ({ done, a, b }) => done(undefined, a * b));\naddOps<number, number>(LispType.Modulus, ({ done, a, b }) => done(undefined, a % b));\naddOps<number, number>(LispType.BitShiftLeft, ({ done, a, b }) => done(undefined, a << b));\naddOps<number, number>(LispType.BitShiftRight, ({ done, a, b }) => done(undefined, a >> b));\naddOps<number, number>(LispType.BitUnsignedShiftRight, ({ done, a, b }) =>\n  done(undefined, a >>> b),\n);\naddOps<unknown, LispItem>(LispType.Typeof, ({ exec, done, ticks, b, context, scope }) => {\n  exec(ticks, b, scope, context, (e, prop) => {\n    done(undefined, typeof valueOrProp(prop, context));\n  });\n});\n\naddOps<unknown, { new (): unknown }>(LispType.Instanceof, ({ done, a, b }) =>\n  done(undefined, a instanceof b),\n);\naddOps<string, {}>(LispType.In, ({ done, a, b }) => done(undefined, a in b));\n\naddOps<unknown, unknown>(LispType.Delete, ({ done, context, bobj }) => {\n  if (!(bobj instanceof Prop)) {\n    done(undefined, true);\n    return;\n  }\n  assignCheck(bobj, context, 'delete');\n  if (bobj.isVariable) {\n    done(undefined, false);\n    return;\n  }\n  done(undefined, delete (bobj.context as any)?.[bobj.prop]);\n});\n\naddOps(LispType.Return, ({ done, b }) => done(undefined, b));\n\naddOps<string, unknown, unknown, Prop>(LispType.Var, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.var, b, bobj?.isGlobal || false));\n});\n\naddOps<string, unknown, unknown, Prop>(LispType.Let, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.let, b, bobj?.isGlobal || false));\n});\n\naddOps<string, unknown, unknown, Prop>(LispType.Const, ({ done, a, b, scope, bobj }) => {\n  done(undefined, scope.declare(a, VarType.const, b, bobj?.isGlobal || false));\n});\n\naddOps<string[], Lisp[], Lisp>(\n  LispType.ArrowFunction,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    a = [...a];\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    if (a.shift()) {\n      done(undefined, createFunctionAsync(a, b, ticks, context, scope));\n    } else {\n      done(undefined, createFunction(a, b, ticks, context, scope));\n    }\n  },\n);\n\naddOps<(string | LispType)[], Lisp[], Lisp>(\n  LispType.Function,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.var, func);\n    }\n    done(undefined, func);\n  },\n);\n\naddOps<(string | LispType)[], Lisp[], Lisp>(\n  LispType.InlineFunction,\n  ({ done, ticks, a, b, obj, context, scope }) => {\n    if (typeof obj[2] === 'string' || obj[2] instanceof CodeString) {\n      if (context.allowJit && context.evalContext) {\n        obj[2] = b = context.evalContext.lispifyFunction(new CodeString(obj[2]), context.constants);\n      } else {\n        throw new SandboxCapabilityError('Unevaluated code detected, JIT not allowed');\n      }\n    }\n    const isAsync = a.shift();\n    const name = a.shift() as string;\n    if (name) {\n      scope = new Scope(scope, {});\n    }\n    let func;\n    if (isAsync === LispType.True) {\n      func = createFunctionAsync(a as string[], b, ticks, context, scope, name);\n    } else {\n      func = createFunction(a as string[], b, ticks, context, scope, name);\n    }\n    if (name) {\n      scope.declare(name, VarType.let, func);\n    }\n    done(undefined, func);\n  },\n);\n\naddOps<Lisp[], Lisp[]>(LispType.Loop, ({ exec, done, ticks, a, b, context, scope }) => {\n  const [checkFirst, startInternal, getIterator, startStep, step, condition, beforeStep] = a;\n  let loop = true;\n  const loopScope = new Scope(scope, {});\n  const internalVars = {\n    $$obj: undefined,\n  };\n  const interalScope = new Scope(loopScope, internalVars);\n  if (exec === execAsync) {\n    (async () => {\n      let ad: AsyncDoneRet;\n      ad = asyncDone((d) => exec(ticks, startStep, loopScope, context, d));\n      internalVars['$$obj'] =\n        (ad = asyncDone((d) => exec(ticks, getIterator, loopScope, context, d))).isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n      ad = asyncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n      if (checkFirst)\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      while (loop) {\n        const innerLoopVars = {};\n        ad = asyncDone((d) =>\n          exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d),\n        );\n        ad.isInstant === true ? ad.instant : (await ad.p).result;\n        const res = await executeTreeAsync(\n          ticks,\n          context,\n          b,\n          [new Scope(loopScope, innerLoopVars)],\n          'loop',\n        );\n        if (res instanceof ExecReturn && res.returned) {\n          done(undefined, res);\n          return;\n        }\n        if (res instanceof ExecReturn && res.breakLoop) {\n          break;\n        }\n        ad = asyncDone((d) => exec(ticks, step, interalScope, context, d));\n        loop =\n          (ad = asyncDone((d) => exec(ticks, condition, interalScope, context, d))).isInstant ===\n          true\n            ? ad.instant\n            : (await ad.p).result;\n      }\n      done();\n    })().catch(done);\n  } else {\n    syncDone((d) => exec(ticks, startStep, loopScope, context, d));\n    internalVars['$$obj'] = syncDone((d) => exec(ticks, getIterator, loopScope, context, d)).result;\n    syncDone((d) => exec(ticks, startInternal, interalScope, context, d));\n    if (checkFirst) loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    while (loop) {\n      const innerLoopVars = {};\n      syncDone((d) => exec(ticks, beforeStep, new Scope(interalScope, innerLoopVars), context, d));\n      const res = executeTree(ticks, context, b, [new Scope(loopScope, innerLoopVars)], 'loop');\n      if (res instanceof ExecReturn && res.returned) {\n        done(undefined, res);\n        return;\n      }\n      if (res instanceof ExecReturn && res.breakLoop) {\n        break;\n      }\n      syncDone((d) => exec(ticks, step, interalScope, context, d));\n      loop = syncDone((d) => exec(ticks, condition, interalScope, context, d)).result;\n    }\n    done();\n  }\n});\n\naddOps<LispItem, LispItem>(LispType.LoopAction, ({ done, a, context, inLoopOrSwitch }) => {\n  if ((inLoopOrSwitch === 'switch' && a === 'continue') || !inLoopOrSwitch) {\n    throw new TypeError('Illegal ' + a + ' statement');\n  }\n  done(\n    undefined,\n    new ExecReturn(context.ctx.auditReport, undefined, false, a === 'break', a === 'continue'),\n  );\n});\n\naddOps<LispItem, If>(LispType.If, ({ exec, done, ticks, a, b, context, scope, inLoopOrSwitch }) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done, inLoopOrSwitch);\n});\n\naddOps<LispItem, If>(LispType.InlineIf, ({ exec, done, ticks, a, b, context, scope }) => {\n  exec(ticks, valueOrProp(a, context) ? b.t : b.f, scope, context, done, undefined);\n});\n\naddOps<Lisp, Lisp>(LispType.InlineIfCase, ({ done, a, b }) => done(undefined, new If(a, b)));\naddOps<Lisp, Lisp>(LispType.IfCase, ({ done, a, b }) => done(undefined, new If(a, b)));\n\naddOps<LispItem, SwitchCase[]>(LispType.Switch, ({ exec, done, ticks, a, b, context, scope }) => {\n  exec(ticks, a, scope, context, (err, toTest) => {\n    if (err) {\n      done(err);\n      return;\n    }\n    toTest = valueOrProp(toTest, context);\n    if (exec === execSync) {\n      let res: ExecReturn<unknown>;\n      let isTrue = false;\n      for (const caseItem of b) {\n        if (\n          isTrue ||\n          (isTrue =\n            !caseItem[1] ||\n            toTest ===\n              valueOrProp(\n                syncDone((d) => exec(ticks, caseItem[1], scope, context, d)).result,\n                context,\n              ))\n        ) {\n          if (!caseItem[2]) continue;\n          res = executeTree(ticks, context, caseItem[2], [scope], 'switch');\n          if (res.breakLoop) break;\n          if (res.returned) {\n            done(undefined, res);\n            return;\n          }\n          if (!caseItem[1]) {\n            // default case\n            break;\n          }\n        }\n      }\n      done();\n    } else {\n      (async () => {\n        let res: ExecReturn<unknown>;\n        let isTrue = false;\n        for (const caseItem of b) {\n          let ad: AsyncDoneRet;\n          if (\n            isTrue ||\n            (isTrue =\n              !caseItem[1] ||\n              toTest ===\n                valueOrProp(\n                  (ad = asyncDone((d) => exec(ticks, caseItem[1], scope, context, d))).isInstant ===\n                    true\n                    ? ad.instant\n                    : (await ad.p).result,\n                  context,\n                ))\n          ) {\n            if (!caseItem[2]) continue;\n            res = await executeTreeAsync(ticks, context, caseItem[2], [scope], 'switch');\n            if (res.breakLoop) break;\n            if (res.returned) {\n              done(undefined, res);\n              return;\n            }\n            if (!caseItem[1]) {\n              // default case\n              break;\n            }\n          }\n        }\n        done();\n      })().catch(done);\n    }\n  });\n});\n\naddOps<Lisp[], [string, Lisp[], Lisp[]]>(\n  LispType.Try,\n  ({ exec, done, ticks, a, b, context, scope, inLoopOrSwitch }) => {\n    const [exception, catchBody, finallyBody] = b;\n    executeTreeWithDone(\n      exec,\n      (err, res) => {\n        executeTreeWithDone(\n          exec,\n          (e) => {\n            if (e) done(e);\n            else if (err) {\n              const sc: Record<string, unknown> = {};\n              if (exception) sc[exception] = err;\n              executeTreeWithDone(\n                exec,\n                done,\n                ticks,\n                context,\n                catchBody,\n                [new Scope(scope)],\n                inLoopOrSwitch,\n              );\n            } else {\n              done(undefined, res);\n            }\n          },\n          ticks,\n          context,\n          finallyBody,\n          [new Scope(scope, {})],\n        );\n      },\n      ticks,\n      context,\n      a,\n      [new Scope(scope)],\n      inLoopOrSwitch,\n    );\n  },\n);\n\naddOps(LispType.Void, ({ done }) => {\n  done();\n});\naddOps<new (...args: unknown[]) => unknown, unknown[]>(LispType.New, ({ done, a, b, context }) => {\n  if (!context.ctx.globalsWhitelist.has(a) && !context.ctx.sandboxedFunctions.has(a)) {\n    throw new SandboxAccessError(`Object construction not allowed: ${a.constructor.name}`);\n  }\n  done(undefined, new a(...b));\n});\n\naddOps(LispType.Throw, ({ done, b }) => {\n  done(b);\n});\naddOps<unknown[]>(LispType.Expression, ({ done, a }) => done(undefined, a.pop()));\naddOps(LispType.None, ({ done }) => done());\n\nfunction valueOrProp(a: unknown, context: IExecContext): unknown {\n  if (a instanceof Prop) return a.get(context);\n  if (a === optional) return undefined;\n  return a;\n}\n\nexport function execMany(\n  ticks: Ticks,\n  exec: Execution,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  if (exec === execSync) {\n    _execManySync(ticks, tree, done, scope, context, inLoopOrSwitch);\n  } else {\n    _execManyAsync(ticks, tree, done, scope, context, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _execManySync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      res = syncDone((d) => execSync(ticks, tree[i], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\nasync function _execManyAsync(\n  ticks: Ticks,\n  tree: Lisp[],\n  done: Done,\n  scope: Scope,\n  context: IExecContext,\n  inLoopOrSwitch?: string,\n) {\n  const ret: any[] = [];\n  for (let i = 0; i < tree.length; i++) {\n    let res;\n    try {\n      let ad: AsyncDoneRet;\n      res =\n        (ad = asyncDone((d) => execAsync(ticks, tree[i], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (res instanceof ExecReturn && (res.returned || res.breakLoop || res.continueLoop)) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(tree[i]) && tree[i][0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n    ret.push(res);\n  }\n  done(undefined, ret);\n}\n\ntype Execution = <T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string,\n) => void;\n\nexport interface AsyncDoneRet {\n  isInstant: boolean;\n  instant: any;\n  p: Promise<{ result: any }>;\n}\n\nexport function asyncDone(callback: (done: Done) => void): AsyncDoneRet {\n  let isInstant = false;\n  let instant: unknown;\n  const p = new Promise<any>((resolve, reject) => {\n    callback((err, result) => {\n      if (err) reject(err);\n      else {\n        isInstant = true;\n        instant = result;\n        resolve({ result });\n      }\n    });\n  });\n  return {\n    isInstant,\n    instant,\n    p,\n  };\n}\n\nexport function syncDone(callback: (done: Done) => void): { result: any } {\n  let result;\n  let err;\n  callback((e, r) => {\n    err = e;\n    result = r;\n  });\n  if (err) throw err;\n  return { result };\n}\n\nexport async function execAsync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  doneOriginal: Done<T>,\n  inLoopOrSwitch?: string,\n): Promise<void> {\n  let done: Done<T> = doneOriginal;\n  const p = new Promise<void>((resolve) => {\n    done = (e, r?) => {\n      doneOriginal(e, r);\n      resolve();\n    };\n  });\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, true, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      let ad: AsyncDoneRet;\n      obj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[1], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    // Short-circuit for nullish coalescing: if a is not null/undefined, return a without evaluating b\n    if (op === LispType.NullishCoalescing && a !== undefined && a !== null) {\n      done(undefined, a);\n      return;\n    }\n    let bobj;\n    try {\n      let ad: AsyncDoneRet;\n      bobj =\n        (ad = asyncDone((d) => execAsync(ticks, tree[2], scope, context, d, inLoopOrSwitch)))\n          .isInstant === true\n          ? ad.instant\n          : (await ad.p).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    performOp({\n      op,\n      exec: execAsync,\n      done,\n      ticks,\n      a,\n      b,\n      obj,\n      context,\n      scope,\n      bobj,\n      inLoopOrSwitch,\n      tree,\n    });\n  }\n  await p;\n}\n\nexport function execSync<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  inLoopOrSwitch?: string,\n) {\n  if (!_execNoneRecurse(ticks, tree, scope, context, done, false, inLoopOrSwitch) && isLisp(tree)) {\n    let op = tree[0];\n    let obj;\n    try {\n      obj = syncDone((d) => execSync(ticks, tree[1], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let a = obj;\n    try {\n      a = obj instanceof Prop ? obj.get(context) : obj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (op === LispType.PropOptional || op === LispType.CallOptional) {\n      if (a === undefined || a === null) {\n        done(undefined, optional);\n        return;\n      }\n      op = op === LispType.PropOptional ? LispType.Prop : LispType.Call;\n    }\n    if (a === optional) {\n      if (op === LispType.Prop || op === LispType.Call) {\n        done(undefined, a);\n        return;\n      } else {\n        a = undefined;\n      }\n    }\n    // Short-circuit for nullish coalescing: if a is not null/undefined, return a without evaluating b\n    if (op === LispType.NullishCoalescing && a !== undefined && a !== null) {\n      done(undefined, a);\n      return;\n    }\n    let bobj;\n    try {\n      bobj = syncDone((d) => execSync(ticks, tree[2], scope, context, d, inLoopOrSwitch)).result;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    let b = bobj;\n    try {\n      b = bobj instanceof Prop ? bobj.get(context) : bobj;\n    } catch (e) {\n      done(e);\n      return;\n    }\n    if (b === optional) {\n      b = undefined;\n    }\n    performOp({\n      op,\n      exec: execSync,\n      done,\n      ticks,\n      a,\n      b,\n      obj,\n      context,\n      scope,\n      bobj,\n      inLoopOrSwitch,\n      tree,\n    });\n  }\n}\n\nfunction checkHaltAsync<T>(context: IExecContext, promise: Promise<T>): Promise<T> {\n  let done = false;\n  let halted = context.ctx.sandbox.halted;\n  let doResolve = () => {};\n  let subres: { unsubscribe: () => void };\n  let subhalt: { unsubscribe: () => void };\n  const interupted = new Promise<void>((resolve) => {\n    doResolve = () => {\n      subhalt.unsubscribe();\n      subres.unsubscribe();\n      resolve();\n    };\n    subhalt = context.ctx.sandbox.subscribeHalt(() => {\n      halted = true;\n    });\n\n    subres = context.ctx.sandbox.subscribeResume(() => {\n      halted = false;\n      if (done) doResolve();\n    });\n  });\n  promise\n    .finally(() => {\n      done = true;\n      if (!halted) {\n        doResolve();\n      }\n    })\n    .catch(() => {});\n  return Promise.allSettled([promise, interupted]).then(() => {\n    return promise;\n  });\n}\n\ntype OpsCallbackParams<a, b, obj, bobj> = {\n  op: LispType;\n  exec: Execution;\n  a: a;\n  b: b;\n  obj: obj;\n  bobj: bobj;\n  ticks: Ticks;\n  tree: LispItem;\n  scope: Scope;\n  context: IExecContext;\n  done: Done;\n  inLoopOrSwitch?: string;\n};\n\nfunction checkHaltExpectedTicks(\n  params: OpsCallbackParams<any, any, any, any>,\n  expectTicks = 0,\n): boolean {\n  const sandbox = params.context.ctx.sandbox;\n  const options = params.context.ctx.options;\n  const { ticks, scope, context, done, op } = params;\n  if (sandbox.halted) {\n    const sub = sandbox.subscribeResume(() => {\n      sub.unsubscribe();\n      try {\n        const o = ops.get(op);\n        if (!o) {\n          done(new SyntaxError('Unknown operator: ' + op));\n          return;\n        }\n        o(params);\n      } catch (err) {\n        if (options.haltOnSandboxError && err instanceof SandboxError) {\n          const sub = sandbox.subscribeResume(() => {\n            sub.unsubscribe();\n            done(err);\n          });\n          sandbox.haltExecution({\n            error: err as Error,\n            ticks,\n            scope,\n            context,\n          });\n        } else {\n          done(err);\n        }\n      }\n    });\n    return true;\n  } else if (ticks.tickLimit && ticks.tickLimit <= ticks.ticks + BigInt(expectTicks)) {\n    const sub = sandbox.subscribeResume(() => {\n      sub.unsubscribe();\n      try {\n        const o = ops.get(op);\n        if (!o) {\n          done(new SyntaxError('Unknown operator: ' + op));\n          return;\n        }\n        o(params);\n      } catch (err) {\n        if (context.ctx.options.haltOnSandboxError && err instanceof SandboxError) {\n          const sub = sandbox.subscribeResume(() => {\n            sub.unsubscribe();\n            done(err);\n          });\n          sandbox.haltExecution({\n            error: err as Error,\n            ticks,\n            scope,\n            context,\n          });\n        } else {\n          done(err);\n        }\n      }\n    });\n    const error = new SandboxExecutionQuotaExceededError('Execution quota exceeded');\n    sandbox.haltExecution({\n      error,\n      ticks,\n      scope: scope,\n      context,\n    });\n    return true;\n  }\n  return false;\n}\n\nfunction performOp(params: OpsCallbackParams<any, any, any, any>) {\n  const { done, op, ticks, context, scope } = params;\n  ticks.ticks++;\n  const sandbox = context.ctx.sandbox;\n\n  if (checkHaltExpectedTicks(params)) {\n    return;\n  }\n\n  try {\n    const o = ops.get(op);\n    if (!o) {\n      done(new SandboxExecutionTreeError('Unknown operator: ' + op));\n      return;\n    }\n    o(params);\n  } catch (err) {\n    if (context.ctx.options.haltOnSandboxError && err instanceof SandboxError) {\n      const sub = sandbox.subscribeResume(() => {\n        sub.unsubscribe();\n        done(err);\n      });\n      sandbox.haltExecution({\n        error: err as Error,\n        ticks,\n        scope,\n        context,\n      });\n    } else {\n      done(err);\n    }\n  }\n}\n\nconst unexecTypes = new Set([\n  LispType.ArrowFunction,\n  LispType.Function,\n  LispType.InlineFunction,\n  LispType.Loop,\n  LispType.Try,\n  LispType.Switch,\n  LispType.IfCase,\n  LispType.InlineIfCase,\n  LispType.Typeof,\n]);\n\nexport const currentTicks = { current: { ticks: BigInt(0) } as Ticks };\n\nfunction _execNoneRecurse<T = any>(\n  ticks: Ticks,\n  tree: LispItem,\n  scope: Scope,\n  context: IExecContext,\n  done: Done<T>,\n  isAsync: boolean,\n  inLoopOrSwitch?: string,\n): boolean {\n  const exec = isAsync ? execAsync : execSync;\n  currentTicks.current = ticks;\n  if (tree instanceof Prop) {\n    try {\n      done(undefined, tree.get(context));\n    } catch (err) {\n      done(err);\n    }\n  } else if (tree === optional) {\n    done();\n  } else if (Array.isArray(tree) && !isLisp(tree)) {\n    if (tree[0] === LispType.None) {\n      done();\n    } else {\n      execMany(ticks, exec, tree as Lisp[], done, scope, context, inLoopOrSwitch);\n    }\n  } else if (!isLisp(tree)) {\n    done(undefined, tree);\n  } else if (tree[0] === LispType.Block) {\n    execMany(ticks, exec, tree[1] as Lisp[], done, scope, context, inLoopOrSwitch);\n  } else if (tree[0] === LispType.Await) {\n    if (!isAsync) {\n      done(new SyntaxError(\"Illegal use of 'await', must be inside async function\"));\n    } else if (context.ctx.prototypeWhitelist?.has(Promise.prototype)) {\n      execAsync(\n        ticks,\n        tree[1],\n        scope,\n        context,\n        async (e, r) => {\n          if (e) done(e);\n          else\n            try {\n              done(undefined, (await valueOrProp(r, context)) as any);\n            } catch (err) {\n              done(err);\n            }\n        },\n        inLoopOrSwitch,\n      ).catch(done);\n    } else {\n      done(new SandboxCapabilityError('Async/await is not permitted'));\n    }\n  } else if (unexecTypes.has(tree[0])) {\n    performOp({\n      op: tree[0],\n      exec,\n      done,\n      ticks,\n      a: tree[1],\n      b: tree[2],\n      obj: tree,\n      tree,\n      context,\n      scope,\n      bobj: undefined,\n      inLoopOrSwitch,\n    });\n  } else {\n    return false;\n  }\n  return true;\n}\nexport function executeTree<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n): ExecReturn<T> {\n  return syncDone((done) =>\n    executeTreeWithDone(execSync, done, ticks, context, executionTree, scopes, inLoopOrSwitch),\n  ).result;\n}\n\nexport async function executeTreeAsync<T>(\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n): Promise<ExecReturn<T>> {\n  let ad: AsyncDoneRet;\n  return (ad = asyncDone((done) =>\n    executeTreeWithDone(execAsync, done, ticks, context, executionTree, scopes, inLoopOrSwitch),\n  )).isInstant === true\n    ? ad.instant\n    : (await ad.p).result;\n}\n\nfunction executeTreeWithDone(\n  exec: Execution,\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scopes: IScope[] = [],\n  inLoopOrSwitch?: string,\n) {\n  if (!executionTree) {\n    done();\n    return;\n  }\n  if (!(executionTree instanceof Array)) {\n    throw new SyntaxError('Bad execution tree');\n  }\n  let scope = context.ctx.globalScope;\n  let s;\n  while ((s = scopes.shift())) {\n    if (typeof s !== 'object') continue;\n    if (s instanceof Scope) {\n      scope = s;\n    } else {\n      scope = new Scope(scope, s, s instanceof LocalScope ? undefined : null);\n    }\n  }\n  if (context.ctx.options.audit && !context.ctx.auditReport) {\n    context.ctx.auditReport = {\n      globalsAccess: new Set(),\n      prototypeAccess: {},\n    };\n  }\n  if (exec === execSync) {\n    _executeWithDoneSync(done, ticks, context, executionTree, scope, inLoopOrSwitch);\n  } else {\n    _executeWithDoneAsync(done, ticks, context, executionTree, scope, inLoopOrSwitch).catch(done);\n  }\n}\n\nfunction _executeWithDoneSync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string,\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      execSync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch,\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n\nasync function _executeWithDoneAsync(\n  done: Done,\n  ticks: Ticks,\n  context: IExecContext,\n  executionTree: Lisp[],\n  scope: Scope,\n  inLoopOrSwitch?: string,\n) {\n  if (!(executionTree instanceof Array)) throw new SyntaxError('Bad execution tree');\n  let i = 0;\n  for (i = 0; i < executionTree.length; i++) {\n    let res: unknown;\n    let err: unknown;\n    const current = executionTree[i];\n    try {\n      await execAsync(\n        ticks,\n        current,\n        scope,\n        context,\n        (e, r) => {\n          err = e;\n          res = r;\n        },\n        inLoopOrSwitch,\n      );\n    } catch (e) {\n      err = e;\n    }\n    if (err) {\n      done(err);\n      return;\n    }\n    if (res instanceof ExecReturn) {\n      done(undefined, res);\n      return;\n    }\n    if (isLisp(current) && current[0] === LispType.Return) {\n      done(undefined, new ExecReturn(context.ctx.auditReport, res, true));\n      return;\n    }\n  }\n  done(undefined, new ExecReturn(context.ctx.auditReport, undefined, false));\n}\n"],"names":[],"mappings":"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"}