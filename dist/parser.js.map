{"version":3,"file":"parser.js","sources":["../src/unraw.ts","../src/parser.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex: string, errorName: string, enforcedLength?: number): number {\n  const parsedHex = parseHexToInt(hex);\n  if (Number.isNaN(parsedHex) || (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Hexadecimal', 2);\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(surrogateCode, 'Malformed Unicode', 4);\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === '{' && text.charAt(text.length - 1) === '}';\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(withoutBraces, 'Malformed Unicode');\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError ? new SyntaxError('Code Point Limit:' + parsedCode) : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  ['b', '\\b'],\n  ['f', '\\f'],\n  ['n', '\\n'],\n  ['r', '\\r'],\n  ['t', '\\t'],\n  ['v', '\\v'],\n  ['0', '\\0'],\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch =\n  /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(\n    escapeMatch,\n    function (\n      _,\n      backslash?: string,\n      hex?: string,\n      codePoint?: string,\n      unicodeWithSurrogate?: string,\n      surrogate?: string,\n      unicode?: string,\n      octal?: string,\n      singleCharacter?: string\n    ): string {\n      // Compare groups to undefined because empty strings mean different errors\n      // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n      if (backslash !== undefined) {\n        return '\\\\';\n      }\n      if (hex !== undefined) {\n        return parseHexadecimalCode(hex);\n      }\n      if (codePoint !== undefined) {\n        return parseUnicodeCodePointCode(codePoint);\n      }\n      if (unicodeWithSurrogate !== undefined) {\n        return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n      }\n      if (unicode !== undefined) {\n        return parseUnicodeCode(unicode);\n      }\n      if (octal === '0') {\n        return '\\0';\n      }\n      if (octal !== undefined) {\n        throw new SyntaxError('Octal Deprecation: ' + octal);\n      }\n      if (singleCharacter !== undefined) {\n        return parseSingleCharacterCode(singleCharacter);\n      }\n      throw new SyntaxError('End of string');\n    }\n  );\n}\nexport default unraw;\n","import unraw from './unraw.js';\nimport { CodeString, isLisp, LispType } from './utils.js';\n\nexport type DefineLisp<\n  op extends LispType,\n  a extends LispItem | LispItem,\n  b extends LispItem | LispItem\n> = [op, a, b];\n\nexport type ExtractLispOp<L> = L extends DefineLisp<infer i, any, any> ? i : never;\nexport type ExtractLispA<L> = L extends DefineLisp<any, infer i, any> ? i : never;\nexport type ExtractLispB<L> = L extends DefineLisp<any, any, infer i> ? i : never;\n\nexport type LispItemSingle = LispType.None | LispType.True | string | Lisp;\nexport type LispItem = LispItemSingle | LispItemSingle[];\nexport type Lisp = [LispType, LispItem, LispItem];\n\nfunction createLisp<L extends Lisp>(obj: {\n  op: ExtractLispOp<L>;\n  a: ExtractLispA<L>;\n  b: ExtractLispB<L>;\n}) {\n  return [obj.op, obj.a, obj.b] as L;\n}\n\nconst NullLisp = createLisp<None>({ op: LispType.None, a: LispType.None, b: LispType.None });\n\nexport type Literal = DefineLisp<LispType.Literal, string, Lisp[]> & { tempJsStrings?: string[] };\nexport type If = DefineLisp<LispType.If, Lisp, IfCase>;\nexport type InlineIf = DefineLisp<LispType.InlineIf, Lisp, InlineIfCase>;\nexport type IfCase = DefineLisp<LispType.IfCase, Lisp[], Lisp[]>;\nexport type InlineIfCase = DefineLisp<LispType.InlineIfCase, Lisp, Lisp>;\nexport type KeyVal = DefineLisp<LispType.KeyVal, string | Lisp, Lisp>;\nexport type SpreadObject = DefineLisp<LispType.SpreadObject, LispType.None, Lisp>;\nexport type SpreadArray = DefineLisp<LispType.SpreadArray, LispType.None, Lisp>;\nexport type ArrayProp = DefineLisp<LispType.ArrayProp, Lisp, Lisp>;\nexport type Prop = DefineLisp<LispType.Prop, Lisp, string | Lisp>;\nexport type PropOptional = DefineLisp<LispType.PropOptional, Lisp, Lisp[]>;\nexport type Call = DefineLisp<LispType.Call, Lisp, Lisp[]>;\nexport type CallOptional = DefineLisp<LispType.CallOptional, Lisp, Lisp[]>;\nexport type CreateArray = DefineLisp<LispType.CreateArray, Lisp, Lisp[]>;\nexport type CreateObject = DefineLisp<LispType.CreateObject, Lisp, Lisp[]>;\nexport type Group = DefineLisp<LispType.Group, Lisp, Lisp[]>;\nexport type Inverse = DefineLisp<LispType.Inverse, Lisp, Lisp>;\nexport type Not = DefineLisp<LispType.Not, Lisp, Lisp>;\nexport type Negative = DefineLisp<LispType.Negative, Lisp, Lisp>;\nexport type Positive = DefineLisp<LispType.Positive, Lisp, Lisp>;\nexport type Typeof = DefineLisp<LispType.Typeof, Lisp, Lisp>;\nexport type Delete = DefineLisp<LispType.Delete, Lisp, Lisp>;\nexport type IncrementBefore = DefineLisp<LispType.IncrementBefore, Lisp, LispType.None>;\nexport type IncrementAfter = DefineLisp<LispType.IncrementAfter, Lisp, LispType.None>;\nexport type DecrementBefore = DefineLisp<LispType.DecrementBefore, Lisp, LispType.None>;\nexport type DecrementAfter = DefineLisp<LispType.DecrementAfter, Lisp, LispType.None>;\n\nexport type And = DefineLisp<LispType.And, Lisp, Lisp>;\nexport type Or = DefineLisp<LispType.Or, Lisp, Lisp>;\nexport type Instanceof = DefineLisp<LispType.Instanceof, Lisp, Lisp>;\nexport type In = DefineLisp<LispType.In, Lisp, Lisp>;\nexport type Assigns = DefineLisp<LispType.Assign, Lisp, Lisp>;\nexport type SubractEquals = DefineLisp<LispType.SubractEquals, Lisp, Lisp>;\nexport type AddEquals = DefineLisp<LispType.AddEquals, Lisp, Lisp>;\nexport type DivideEquals = DefineLisp<LispType.DivideEquals, Lisp, Lisp>;\nexport type PowerEquals = DefineLisp<LispType.PowerEquals, Lisp, Lisp>;\nexport type MultiplyEquals = DefineLisp<LispType.MultiplyEquals, Lisp, Lisp>;\nexport type ModulusEquals = DefineLisp<LispType.ModulusEquals, Lisp, Lisp>;\nexport type BitNegateEquals = DefineLisp<LispType.BitNegateEquals, Lisp, Lisp>;\nexport type BitAndEquals = DefineLisp<LispType.BitAndEquals, Lisp, Lisp>;\nexport type BitOrEquals = DefineLisp<LispType.BitOrEquals, Lisp, Lisp>;\nexport type UnsignedShiftRightEquals = DefineLisp<LispType.UnsignedShiftRightEquals, Lisp, Lisp>;\nexport type ShiftLeftEquals = DefineLisp<LispType.ShiftLeftEquals, Lisp, Lisp>;\nexport type ShiftRightEquals = DefineLisp<LispType.ShiftRightEquals, Lisp, Lisp>;\n\nexport type BitAnd = DefineLisp<LispType.BitAnd, Lisp, Lisp>;\nexport type BitOr = DefineLisp<LispType.BitOr, Lisp, Lisp>;\nexport type BitNegate = DefineLisp<LispType.BitNegate, Lisp, Lisp>;\nexport type BitShiftLeft = DefineLisp<LispType.BitShiftLeft, Lisp, Lisp>;\nexport type BitShiftRight = DefineLisp<LispType.BitShiftRight, Lisp, Lisp>;\nexport type BitUnsignedShiftRight = DefineLisp<LispType.BitUnsignedShiftRight, Lisp, Lisp>;\nexport type SmallerEqualThan = DefineLisp<LispType.SmallerEqualThan, Lisp, Lisp>;\nexport type LargerEqualThan = DefineLisp<LispType.LargerEqualThan, Lisp, Lisp>;\nexport type SmallerThan = DefineLisp<LispType.SmallerThan, Lisp, Lisp>;\nexport type LargerThan = DefineLisp<LispType.LargerThan, Lisp, Lisp>;\nexport type StrictNotEqual = DefineLisp<LispType.StrictNotEqual, Lisp, Lisp>;\nexport type NotEqual = DefineLisp<LispType.NotEqual, Lisp, Lisp>;\nexport type StrictEqual = DefineLisp<LispType.StrictEqual, Lisp, Lisp>;\nexport type Equal = DefineLisp<LispType.Equal, Lisp, Lisp>;\nexport type Plus = DefineLisp<LispType.Plus, Lisp, Lisp>;\nexport type Minus = DefineLisp<LispType.Minus, Lisp, Lisp>;\nexport type Divide = DefineLisp<LispType.Divide, Lisp, Lisp>;\nexport type Power = DefineLisp<LispType.Power, Lisp, Lisp>;\nexport type Multiply = DefineLisp<LispType.Multiply, Lisp, Lisp>;\nexport type Modulus = DefineLisp<LispType.Modulus, Lisp, Lisp>;\n\nexport type Block = DefineLisp<LispType.Block, Lisp[], LispType.None>;\nexport type Expression = DefineLisp<LispType.Expression, Lisp[], LispType.None>;\nexport type Return = DefineLisp<LispType.Return, LispType.None, Lisp>;\nexport type Throw = DefineLisp<LispType.Throw, LispType.None, Lisp>;\nexport type Switch = DefineLisp<LispType.Switch, Lisp, SwitchCase[]>;\nexport type SwitchCase = DefineLisp<LispType.SwitchCase, LispType.None | Lisp, Lisp[]>;\nexport type Var = DefineLisp<LispType.Var, string, Lisp | LispType.None>;\nexport type Let = DefineLisp<LispType.Let, string, Lisp | LispType.None>;\nexport type Const = DefineLisp<LispType.Const, string, Lisp | LispType.None>;\n\nexport type Number = DefineLisp<LispType.Number, LispType.None, string>;\nexport type BigInt = DefineLisp<LispType.BigInt, LispType.None, string>;\nexport type GlobalSymbol = DefineLisp<LispType.GlobalSymbol, LispType.None, string>;\nexport type LiteralIndex = DefineLisp<LispType.LiteralIndex, LispType.None, string>;\nexport type StringIndex = DefineLisp<LispType.StringIndex, LispType.None, string>;\nexport type RegexIndex = DefineLisp<LispType.RegexIndex, LispType.None, string>;\n\nexport type Function = DefineLisp<\n  LispType.Function,\n  (string | LispType.None | LispType.True)[],\n  string | Lisp[]\n>;\nexport type InlineFunction = DefineLisp<LispType.InlineFunction, string[], string | Lisp[]>;\nexport type ArrowFunction = DefineLisp<LispType.ArrowFunction, string[], string | Lisp[]>;\nexport type Loop = DefineLisp<LispType.Loop, LispItem, Lisp[]>;\nexport type LoopAction = DefineLisp<LispType.LoopAction, string, LispType.None>;\nexport type Try = DefineLisp<LispType.Try, Lisp[], LispItem>;\n\nexport type Void = DefineLisp<LispType.Void, Lisp, LispType.None>;\nexport type Await = DefineLisp<LispType.Await, Lisp, LispType.None>;\nexport type New = DefineLisp<LispType.New, Lisp, Lisp[]>;\nexport type None = DefineLisp<LispType.None, LispType.None, LispType.None>;\n\nexport type LispFamily =\n  | Literal\n  | If\n  | InlineIf\n  | IfCase\n  | InlineIfCase\n  | KeyVal\n  | SpreadObject\n  | SpreadArray\n  | ArrayProp\n  | Prop\n  | PropOptional\n  | Call\n  | CallOptional\n  | CreateArray\n  | CreateObject\n  | Group\n  | Inverse\n  | Not\n  | Negative\n  | Positive\n  | Typeof\n  | Delete\n  | IncrementBefore\n  | IncrementAfter\n  | DecrementBefore\n  | DecrementAfter\n  | And\n  | Or\n  | Instanceof\n  | In\n  | Assigns\n  | SubractEquals\n  | AddEquals\n  | DivideEquals\n  | PowerEquals\n  | MultiplyEquals\n  | ModulusEquals\n  | BitNegateEquals\n  | BitAndEquals\n  | BitOrEquals\n  | UnsignedShiftRightEquals\n  | ShiftLeftEquals\n  | ShiftRightEquals\n  | BitAnd\n  | BitOr\n  | BitNegate\n  | BitShiftLeft\n  | BitShiftRight\n  | BitUnsignedShiftRight\n  | SmallerEqualThan\n  | LargerEqualThan\n  | SmallerThan\n  | LargerThan\n  | StrictNotEqual\n  | NotEqual\n  | StrictEqual\n  | Equal\n  | Plus\n  | Minus\n  | Divide\n  | Power\n  | Multiply\n  | Modulus\n  | Block\n  | Expression\n  | Return\n  | Throw\n  | Switch\n  | SwitchCase\n  | Var\n  | Let\n  | Const\n  | Number\n  | BigInt\n  | GlobalSymbol\n  | LiteralIndex\n  | StringIndex\n  | RegexIndex\n  | Function\n  | InlineFunction\n  | ArrowFunction\n  | Loop\n  | LoopAction\n  | Try\n  | Void\n  | Await\n  | New\n  | None;\n\nexport interface IRegEx {\n  regex: string;\n  flags: string;\n  length: number;\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: Literal[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: Lisp[];\n  constants: IConstants;\n}\n\ntype LispCallback<T> = (\n  strings: IConstants,\n  type: T,\n  part: CodeString,\n  res: string[],\n  expect: string,\n  ctx: { lispTree: Lisp }\n) => any;\nconst lispTypes: Map<string, LispCallback<string>> = new Map();\n\nexport class ParseError extends Error {\n  constructor(message: string, public code: string) {\n    super(message + ': ' + code.substring(0, 40));\n  }\n}\n\nlet lastType: CodeString | string;\nlet lastPart: CodeString | string;\nlet lastLastPart: CodeString | string;\nlet lastLastLastPart: CodeString | string;\nlet lastLastLastLastPart: CodeString | string;\n\nconst inlineIfElse = /^:/;\nconst elseIf = /^else(?![\\w$])/;\nconst ifElse = /^if(?![\\w$])/;\nconst space = /^\\s/;\n\nexport const expectTypes = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|%)(?!=)/,\n      op: /^(\\+(?!(\\+))|-(?!(-)))(?!=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!=)|===|==)/,\n      boolOp: /^(&&|\\|\\||instanceof(?![\\w$])|in(?![\\w$]))/,\n      bitwise: /^(&(?!&)|\\|(?!\\|)|\\^|<<|>>(?!>)|>>>)(?!=)/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: ['expEnd'],\n  },\n  assignment: {\n    types: {\n      assignModify: /^(-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  incrementerBefore: {\n    types: { incrementerBefore: /^(\\+\\+|--)/ },\n    next: ['prop'],\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[(]/,\n      incrementerAfter: /^(\\+\\+|--)/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^-(?!-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w$])/,\n      delete: /^delete(?![\\w$])/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z$_])/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z$_][a-zA-Z\\d$_]*/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number:\n        /^(0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[+-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w$])/,\n      boolean: /^(true|false)(?![\\w$])/,\n      null: /^null(?![\\w$])/,\n      und: /^undefined(?![\\w$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*=>\\s*({)?/,\n      arrowFunction:\n        /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w$])/,\n      Infinity: /^Infinity(?![\\w$])/,\n      void: /^void(?![\\w$])\\s*/,\n      await: /^await(?![\\w$])\\s*/,\n      new: /^new(?![\\w$])\\s*/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*(=)?/,\n      return: /^return(?![\\w$])/,\n      throw: /^throw(?![\\w$])\\s*/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore', 'expEnd'],\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  expEnd: { types: {}, next: [] },\n  expFunction: {\n    types: {\n      function:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: ['expEdge', 'expEnd'],\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*do(?![\\w$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w$])\\s*([a-zA-Z$_][\\w$]*)?/,\n      if: /^((([a-zA-Z$_][\\w$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: ['expEnd'],\n  },\n} as Record<string, { types: Record<string, RegExp>; next: string[] }>;\n\nconst closings = {\n  '(': ')',\n  '[': ']',\n  '{': '}',\n  \"'\": \"'\",\n  '\"': '\"',\n  '`': '`',\n} as Record<string, string>;\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray | null = null;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nconst emptyString = new CodeString('');\n\nconst okFirstChars = /^[+\\-~ !]/;\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w$])|[\\w$]+)/;\nconst semiColon = /^;/;\nconst insertedSemicolons: WeakMap<{ str: string }, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{ str: string }, Map<number, number>> = new WeakMap();\nexport interface restDetails {\n  oneliner?: boolean;\n  words?: string[];\n  lastWord?: string;\n  lastAnyWord?: string;\n  regRes?: RegExpExecArray;\n}\nexport function restOfExp(\n  constants: IConstants,\n  part: CodeString,\n  tests?: RegExp[],\n  quote?: string,\n  firstOpening?: string,\n  closingsTests?: RegExp[],\n  details: restDetails = {}\n): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1)! - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = '';\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i)!;\n    if (quote === '\"' || quote === \"'\" || quote === '`') {\n      if (quote === '`' && char === '$' && part.char(i + 1) === '{' && !escape) {\n        const skip = restOfExp(constants, part.substring(i + 2), [], '{');\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === '\\\\';\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true;\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === '{') {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        const skip = restOfExp(constants, part.substring(i + 1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          const sub = part.substring(i);\n          let found: RegExpExecArray | null;\n          if ((found = testMultiple(sub.toString(), closingsTests))) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray | null;\n      let foundNumber: RegExpExecArray | null;\n      if (closingsTests) {\n        let found: RegExpExecArray | null;\n        if ((found = testMultiple(sub, closingsTests))) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if ((foundNumber = aNumber.exec(sub))) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string] | RegExpExecArray | null = null;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [';'];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true;\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if (foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if (char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = ['splitter', 'expEnd', 'inlineIf'];\n\nconst startingExecpted = [\n  'initialize',\n  'expSingle',\n  'expFunction',\n  'value',\n  'modifier',\n  'prop',\n  'incrementerBefore',\n  'expEnd',\n];\n\nexport const setLispType = <T extends readonly string[]>(types: T, fn: LispCallback<T[number]>) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  });\n};\n\nconst closingsCreate: { [type: string]: RegExp } = {\n  createArray: /^\\]/,\n  createObject: /^\\}/,\n  group: /^\\)/,\n  arrayProp: /^\\]/,\n  call: /^\\)/,\n};\n\nconst typesCreate = {\n  createArray: LispType.CreateArray,\n  createObject: LispType.CreateObject,\n  group: LispType.Group,\n  arrayProp: LispType.ArrayProp,\n  call: LispType.Call,\n  prop: LispType.Prop,\n  '?prop': LispType.PropOptional,\n  '?call': LispType.CallOptional,\n} as any;\n\nsetLispType(\n  ['createArray', 'createObject', 'group', 'arrayProp', 'call'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    let extract = emptyString;\n    const arg: CodeString[] = [];\n    let end = false;\n    let i = res[0].length;\n    const start = i;\n    while (i < part.length && !end) {\n      extract = restOfExp(constants, part.substring(i), [closingsCreate[type], /^,/]);\n      i += extract.length;\n      if (extract.trim().length) {\n        arg.push(extract);\n      }\n      if (part.char(i) !== ',') {\n        end = true;\n      } else {\n        i++;\n      }\n    }\n    const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n    let l: Lisp | Lisp[];\n\n    let funcFound: RegExpExecArray | null;\n    switch (type) {\n      case 'group':\n      case 'arrayProp':\n        l = lispifyExpr(constants, part.substring(start, i));\n        break;\n      case 'call':\n      case 'createArray':\n        // @TODO: support 'empty' values\n        l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n        break;\n      case 'createObject':\n        l = arg.map((str) => {\n          str = str.trimStart();\n          let value: Lisp;\n          let key: string | Lisp = '';\n          funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n          if (funcFound) {\n            key = funcFound[2].trimStart();\n            value = lispify(\n              constants,\n              new CodeString('function ' + str.toString().replace(key, ''))\n            );\n          } else {\n            const extract = restOfExp(constants, str, [/^:/]);\n            key = lispify(constants, extract, [...next, 'spreadObject']) as Prop;\n            if (key[0] === LispType.Prop) {\n              key = (key as Prop)[2];\n            }\n            value = lispify(constants, str.substring(extract.length + 1));\n          }\n          return createLisp<KeyVal>({\n            op: LispType.KeyVal,\n            a: key,\n            b: value,\n          });\n        });\n        break;\n    }\n    const lisptype = (\n      type === 'arrayProp'\n        ? res[1]\n          ? LispType.PropOptional\n          : LispType.Prop\n        : type === 'call'\n        ? res[1]\n          ? LispType.CallOptional\n          : LispType.Call\n        : typesCreate[type]\n    ) as (typeof typesCreate)[keyof typeof typesCreate];\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(i + 1),\n      expectTypes[expect].next,\n      createLisp<\n        ArrayProp | Prop | Call | CreateObject | CreateArray | Group | PropOptional | CallOptional\n      >({\n        op: lisptype,\n        a: ctx.lispTree,\n        b: l,\n      })\n    );\n  }\n);\n\nconst modifierTypes = {\n  inverse: LispType.Inverse,\n  not: LispType.Not,\n  positive: LispType.Positive,\n  negative: LispType.Negative,\n  typeof: LispType.Typeof,\n  delete: LispType.Delete,\n} as const;\n\nsetLispType(\n  ['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<Inverse | Not | Negative | Positive | Typeof | Delete>({\n        op: modifierTypes[type],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      })\n    );\n  }\n);\n\nconst incrementTypes = {\n  '++$': LispType.IncrementBefore,\n  '--$': LispType.DecrementBefore,\n  '$++': LispType.IncrementAfter,\n  '$--': LispType.DecrementAfter,\n} as any;\n\nsetLispType(['incrementerBefore'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(2), [/^[^\\s.\\w$]/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + 2),\n    restOfExp.next,\n    createLisp<IncrementBefore | DecrementBefore>({\n      op: incrementTypes[res[0] + '$'],\n      a: lispify(constants, extract, expectTypes[expect].next),\n      b: LispType.None,\n    })\n  );\n});\n\nsetLispType(['incrementerAfter'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<IncrementAfter | DecrementAfter>({\n      op: incrementTypes['$' + res[0]],\n      a: ctx.lispTree,\n      b: LispType.None,\n    })\n  );\n});\n\nconst adderTypes = {\n  '&&': LispType.And,\n  '||': LispType.Or,\n  instanceof: LispType.Instanceof,\n  in: LispType.In,\n  '=': LispType.Assign,\n  '-=': LispType.SubractEquals,\n  '+=': LispType.AddEquals,\n  '/=': LispType.DivideEquals,\n  '**=': LispType.PowerEquals,\n  '*=': LispType.MultiplyEquals,\n  '%=': LispType.ModulusEquals,\n  '^=': LispType.BitNegateEquals,\n  '&=': LispType.BitAndEquals,\n  '|=': LispType.BitOrEquals,\n  '>>>=': LispType.UnsignedShiftRightEquals,\n  '<<=': LispType.ShiftLeftEquals,\n  '>>=': LispType.ShiftRightEquals,\n} as any;\n\nsetLispType(\n  ['assign', 'assignModify', 'boolOp'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = createLisp<\n      | And\n      | Or\n      | Instanceof\n      | In\n      | Assigns\n      | SubractEquals\n      | AddEquals\n      | DivideEquals\n      | PowerEquals\n      | MultiplyEquals\n      | ModulusEquals\n      | BitNegateEquals\n      | BitAndEquals\n      | BitOrEquals\n      | UnsignedShiftRightEquals\n      | ShiftLeftEquals\n      | ShiftRightEquals\n    >({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  }\n);\n\nconst opTypes = {\n  '&': LispType.BitAnd,\n  '|': LispType.BitOr,\n  '^': LispType.BitNegate,\n  '<<': LispType.BitShiftLeft,\n  '>>': LispType.BitShiftRight,\n  '>>>': LispType.BitUnsignedShiftRight,\n  '<=': LispType.SmallerEqualThan,\n  '>=': LispType.LargerEqualThan,\n  '<': LispType.SmallerThan,\n  '>': LispType.LargerThan,\n  '!==': LispType.StrictNotEqual,\n  '!=': LispType.NotEqual,\n  '===': LispType.StrictEqual,\n  '==': LispType.Equal,\n  '+': LispType.Plus,\n  '-': LispType.Minus,\n  '/': LispType.Divide,\n  '**': LispType.Power,\n  '*': LispType.Multiply,\n  '%': LispType.Modulus,\n} as any;\n\nsetLispType(\n  ['opHigh', 'op', 'comparitor', 'bitwise'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const next = [expectTypes.inlineIf.types.inlineIf, inlineIfElse];\n    switch (type) {\n      case 'opHigh':\n        next.push(expectTypes.splitter.types.opHigh);\n      case 'op':\n        next.push(expectTypes.splitter.types.op);\n      case 'comparitor':\n        next.push(expectTypes.splitter.types.comparitor);\n      case 'bitwise':\n        next.push(expectTypes.splitter.types.bitwise);\n        next.push(expectTypes.splitter.types.boolOp);\n    }\n    const extract = restOfExp(constants, part.substring(res[0].length), next);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<\n        | BitAnd\n        | BitOr\n        | BitNegate\n        | BitShiftLeft\n        | BitShiftRight\n        | BitUnsignedShiftRight\n        | SmallerEqualThan\n        | LargerEqualThan\n        | SmallerThan\n        | LargerThan\n        | StrictNotEqual\n        | NotEqual\n        | StrictEqual\n        | Equal\n        | Plus\n        | Minus\n        | Divide\n        | Power\n        | Multiply\n        | Modulus\n      >({\n        op: opTypes[res[0]],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      })\n    );\n  }\n);\n\nsetLispType(['inlineIf'] as const, (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  const extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while (!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse,\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++;\n    } else {\n      quoteCount--;\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = createLisp<InlineIf>({\n    op: LispType.InlineIf,\n    a: ctx.lispTree,\n    b: createLisp<InlineIfCase>({\n      op: LispType.InlineIfCase,\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1)),\n    }),\n  });\n});\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString | undefined;\n  let first = true;\n  let elseReg: RegExpExecArray | null;\n  let details: restDetails = {};\n  while (\n    (found = restOfExp(\n      constants,\n      part.substring(found.end - part.start),\n      [elseIf, ifElse, semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details\n    )).length ||\n    first\n  ) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n\n    if (f.startsWith('if')) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if ((elseReg = /^;?\\s*else(?![\\w$])/.exec(f))) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      const ie = extractIfElse(\n        constants,\n        part.substring(found.end - part.start + (/^;?\\s*else(?![\\w$])/.exec(f)?.[0].length || 0))\n      );\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {\n    all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start),\n    true: foundTrue,\n    false: foundElse,\n  };\n}\n\nsetLispType(['if'] as const, (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], '(');\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n\n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n\n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === '{') trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === '{') elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = createLisp<If>({\n    op: LispType.If,\n    a: lispifyExpr(constants, condition),\n    b: createLisp<IfCase>({\n      op: LispType.IfCase,\n      a: lispifyBlock(trueBlock, constants),\n      b: lispifyBlock(elseBlock, constants),\n    }),\n  });\n});\n\nsetLispType(['switch'] as const, (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], '(');\n  let start = part.toString().indexOf('{', res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError('Invalid switch');\n  let statement = insertSemicolons(\n    constants,\n    restOfExp(constants, part.substring(start + 1), [], '{')\n  );\n  let caseFound: RegExpExecArray | null;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  const cases: SwitchCase[] = [];\n  let defaultFound = false;\n  while ((caseFound = caseTest.exec(statement.toString()))) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError('Only one default switch case allowed');\n      defaultFound = true;\n    }\n    const cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = (start = caseFound[0].length + cond.length + 1);\n    const bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs: Lisp[] = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], '{');\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      const notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while ((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(\n      createLisp<SwitchCase>({\n        op: LispType.SwitchCase,\n        a: caseFound[1] === 'default' ? LispType.None : lispifyExpr(constants, cond),\n        b: exprs,\n      })\n    );\n  }\n  ctx.lispTree = createLisp<Switch>({\n    op: LispType.Switch,\n    a: lispifyExpr(constants, test),\n    b: cases,\n  });\n});\n\nsetLispType(['dot', 'prop'] as const, (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    const matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length;\n    } else {\n      throw new SyntaxError('Hanging  dot');\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(index),\n    expectTypes[expect].next,\n    createLisp<Prop | PropOptional>({\n      op: typesCreate[op],\n      a: ctx.lispTree,\n      b: prop,\n    })\n  );\n});\n\nsetLispType(['spreadArray', 'spreadObject'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<SpreadArray | SpreadObject>({\n    op: type === 'spreadArray' ? LispType.SpreadArray : LispType.SpreadObject,\n    a: LispType.None,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n  });\n});\n\nsetLispType(['return', 'throw'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Return | Throw>({\n    op: type === 'return' ? LispType.Return : LispType.Throw,\n    a: LispType.None,\n    b: lispifyExpr(constants, part.substring(res[0].length)),\n  });\n});\n\nsetLispType(\n  ['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Number | BigInt | GlobalSymbol>({\n        op:\n          type === 'number' ? (res[10] ? LispType.BigInt : LispType.Number) : LispType.GlobalSymbol,\n        a: LispType.None,\n        b: res[10] ? res[1] : res[0],\n      })\n    );\n  }\n);\n\nsetLispType(['string', 'literal', 'regex'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<StringIndex | LiteralIndex | RegexIndex>({\n      op:\n        type === 'string'\n          ? LispType.StringIndex\n          : type === 'literal'\n          ? LispType.LiteralIndex\n          : LispType.RegexIndex,\n      a: LispType.None,\n      b: res[1],\n    })\n  );\n});\n\nsetLispType(['initialize'] as const, (constants, type, part, res, expect, ctx) => {\n  const lt = res[1] === 'var' ? LispType.Var : res[1] === 'let' ? LispType.Let : LispType.Const;\n  if (!res[3]) {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Var | Let | Const>({\n        op: lt,\n        a: res[2],\n        b: LispType.None,\n      })\n    );\n  } else {\n    ctx.lispTree = createLisp<Var | Let | Const>({\n      op: lt,\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  }\n});\n\nsetLispType(\n  ['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const isArrow = type !== 'function' && type !== 'inlineFunction';\n    const isReturn = isArrow && !res[res.length - 1];\n    const argPos = isArrow ? 2 : 3;\n    const isAsync = res[1] ? LispType.True : LispType.None;\n    const args: string[] = res[argPos] ? res[argPos].replace(/\\s+/g, '').split(/,/g) : [];\n    if (!isArrow) {\n      args.unshift((res[2] || '').trimStart());\n    }\n    let ended = false;\n    args.forEach((arg: string) => {\n      if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n      if (arg.startsWith('...')) ended = true;\n    });\n    const f = restOfExp(\n      constants,\n      part.substring(res[0].length),\n      !isReturn ? [/^}/] : [/^[,)}\\]]/, semiColon]\n    );\n    const func = isReturn ? 'return ' + f : f.toString();\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length + func.length + 1),\n      expectTypes[expect].next,\n      createLisp<Function | InlineFunction | ArrowFunction>({\n        op: isArrow\n          ? LispType.ArrowFunction\n          : type === 'function'\n          ? LispType.Function\n          : LispType.InlineFunction,\n        a: [isAsync, ...args],\n        b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func,\n      })\n    );\n  }\n);\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s+(in|of)(?![\\w$])/;\nsetLispType(['for', 'do', 'while'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = LispType.True;\n  let startInternal: Lisp[] = [];\n  let getIterator: Lisp | LispType.None = LispType.None;\n  let beforeStep: LispItem = LispType.None;\n  let checkFirst = LispType.True;\n  let condition: LispItem;\n  let step: LispItem = LispType.True;\n  let body: CodeString;\n  switch (type) {\n    case 'while': {\n      i = part.toString().indexOf('(') + 1;\n      const extract = restOfExp(constants, part.substring(i), [], '(');\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n      break;\n    }\n    case 'for': {\n      i = part.toString().indexOf('(') + 1;\n      const args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++) {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === ')') break;\n      }\n      let iterator: RegExpExecArray | null;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          (getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [ofStart2, ofStart3]);\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$next.value'),\n            ['initialize']\n          );\n        } else {\n          (getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [inStart2, inStart3]);\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'),\n            ['initialize']\n          );\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift()!, startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift()!);\n        step = lispifyExpr(constants, args.shift()!);\n      } else {\n        throw new SyntaxError('Invalid for loop definition');\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n\n      break;\n    }\n    case 'do': {\n      checkFirst = LispType.None;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(\n        constants,\n        restOfExp(\n          constants,\n          part.substring(part.toString().indexOf('(', res[0].length + body.length) + 1),\n          [],\n          '('\n        )\n      );\n      break;\n    }\n  }\n  const a = [\n    checkFirst,\n    startInternal,\n    getIterator,\n    startStep,\n    step,\n    condition,\n    beforeStep,\n  ] as LispItem;\n  ctx.lispTree = createLisp<Loop>({\n    op: LispType.Loop,\n    a,\n    b: lispifyBlock(body, constants),\n  });\n});\n\nsetLispType(['block'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Block>({\n    op: LispType.Block,\n    a: lispifyBlock(restOfExp(constants, part.substring(1), [], '{'), constants),\n    b: LispType.None,\n  });\n});\n\nsetLispType(['loopAction'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<LoopAction>({\n    op: LispType.LoopAction,\n    a: res[1],\n    b: LispType.None,\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\))?|finally)\\s*\\{/;\nsetLispType(['try'] as const, (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], '{');\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception = '';\n  let catchBody;\n  let offset = 0;\n  if (catchRes![1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes![2];\n    catchBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{'\n    );\n    offset = res[0].length + body.length + 1 + catchRes![0].length + catchBody.length + 1;\n    if (\n      (catchRes = catchReg.exec(part.substring(offset).toString())) &&\n      catchRes[1].startsWith('finally')\n    ) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], '{');\n    }\n  } else {\n    finallyBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{'\n    );\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ] as LispItem;\n  ctx.lispTree = createLisp<Try>({\n    op: LispType.Try,\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b,\n  });\n});\n\nsetLispType(['void', 'await'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length + extract.length),\n    expectTypes[expect].next,\n    createLisp<Void | Await>({\n      op: type === 'void' ? LispType.Void : LispType.Await,\n      a: lispify(constants, extract),\n      b: LispType.None,\n    })\n  );\n});\n\nsetLispType(['new'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, '(');\n  i += obj.length + 1;\n  const args: CodeString[] = [];\n  if (part.char(i - 1) === '(') {\n    const argsString = restOfExp(constants, part.substring(i), [], '(');\n    i += argsString.length + 1;\n    let found: CodeString;\n    let j = 0;\n    while ((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(i),\n    expectTypes.expEdge.next,\n    createLisp({\n      op: LispType.New,\n      a: lispify(constants, obj, expectTypes.initialize.next),\n      b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n    })\n  );\n});\n\nconst ofStart2 = lispify(\n  undefined as any,\n  new CodeString('let $$iterator = $$obj[Symbol.iterator]()'),\n  ['initialize']\n);\nconst ofStart3 = lispify(undefined as any, new CodeString('let $$next = $$iterator.next()'), [\n  'initialize',\n]);\nconst ofCondition = lispify(undefined as any, new CodeString('return !$$next.done'), [\n  'initialize',\n]);\nconst ofStep = lispify(undefined as any, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined as any, new CodeString('let $$keys = Object.keys($$obj)'), [\n  'initialize',\n]);\nconst inStart3 = lispify(undefined as any, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined as any, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined as any, new CodeString('return $$keyIndex < $$keys.length'), [\n  'initialize',\n]);\n\nfunction lispify(\n  constants: IConstants,\n  part: CodeString,\n  expected?: readonly string[],\n  lispTree?: Lisp,\n  topLevel = false\n): Lisp {\n  lispTree = lispTree || NullLisp;\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError('Unexpected end of expression');\n  }\n  if (!part.length) return lispTree;\n\n  const ctx = { lispTree: lispTree };\n\n  let res: any;\n  for (const expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (const type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if ((res = expectTypes[expect].types[type].exec(str))) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)?.(constants, type, part, res, expect, ctx);\n        } catch (e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: readonly string[]): Lisp {\n  if (!str.trimStart().length) return NullLisp;\n  const subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    const defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return createLisp<Block>({\n        op: LispType.Block,\n        a: subExpressions.map((str, i) =>\n          lispify(\n            constants,\n            i ? new CodeString(defined![1] + ' ' + str) : str,\n            ['initialize'],\n            undefined,\n            true\n          )\n        ),\n        b: LispType.None,\n      });\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = subExpressions.map((str) => lispify(constants, str, expected, undefined, true));\n  return createLisp<Expression>({ op: LispType.Expression, a: exprs, b: LispType.None });\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return createLisp<Return>({\n    op: LispType.Return,\n    a: LispType.None,\n    b: lispifyExpr(constants, str),\n  });\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return [];\n  const parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while (\n    (part = restOfExp(\n      constants,\n      str.substring(pos),\n      [semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details\n    )).length\n  ) {\n    isInserted = !!(str.char(pos + part.length) && str.char(pos + part.length) !== ';');\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (\n      details['words']?.includes('do') &&\n      /^\\s*while(?![\\w$])/.test(str.substring(pos).toString())\n    ) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return parts\n    .map((str) => str.trimStart())\n    .filter((str) => str.length)\n    .map((str) => {\n      return lispifyExpr(constants, str.trimStart(), startingExecpted);\n    });\n}\n\nexport function lispifyFunction(\n  str: CodeString,\n  constants: IConstants,\n  expression = false\n): Lisp[] {\n  if (!str.trim().length) return [];\n  const tree = lispifyBlock(str, constants, expression);\n  hoist(tree);\n  return tree;\n}\n\nfunction hoist(item: LispItem, res: Lisp[] = []): boolean {\n  if (isLisp(item)) {\n    if (!isLisp<LispFamily>(item)) return false;\n    const [op, a, b] = item;\n    if (\n      op === LispType.Try ||\n      op === LispType.If ||\n      op === LispType.Loop ||\n      op === LispType.Switch\n    ) {\n      hoist(a, res);\n      hoist(b, res);\n    } else if (op === LispType.Var) {\n      res.push(createLisp({ op: LispType.Var, a: a, b: LispType.None }));\n    } else if (op === LispType.Function && a[1]) {\n      res.push(item);\n      return true;\n    }\n  } else if (Array.isArray(item)) {\n    const rep: LispItemSingle[] = [];\n    for (const it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...res, ...rep);\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w$])/;\n//  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5\nconst colonsRegex = /^((([\\w$\\])\"'`]|\\+\\+|--)\\s*\\r?\\n\\s*([\\w$+\\-!~]))|(\\}\\s*[\\w$!~+\\-{(\"'`]))/;\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while (\n    (sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length\n  ) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [, , a, , , b] = details.regRes;\n      edge = details.regRes[3] === '++' || details.regRes[3] === '--' ? sub.length + 1 : sub.length;\n      part = rest.substring(0, edge);\n      if (b) {\n        const res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (\n          details.lastWord === 'function' &&\n          details.regRes[5][0] === '}' &&\n          details.regRes[5].slice(-1) === '('\n        ) {\n          valid = false;\n        }\n      } else if (a) {\n        if (\n          details.lastWord === 'if' ||\n          details.lastWord === 'while' ||\n          details.lastWord === 'for' ||\n          details.lastWord === 'else'\n        ) {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = str[i] === '/' && !escape;\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  const after = str.substring(i);\n  cancel = cancel || !done || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  const flags = /^[a-z]*/.exec(after);\n  if (/^\\s+[\\w$]/.test(str.substring(i + flags![0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i - 1),\n    flags: (flags && flags[0]) || '',\n    length: i + ((flags && flags[0].length) || 0),\n  };\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/;\nconst possibleDivide = /^([\\w$\\])]|\\+\\+|--)[\\s/]/;\nexport function extractConstants(\n  constants: IConstants,\n  str: string,\n  currentEnclosure = ''\n): { str: string; length: number } {\n  let quote;\n  let extract: (string | number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx | null;\n  let comment = '';\n  let commentStart = -1;\n  let currJs: string[] = [];\n  let char = '';\n  const strRes: (string | number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray | null = null;\n  let i = 0;\n  for (i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === '*' && str[i + 1] === '/') {\n          comment = '';\n          i++;\n        } else if (comment === '\\n') {\n          comment = '';\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === '`' && char === '$' && str[i + 1] === '{') {\n          const skip = extractConstants(constants, str.substring(i + 2), '{');\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            const li = createLisp<Literal>({\n              op: LispType.Literal,\n              a: unraw(extract.join('')),\n              b: [],\n            });\n            li.tempJsStrings = currJs;\n            constants.literals.push(li);\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join('')));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if (char === \"'\" || char === '\"' || char === '`') {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return { str: strRes.join(''), length: i };\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length - 1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === '/' && (str[i + 1] === '*' || str[i + 1] === '/')) {\n          comment = str[i + 1] === '*' ? '*' : '\\n';\n          commentStart = i;\n        } else if (\n          char === '/' &&\n          !isPossibleDivide &&\n          (regexFound = checkRegex(str.substring(i)))\n        ) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if ((isPossibleDivide = possibleDivide.exec(str.substring(i)))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = !!(quote && char === '\\\\');\n    }\n  }\n\n  if (comment) {\n    if (comment === '*') {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`);\n    }\n  }\n  return { str: strRes.join(''), length: i };\n}\n\nexport default function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = { strings: [], literals: [], regexes: [], eager };\n  str = extractConstants(constants, str).str;\n\n  for (const l of constants.literals) {\n    l[2] = l.tempJsStrings!.map((js: string) => lispifyExpr(constants, new CodeString(js)));\n    delete l.tempJsStrings;\n  }\n  return { tree: lispifyFunction(new CodeString(str), constants, expression), constants };\n}\n"],"names":[],"mappings":"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"}