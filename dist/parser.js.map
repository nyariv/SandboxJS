{"version":3,"file":"parser.js","sources":["../src/unraw.ts","../src/parser.ts"],"sourcesContent":["/**\n * Parse a string as a base-16 number. This is more strict than `parseInt` as it\n * will not allow any other characters, including (for example) \"+\", \"-\", and\n * \".\".\n * @param hex A string containing a hexadecimal number.\n * @returns The parsed integer, or `NaN` if the string is not a valid hex\n * number.\n */\nfunction parseHexToInt(hex: string): number {\n  const isOnlyHexChars = !hex.match(/[^a-f0-9]/i);\n  return isOnlyHexChars ? parseInt(hex, 16) : NaN;\n}\n\n/**\n * Check the validity and length of a hexadecimal code and optionally enforces\n * a specific number of hex digits.\n * @param hex The string to validate and parse.\n * @param errorName The name of the error message to throw a `SyntaxError` with\n * if `hex` is invalid. This is used to index `errorMessages`.\n * @param enforcedLength If provided, will throw an error if `hex` is not\n * exactly this many characters.\n * @returns The parsed hex number as a normal number.\n * @throws {SyntaxError} If the code is not valid.\n */\nfunction validateAndParseHex(hex: string, errorName: string, enforcedLength?: number): number {\n  const parsedHex = parseHexToInt(hex);\n  if (Number.isNaN(parsedHex) || (enforcedLength !== undefined && enforcedLength !== hex.length)) {\n    throw new SyntaxError(errorName + ': ' + hex);\n  }\n  return parsedHex;\n}\n\n/**\n * Parse a two-digit hexadecimal character escape code.\n * @param code The two-digit hexadecimal number that represents the character to\n * output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or is not the right\n * length.\n */\nfunction parseHexadecimalCode(code: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Hexadecimal', 2);\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Parse a four-digit Unicode character escape code.\n * @param code The four-digit unicode number that represents the character to\n * output.\n * @param surrogateCode Optional four-digit unicode surrogate that represents\n * the other half of the character to output.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the codes are not valid hex or are not the right\n * length.\n */\nfunction parseUnicodeCode(code: string, surrogateCode?: string): string {\n  const parsedCode = validateAndParseHex(code, 'Malformed Unicode', 4);\n\n  if (surrogateCode !== undefined) {\n    const parsedSurrogateCode = validateAndParseHex(surrogateCode, 'Malformed Unicode', 4);\n    return String.fromCharCode(parsedCode, parsedSurrogateCode);\n  }\n\n  return String.fromCharCode(parsedCode);\n}\n\n/**\n * Test if the text is surrounded by curly braces (`{}`).\n * @param text Text to check.\n * @returns `true` if the text is in the form `{*}`.\n */\nfunction isCurlyBraced(text: string): boolean {\n  return text.charAt(0) === '{' && text.charAt(text.length - 1) === '}';\n}\n\n/**\n * Parse a Unicode code point character escape code.\n * @param codePoint A unicode escape code point, including the surrounding curly\n * braces.\n * @returns The single character represented by the code.\n * @throws {SyntaxError} If the code is not valid hex or does not have the\n * surrounding curly braces.\n */\nfunction parseUnicodeCodePointCode(codePoint: string): string {\n  if (!isCurlyBraced(codePoint)) {\n    throw new SyntaxError('Malformed Unicode: +' + codePoint);\n  }\n  const withoutBraces = codePoint.slice(1, -1);\n  const parsedCode = validateAndParseHex(withoutBraces, 'Malformed Unicode');\n\n  try {\n    return String.fromCodePoint(parsedCode);\n  } catch (err) {\n    throw err instanceof RangeError ? new SyntaxError('Code Point Limit:' + parsedCode) : err;\n  }\n}\n\n/**\n * Map of unescaped letters to their corresponding special JS escape characters.\n * Intentionally does not include characters that map to themselves like \"\\'\".\n */\nconst singleCharacterEscapes = new Map<string, string>([\n  ['b', '\\b'],\n  ['f', '\\f'],\n  ['n', '\\n'],\n  ['r', '\\r'],\n  ['t', '\\t'],\n  ['v', '\\v'],\n  ['0', '\\0'],\n]);\n\n/**\n * Parse a single character escape sequence and return the matching character.\n * If none is matched, defaults to `code`.\n * @param code A single character code.\n */\nfunction parseSingleCharacterCode(code: string): string {\n  return singleCharacterEscapes.get(code) || code;\n}\n\n/**\n * Matches every escape sequence possible, including invalid ones.\n *\n * All capture groups (described below) are unique (only one will match), except\n * for 4, which can only potentially match if 3 does.\n *\n * **Capture Groups:**\n * 0. A single backslash\n * 1. Hexadecimal code\n * 2. Unicode code point code with surrounding curly braces\n * 3. Unicode escape code with surrogate\n * 4. Surrogate code\n * 5. Unicode escape code without surrogate\n * 6. Octal code _NOTE: includes \"0\"._\n * 7. A single character (will never be \\, x, u, or 0-3)\n */\nconst escapeMatch =\n  /\\\\(?:(\\\\)|x([\\s\\S]{0,2})|u(\\{[^}]*\\}?)|u([\\s\\S]{4})\\\\u([^{][\\s\\S]{0,3})|u([\\s\\S]{0,4})|([0-3]?[0-7]{1,2})|([\\s\\S])|$)/g;\n\n/**\n * Replace raw escape character strings with their escape characters.\n * @param raw A string where escape characters are represented as raw string\n * values like `\\'` rather than `'`.\n * @param allowOctals If `true`, will process the now-deprecated octal escape\n * sequences (ie, `\\111`).\n * @returns The processed string, with escape characters replaced by their\n * respective actual Unicode characters.\n */\nexport function unraw(raw: string): string {\n  return raw.replace(\n    escapeMatch,\n    function (\n      _,\n      backslash?: string,\n      hex?: string,\n      codePoint?: string,\n      unicodeWithSurrogate?: string,\n      surrogate?: string,\n      unicode?: string,\n      octal?: string,\n      singleCharacter?: string,\n    ): string {\n      // Compare groups to undefined because empty strings mean different errors\n      // Otherwise, `\\u` would fail the same as `\\` which is wrong.\n      if (backslash !== undefined) {\n        return '\\\\';\n      }\n      if (hex !== undefined) {\n        return parseHexadecimalCode(hex);\n      }\n      if (codePoint !== undefined) {\n        return parseUnicodeCodePointCode(codePoint);\n      }\n      if (unicodeWithSurrogate !== undefined) {\n        return parseUnicodeCode(unicodeWithSurrogate, surrogate);\n      }\n      if (unicode !== undefined) {\n        return parseUnicodeCode(unicode);\n      }\n      if (octal === '0') {\n        return '\\0';\n      }\n      if (octal !== undefined) {\n        throw new SyntaxError('Octal Deprecation: ' + octal);\n      }\n      if (singleCharacter !== undefined) {\n        return parseSingleCharacterCode(singleCharacter);\n      }\n      throw new SyntaxError('End of string');\n    },\n  );\n}\nexport default unraw;\n","import unraw from './unraw.js';\nimport { CodeString, isLisp, LispType, reservedWords } from './utils.js';\n\nexport type DefineLisp<\n  op extends LispType,\n  a extends LispItem | LispItem,\n  b extends LispItem | LispItem,\n> = [op, a, b];\n\nexport type ExtractLispOp<L> = L extends DefineLisp<infer i, any, any> ? i : never;\nexport type ExtractLispA<L> = L extends DefineLisp<any, infer i, any> ? i : never;\nexport type ExtractLispB<L> = L extends DefineLisp<any, any, infer i> ? i : never;\n\nexport type LispItemSingle = LispType.None | LispType.True | string | Lisp;\nexport type LispItem = LispItemSingle | LispItemSingle[];\nexport type Lisp = [LispType, LispItem, LispItem];\n\nfunction createLisp<L extends Lisp>(obj: {\n  op: ExtractLispOp<L>;\n  a: ExtractLispA<L>;\n  b: ExtractLispB<L>;\n}) {\n  return [obj.op, obj.a, obj.b] as L;\n}\n\nconst NullLisp = createLisp<None>({ op: LispType.None, a: LispType.None, b: LispType.None });\n\nexport type Literal = DefineLisp<LispType.Literal, string, Lisp[]> & { tempJsStrings?: string[] };\nexport type If = DefineLisp<LispType.If, Lisp, IfCase>;\nexport type InlineIf = DefineLisp<LispType.InlineIf, Lisp, InlineIfCase>;\nexport type IfCase = DefineLisp<LispType.IfCase, Lisp[], Lisp[]>;\nexport type InlineIfCase = DefineLisp<LispType.InlineIfCase, Lisp, Lisp>;\nexport type KeyVal = DefineLisp<LispType.KeyVal, string | Lisp, Lisp>;\nexport type SpreadObject = DefineLisp<LispType.SpreadObject, LispType.None, Lisp>;\nexport type SpreadArray = DefineLisp<LispType.SpreadArray, LispType.None, Lisp>;\nexport type ArrayProp = DefineLisp<LispType.ArrayProp, Lisp, Lisp>;\nexport type Prop = DefineLisp<LispType.Prop, Lisp, string | Lisp>;\nexport type PropOptional = DefineLisp<LispType.PropOptional, Lisp, Lisp[]>;\nexport type Call = DefineLisp<LispType.Call, Lisp, Lisp[]>;\nexport type CallOptional = DefineLisp<LispType.CallOptional, Lisp, Lisp[]>;\nexport type CreateArray = DefineLisp<LispType.CreateArray, Lisp, Lisp[]>;\nexport type CreateObject = DefineLisp<LispType.CreateObject, Lisp, Lisp[]>;\nexport type Group = DefineLisp<LispType.Group, Lisp, Lisp[]>;\nexport type Inverse = DefineLisp<LispType.Inverse, Lisp, Lisp>;\nexport type Not = DefineLisp<LispType.Not, Lisp, Lisp>;\nexport type Negative = DefineLisp<LispType.Negative, Lisp, Lisp>;\nexport type Positive = DefineLisp<LispType.Positive, Lisp, Lisp>;\nexport type Typeof = DefineLisp<LispType.Typeof, Lisp, Lisp>;\nexport type Delete = DefineLisp<LispType.Delete, Lisp, Lisp>;\nexport type IncrementBefore = DefineLisp<LispType.IncrementBefore, Lisp, LispType.None>;\nexport type IncrementAfter = DefineLisp<LispType.IncrementAfter, Lisp, LispType.None>;\nexport type DecrementBefore = DefineLisp<LispType.DecrementBefore, Lisp, LispType.None>;\nexport type DecrementAfter = DefineLisp<LispType.DecrementAfter, Lisp, LispType.None>;\n\nexport type And = DefineLisp<LispType.And, Lisp, Lisp>;\nexport type Or = DefineLisp<LispType.Or, Lisp, Lisp>;\nexport type NullishCoalescing = DefineLisp<LispType.NullishCoalescing, Lisp, Lisp>;\nexport type Instanceof = DefineLisp<LispType.Instanceof, Lisp, Lisp>;\nexport type In = DefineLisp<LispType.In, Lisp, Lisp>;\nexport type Assigns = DefineLisp<LispType.Assign, Lisp, Lisp>;\nexport type SubractEquals = DefineLisp<LispType.SubractEquals, Lisp, Lisp>;\nexport type AddEquals = DefineLisp<LispType.AddEquals, Lisp, Lisp>;\nexport type DivideEquals = DefineLisp<LispType.DivideEquals, Lisp, Lisp>;\nexport type PowerEquals = DefineLisp<LispType.PowerEquals, Lisp, Lisp>;\nexport type MultiplyEquals = DefineLisp<LispType.MultiplyEquals, Lisp, Lisp>;\nexport type ModulusEquals = DefineLisp<LispType.ModulusEquals, Lisp, Lisp>;\nexport type BitNegateEquals = DefineLisp<LispType.BitNegateEquals, Lisp, Lisp>;\nexport type BitAndEquals = DefineLisp<LispType.BitAndEquals, Lisp, Lisp>;\nexport type BitOrEquals = DefineLisp<LispType.BitOrEquals, Lisp, Lisp>;\nexport type UnsignedShiftRightEquals = DefineLisp<LispType.UnsignedShiftRightEquals, Lisp, Lisp>;\nexport type ShiftLeftEquals = DefineLisp<LispType.ShiftLeftEquals, Lisp, Lisp>;\nexport type ShiftRightEquals = DefineLisp<LispType.ShiftRightEquals, Lisp, Lisp>;\n\nexport type BitAnd = DefineLisp<LispType.BitAnd, Lisp, Lisp>;\nexport type BitOr = DefineLisp<LispType.BitOr, Lisp, Lisp>;\nexport type BitNegate = DefineLisp<LispType.BitNegate, Lisp, Lisp>;\nexport type BitShiftLeft = DefineLisp<LispType.BitShiftLeft, Lisp, Lisp>;\nexport type BitShiftRight = DefineLisp<LispType.BitShiftRight, Lisp, Lisp>;\nexport type BitUnsignedShiftRight = DefineLisp<LispType.BitUnsignedShiftRight, Lisp, Lisp>;\nexport type SmallerEqualThan = DefineLisp<LispType.SmallerEqualThan, Lisp, Lisp>;\nexport type LargerEqualThan = DefineLisp<LispType.LargerEqualThan, Lisp, Lisp>;\nexport type SmallerThan = DefineLisp<LispType.SmallerThan, Lisp, Lisp>;\nexport type LargerThan = DefineLisp<LispType.LargerThan, Lisp, Lisp>;\nexport type StrictNotEqual = DefineLisp<LispType.StrictNotEqual, Lisp, Lisp>;\nexport type NotEqual = DefineLisp<LispType.NotEqual, Lisp, Lisp>;\nexport type StrictEqual = DefineLisp<LispType.StrictEqual, Lisp, Lisp>;\nexport type Equal = DefineLisp<LispType.Equal, Lisp, Lisp>;\nexport type Plus = DefineLisp<LispType.Plus, Lisp, Lisp>;\nexport type Minus = DefineLisp<LispType.Minus, Lisp, Lisp>;\nexport type Divide = DefineLisp<LispType.Divide, Lisp, Lisp>;\nexport type Power = DefineLisp<LispType.Power, Lisp, Lisp>;\nexport type Multiply = DefineLisp<LispType.Multiply, Lisp, Lisp>;\nexport type Modulus = DefineLisp<LispType.Modulus, Lisp, Lisp>;\n\nexport type Block = DefineLisp<LispType.Block, Lisp[], LispType.None>;\nexport type Expression = DefineLisp<LispType.Expression, Lisp[], LispType.None>;\nexport type Return = DefineLisp<LispType.Return, LispType.None, Lisp>;\nexport type Throw = DefineLisp<LispType.Throw, LispType.None, Lisp>;\nexport type Switch = DefineLisp<LispType.Switch, Lisp, SwitchCase[]>;\nexport type SwitchCase = DefineLisp<LispType.SwitchCase, LispType.None | Lisp, Lisp[]>;\nexport type Var = DefineLisp<LispType.Var, string, Lisp | LispType.None>;\nexport type Let = DefineLisp<LispType.Let, string, Lisp | LispType.None>;\nexport type Const = DefineLisp<LispType.Const, string, Lisp | LispType.None>;\n\nexport type Number = DefineLisp<LispType.Number, LispType.None, string>;\nexport type BigInt = DefineLisp<LispType.BigInt, LispType.None, string>;\nexport type GlobalSymbol = DefineLisp<LispType.GlobalSymbol, LispType.None, string>;\nexport type LiteralIndex = DefineLisp<LispType.LiteralIndex, LispType.None, string>;\nexport type StringIndex = DefineLisp<LispType.StringIndex, LispType.None, string>;\nexport type RegexIndex = DefineLisp<LispType.RegexIndex, LispType.None, string>;\n\nexport type Function = DefineLisp<\n  LispType.Function,\n  (string | LispType.None | LispType.True)[],\n  string | Lisp[]\n>;\nexport type InlineFunction = DefineLisp<LispType.InlineFunction, string[], string | Lisp[]>;\nexport type ArrowFunction = DefineLisp<LispType.ArrowFunction, string[], string | Lisp[]>;\nexport type Loop = DefineLisp<LispType.Loop, LispItem, Lisp[]>;\nexport type LoopAction = DefineLisp<LispType.LoopAction, string, LispType.None>;\nexport type Try = DefineLisp<LispType.Try, Lisp[], LispItem>;\n\nexport type Void = DefineLisp<LispType.Void, Lisp, LispType.None>;\nexport type Await = DefineLisp<LispType.Await, Lisp, LispType.None>;\nexport type New = DefineLisp<LispType.New, Lisp, Lisp[]>;\nexport type None = DefineLisp<LispType.None, LispType.None, LispType.None>;\n\nexport type LispFamily =\n  | Literal\n  | If\n  | InlineIf\n  | IfCase\n  | InlineIfCase\n  | KeyVal\n  | SpreadObject\n  | SpreadArray\n  | ArrayProp\n  | Prop\n  | PropOptional\n  | Call\n  | CallOptional\n  | CreateArray\n  | CreateObject\n  | Group\n  | Inverse\n  | Not\n  | Negative\n  | Positive\n  | Typeof\n  | Delete\n  | IncrementBefore\n  | IncrementAfter\n  | DecrementBefore\n  | DecrementAfter\n  | And\n  | Or\n  | NullishCoalescing\n  | Instanceof\n  | In\n  | Assigns\n  | SubractEquals\n  | AddEquals\n  | DivideEquals\n  | PowerEquals\n  | MultiplyEquals\n  | ModulusEquals\n  | BitNegateEquals\n  | BitAndEquals\n  | BitOrEquals\n  | UnsignedShiftRightEquals\n  | ShiftLeftEquals\n  | ShiftRightEquals\n  | BitAnd\n  | BitOr\n  | BitNegate\n  | BitShiftLeft\n  | BitShiftRight\n  | BitUnsignedShiftRight\n  | SmallerEqualThan\n  | LargerEqualThan\n  | SmallerThan\n  | LargerThan\n  | StrictNotEqual\n  | NotEqual\n  | StrictEqual\n  | Equal\n  | Plus\n  | Minus\n  | Divide\n  | Power\n  | Multiply\n  | Modulus\n  | Block\n  | Expression\n  | Return\n  | Throw\n  | Switch\n  | SwitchCase\n  | Var\n  | Let\n  | Const\n  | Number\n  | BigInt\n  | GlobalSymbol\n  | LiteralIndex\n  | StringIndex\n  | RegexIndex\n  | Function\n  | InlineFunction\n  | ArrowFunction\n  | Loop\n  | LoopAction\n  | Try\n  | Void\n  | Await\n  | New\n  | None;\n\nexport interface IRegEx {\n  regex: string;\n  flags: string;\n  length: number;\n}\n\nexport interface IConstants {\n  strings: string[];\n  literals: Literal[];\n  regexes: IRegEx[];\n  eager: boolean;\n}\n\nexport interface IExecutionTree {\n  tree: Lisp[];\n  constants: IConstants;\n}\n\ntype LispCallback<T> = (\n  strings: IConstants,\n  type: T,\n  part: CodeString,\n  res: string[],\n  expect: string,\n  ctx: { lispTree: Lisp },\n) => any;\nconst lispTypes: Map<string, LispCallback<string>> = new Map();\n\nexport class ParseError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n  ) {\n    super(message + ': ' + code.substring(0, 40));\n  }\n}\n\nlet lastType: CodeString | string;\nlet lastPart: CodeString | string;\nlet lastLastPart: CodeString | string;\nlet lastLastLastPart: CodeString | string;\nlet lastLastLastLastPart: CodeString | string;\n\nconst inlineIfElse = /^:/;\nconst elseIf = /^else(?![\\w$])/;\nconst ifElse = /^if(?![\\w$])/;\nconst space = /^\\s/;\n\nexport const expectTypes = {\n  splitter: {\n    types: {\n      opHigh: /^(\\/|\\*\\*|\\*(?!\\*)|%)(?!=)/,\n      op: /^(\\+(?!(\\+))|-(?!(-)))(?!=)/,\n      comparitor: /^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!=)|===|==)/,\n      bitwiseShift: /^(<<|>>(?!>)|>>>)(?!=)/,\n      bitwiseAnd: /^(&(?!&))(?!=)/,\n      bitwiseXor: /^(\\^)(?!=)/,\n      bitwiseOr: /^(\\|(?!\\|))(?!=)/,\n      boolOpAnd: /^(&&)/,\n      boolOpOr: /^(\\|\\||instanceof(?![\\w$])|in(?![\\w$]))/,\n      nullishCoalescing: /^\\?\\?/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  inlineIf: {\n    types: {\n      inlineIf: /^\\?(?!\\.(?!\\d))/,\n    },\n    next: ['expEnd'],\n  },\n  assignment: {\n    types: {\n      assignModify: /^(-=|\\+=|\\/=|\\*\\*=|\\*=|%=|\\^=|&=|\\|=|>>>=|>>=|<<=)/,\n      assign: /^(=)(?!=)/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  incrementerBefore: {\n    types: { incrementerBefore: /^(\\+\\+|--)/ },\n    next: ['prop'],\n  },\n  expEdge: {\n    types: {\n      call: /^(\\?\\.)?[(]/,\n      incrementerAfter: /^(\\+\\+|--)/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  modifier: {\n    types: {\n      not: /^!/,\n      inverse: /^~/,\n      negative: /^-(?!-)/,\n      positive: /^\\+(?!\\+)/,\n      typeof: /^typeof(?![\\w$])/,\n      delete: /^delete(?![\\w$])/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore'],\n  },\n  dot: {\n    types: {\n      arrayProp: /^(\\?\\.)?\\[/,\n      dot: /^(\\?)?\\.(?=\\s*[a-zA-Z$_])/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  prop: {\n    types: {\n      prop: /^[a-zA-Z$_][a-zA-Z\\d$_]*/,\n    },\n    next: ['splitter', 'assignment', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  value: {\n    types: {\n      createObject: /^\\{/,\n      createArray: /^\\[/,\n      number:\n        /^(0b[01]+(_[01]+)*|0o[0-7]+(_[0-7]+)*|0x[\\da-f]+(_[\\da-f]+)*|(\\d+(_\\d+)*(\\.\\d+(_\\d+)*)?|\\.\\d+(_\\d+)*))(e[+-]?\\d+(_\\d+)*)?(n)?(?!\\d)/i,\n      string: /^\"(\\d+)\"/,\n      literal: /^`(\\d+)`/,\n      regex: /^\\/(\\d+)\\/r(?![\\w$])/,\n      boolean: /^(true|false)(?![\\w$])/,\n      null: /^null(?![\\w$])/,\n      und: /^undefined(?![\\w$])/,\n      arrowFunctionSingle: /^(async\\s+)?([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*=>\\s*({)?/,\n      arrowFunction:\n        /^(async\\s*)?\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*=>\\s*({)?/,\n      inlineFunction:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)?\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n      group: /^\\(/,\n      NaN: /^NaN(?![\\w$])/,\n      Infinity: /^Infinity(?![\\w$])/,\n      void: /^void(?![\\w$])\\s*/,\n      await: /^await(?![\\w$])\\s*/,\n      new: /^new(?![\\w$])\\s*/,\n    },\n    next: ['splitter', 'expEdge', 'dot', 'inlineIf', 'expEnd'],\n  },\n  initialize: {\n    types: {\n      initialize: /^(var|let|const)\\s+([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*(=)?/,\n      return: /^return(?![\\w$])/,\n      throw: /^throw(?![\\w$])\\s*/,\n    },\n    next: ['modifier', 'value', 'prop', 'incrementerBefore', 'expEnd'],\n  },\n  spreadObject: {\n    types: {\n      spreadObject: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  spreadArray: {\n    types: {\n      spreadArray: /^\\.\\.\\./,\n    },\n    next: ['value', 'prop'],\n  },\n  expEnd: { types: {}, next: [] },\n  expFunction: {\n    types: {\n      function:\n        /^(async\\s+)?function(\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\(\\s*((\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*(\\s*,\\s*(\\.\\.\\.)?\\s*[a-zA-Z$_][a-zA-Z\\d$_]*)*)?\\s*\\)\\s*{/,\n    },\n    next: ['expEdge', 'expEnd'],\n  },\n  expSingle: {\n    types: {\n      for: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*for\\s*\\(/,\n      do: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*do(?![\\w$])\\s*(\\{)?/,\n      while: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*while\\s*\\(/,\n      loopAction: /^(break|continue)(?![\\w$])\\s*([a-zA-Z$_][\\w$]*)?/,\n      if: /^((([a-zA-Z$_][\\w$]*)\\s*:)?\\s*)if\\s*\\(/,\n      try: /^try\\s*{/,\n      block: /^{/,\n      switch: /^(([a-zA-Z$_][\\w$]*)\\s*:)?\\s*switch\\s*\\(/,\n    },\n    next: ['expEnd'],\n  },\n} as Record<string, { types: Record<string, RegExp>; next: string[] }>;\n\nconst closings = {\n  '(': ')',\n  '[': ']',\n  '{': '}',\n  \"'\": \"'\",\n  '\"': '\"',\n  '`': '`',\n} as Record<string, string>;\n\nexport function testMultiple(str: string, tests: RegExp[]) {\n  let found: RegExpExecArray | null = null;\n  for (let i = 0; i < tests.length; i++) {\n    const test = tests[i];\n    found = test.exec(str);\n    if (found) break;\n  }\n  return found;\n}\n\nconst emptyString = new CodeString('');\n\nconst okFirstChars = /^[+\\-~ !]/;\nconst aNumber = expectTypes.value.types.number;\nconst wordReg = /^((if|for|else|while|do|function)(?![\\w$])|[\\w$]+)/;\nconst semiColon = /^;/;\nconst insertedSemicolons: WeakMap<{ str: string }, Array<number>> = new WeakMap();\nconst quoteCache: WeakMap<{ str: string }, Map<number, number>> = new WeakMap();\nexport interface restDetails {\n  oneliner?: boolean;\n  words?: string[];\n  lastWord?: string;\n  lastAnyWord?: string;\n  regRes?: RegExpExecArray;\n}\nexport function restOfExp(\n  constants: IConstants,\n  part: CodeString,\n  tests?: RegExp[],\n  quote?: string,\n  firstOpening?: string,\n  closingsTests?: RegExp[],\n  details: restDetails = {},\n): CodeString {\n  if (!part.length) {\n    return part;\n  }\n  details.words = details.words || [];\n  let isStart = true;\n  tests = tests || [];\n  const hasSemiTest = tests.includes(semiColon);\n  if (hasSemiTest) {\n    tests = tests.filter((a) => a !== semiColon);\n  }\n  const insertedSemis = insertedSemicolons.get(part.ref) || [];\n  const cache = quoteCache.get(part.ref) || new Map<number, number>();\n  quoteCache.set(part.ref, cache);\n  if (quote && cache.has(part.start - 1)) {\n    return part.substring(0, cache.get(part.start - 1)! - part.start);\n  }\n  let escape = false;\n  let done = false;\n  let lastChar = '';\n  let isOneLiner = false;\n  let i;\n  let lastInertedSemi = false;\n  for (i = 0; i < part.length && !done; i++) {\n    let char = part.char(i)!;\n    if (quote === '\"' || quote === \"'\" || quote === '`') {\n      if (quote === '`' && char === '$' && part.char(i + 1) === '{' && !escape) {\n        const skip = restOfExp(constants, part.substring(i + 2), [], '{');\n        i += skip.length + 2;\n      } else if (char === quote && !escape) {\n        return part.substring(0, i);\n      }\n      escape = !escape && char === '\\\\';\n    } else if (closings[char]) {\n      if (!lastInertedSemi && insertedSemis[i + part.start]) {\n        lastInertedSemi = true;\n        if (hasSemiTest) {\n          break;\n        }\n        i--;\n        lastChar = ';';\n        continue;\n      }\n      if (isOneLiner && char === '{') {\n        isOneLiner = false;\n      }\n      if (char === firstOpening) {\n        done = true;\n        break;\n      } else {\n        const skip = restOfExp(constants, part.substring(i + 1), [], char);\n        cache.set(skip.start - 1, skip.end);\n        i += skip.length + 1;\n        isStart = false;\n        if (closingsTests) {\n          const sub = part.substring(i);\n          let found: RegExpExecArray | null;\n          if ((found = testMultiple(sub.toString(), closingsTests))) {\n            details.regRes = found;\n            done = true;\n          }\n        }\n      }\n    } else if (!quote) {\n      let sub = part.substring(i).toString();\n      let foundWord: RegExpExecArray | null;\n      let foundNumber: RegExpExecArray | null;\n      if (closingsTests) {\n        let found: RegExpExecArray | null;\n        if ((found = testMultiple(sub, closingsTests))) {\n          details.regRes = found;\n          i++;\n          done = true;\n          break;\n        }\n      }\n      if ((foundNumber = aNumber.exec(sub))) {\n        i += foundNumber[0].length - 1;\n        sub = part.substring(i).toString();\n      } else if (lastChar != char) {\n        let found: [string] | RegExpExecArray | null = null;\n        if (char === ';' || (insertedSemis[i + part.start] && !isStart && !lastInertedSemi)) {\n          if (hasSemiTest) {\n            found = [';'];\n          } else if (insertedSemis[i + part.start]) {\n            lastInertedSemi = true;\n            i--;\n            lastChar = ';';\n            continue;\n          }\n          char = sub = ';';\n        } else {\n          lastInertedSemi = false;\n        }\n        if (!found) {\n          found = testMultiple(sub, tests);\n        }\n        if (found) {\n          done = true;\n        }\n        if (!done && (foundWord = wordReg.exec(sub))) {\n          isOneLiner = true;\n          if (foundWord[0].length > 1) {\n            details.words.push(foundWord[1]);\n            details.lastAnyWord = foundWord[1];\n            if (foundWord[2]) {\n              details.lastWord = foundWord[2];\n            }\n          }\n          if (foundWord[0].length > 2) {\n            i += foundWord[0].length - 2;\n          }\n        }\n      }\n      if (isStart) {\n        if (okFirstChars.test(sub)) {\n          done = false;\n        } else {\n          isStart = false;\n        }\n      }\n      if (done) break;\n    } else if (char === closings[quote]) {\n      return part.substring(0, i);\n    }\n    lastChar = char;\n  }\n  if (quote) {\n    throw new SyntaxError(\"Unclosed '\" + quote + \"'\");\n  }\n  if (details) {\n    details.oneliner = isOneLiner;\n  }\n  return part.substring(0, i);\n}\nrestOfExp.next = ['splitter', 'expEnd', 'inlineIf'];\n\nconst startingExecpted = [\n  'initialize',\n  'expSingle',\n  'expFunction',\n  'value',\n  'modifier',\n  'prop',\n  'incrementerBefore',\n  'expEnd',\n];\n\nexport const setLispType = <T extends readonly string[]>(types: T, fn: LispCallback<T[number]>) => {\n  types.forEach((type) => {\n    lispTypes.set(type, fn);\n  });\n};\n\nconst closingsCreate: { [type: string]: RegExp } = {\n  createArray: /^\\]/,\n  createObject: /^\\}/,\n  group: /^\\)/,\n  arrayProp: /^\\]/,\n  call: /^\\)/,\n};\n\nconst typesCreate = {\n  createArray: LispType.CreateArray,\n  createObject: LispType.CreateObject,\n  group: LispType.Group,\n  arrayProp: LispType.ArrayProp,\n  call: LispType.Call,\n  prop: LispType.Prop,\n  '?prop': LispType.PropOptional,\n  '?call': LispType.CallOptional,\n} as any;\n\nsetLispType(\n  ['createArray', 'createObject', 'group', 'arrayProp', 'call'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    let extract = emptyString;\n    const arg: CodeString[] = [];\n    let end = false;\n    let i = res[0].length;\n    const start = i;\n    while (i < part.length && !end) {\n      extract = restOfExp(constants, part.substring(i), [closingsCreate[type], /^,/]);\n      i += extract.length;\n      if (extract.trim().length) {\n        arg.push(extract);\n      }\n      if (part.char(i) !== ',') {\n        end = true;\n      } else {\n        i++;\n      }\n    }\n    const next = ['value', 'modifier', 'prop', 'incrementerBefore', 'expEnd'];\n    let l: Lisp | Lisp[];\n\n    let funcFound: RegExpExecArray | null;\n    switch (type) {\n      case 'group':\n      case 'arrayProp':\n        l = lispifyExpr(constants, part.substring(start, i));\n        break;\n      case 'call':\n      case 'createArray':\n        // @TODO: support 'empty' values\n        l = arg.map((e) => lispify(constants, e, [...next, 'spreadArray']));\n        break;\n      case 'createObject':\n        l = arg.map((str) => {\n          str = str.trimStart();\n          let value: Lisp;\n          let key: string | Lisp = '';\n          funcFound = expectTypes.expFunction.types.function.exec('function ' + str);\n          if (funcFound) {\n            key = funcFound[2].trimStart();\n            value = lispify(\n              constants,\n              new CodeString('function ' + str.toString().replace(key, '')),\n            );\n          } else {\n            const extract = restOfExp(constants, str, [/^:/]);\n            key = lispify(constants, extract, [...next, 'spreadObject']) as Prop;\n            if (key[0] === LispType.Prop) {\n              key = (key as Prop)[2];\n            }\n            value = lispify(constants, str.substring(extract.length + 1));\n          }\n          return createLisp<KeyVal>({\n            op: LispType.KeyVal,\n            a: key,\n            b: value,\n          });\n        });\n        break;\n    }\n    const lisptype = (\n      type === 'arrayProp'\n        ? res[1]\n          ? LispType.PropOptional\n          : LispType.Prop\n        : type === 'call'\n          ? res[1]\n            ? LispType.CallOptional\n            : LispType.Call\n          : typesCreate[type]\n    ) as (typeof typesCreate)[keyof typeof typesCreate];\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(i + 1),\n      expectTypes[expect].next,\n      createLisp<\n        ArrayProp | Prop | Call | CreateObject | CreateArray | Group | PropOptional | CallOptional\n      >({\n        op: lisptype,\n        a: ctx.lispTree,\n        b: l,\n      }),\n    );\n  },\n);\n\nconst modifierTypes = {\n  inverse: LispType.Inverse,\n  not: LispType.Not,\n  positive: LispType.Positive,\n  negative: LispType.Negative,\n  typeof: LispType.Typeof,\n  delete: LispType.Delete,\n} as const;\n\nsetLispType(\n  ['inverse', 'not', 'negative', 'positive', 'typeof', 'delete'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<Inverse | Not | Negative | Positive | Typeof | Delete>({\n        op: modifierTypes[type],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      }),\n    );\n  },\n);\n\nconst incrementTypes = {\n  '++$': LispType.IncrementBefore,\n  '--$': LispType.DecrementBefore,\n  '$++': LispType.IncrementAfter,\n  '$--': LispType.DecrementAfter,\n} as any;\n\nsetLispType(['incrementerBefore'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(2), [/^[^\\s.\\w$]/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + 2),\n    restOfExp.next,\n    createLisp<IncrementBefore | DecrementBefore>({\n      op: incrementTypes[res[0] + '$'],\n      a: lispify(constants, extract, expectTypes[expect].next),\n      b: LispType.None,\n    }),\n  );\n});\n\nsetLispType(['incrementerAfter'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<IncrementAfter | DecrementAfter>({\n      op: incrementTypes['$' + res[0]],\n      a: ctx.lispTree,\n      b: LispType.None,\n    }),\n  );\n});\n\nconst adderTypes = {\n  '&&': LispType.And,\n  '||': LispType.Or,\n  '??': LispType.NullishCoalescing,\n  instanceof: LispType.Instanceof,\n  in: LispType.In,\n  '=': LispType.Assign,\n  '-=': LispType.SubractEquals,\n  '+=': LispType.AddEquals,\n  '/=': LispType.DivideEquals,\n  '**=': LispType.PowerEquals,\n  '*=': LispType.MultiplyEquals,\n  '%=': LispType.ModulusEquals,\n  '^=': LispType.BitNegateEquals,\n  '&=': LispType.BitAndEquals,\n  '|=': LispType.BitOrEquals,\n  '>>>=': LispType.UnsignedShiftRightEquals,\n  '<<=': LispType.ShiftLeftEquals,\n  '>>=': LispType.ShiftRightEquals,\n} as any;\n\nsetLispType(\n  ['assign', 'assignModify', 'nullishCoalescing'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = createLisp<\n      | NullishCoalescing\n      | Assigns\n      | SubractEquals\n      | AddEquals\n      | DivideEquals\n      | PowerEquals\n      | MultiplyEquals\n      | ModulusEquals\n      | BitNegateEquals\n      | BitAndEquals\n      | BitOrEquals\n      | UnsignedShiftRightEquals\n      | ShiftLeftEquals\n      | ShiftRightEquals\n    >({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  },\n);\n\n// Separate handler for boolOpOr (||, instanceof, in) - lower precedence than &&\nsetLispType(['boolOpOr'] as const, (constants, type, part, res, expect, ctx) => {\n  // boolOpOr should allow boolOpOr on the right (same precedence, left-to-right)\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse,\n    expectTypes.splitter.types.boolOpOr,\n  ];\n  const extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + res[0].length),\n    restOfExp.next,\n    createLisp<Or | Instanceof | In>({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, extract, expectTypes[expect].next),\n    }),\n  );\n});\n\n// Separate handler for boolOpAnd (&&) - higher precedence than ||\nsetLispType(['boolOpAnd'] as const, (constants, type, part, res, expect, ctx) => {\n  // boolOpAnd should allow boolOpAnd and boolOpOr on the right\n  const next = [\n    expectTypes.inlineIf.types.inlineIf,\n    inlineIfElse,\n    expectTypes.splitter.types.boolOpAnd,\n    expectTypes.splitter.types.boolOpOr,\n  ];\n  const extract = restOfExp(constants, part.substring(res[0].length), next);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(extract.length + res[0].length),\n    restOfExp.next,\n    createLisp<And>({\n      op: adderTypes[res[0]],\n      a: ctx.lispTree,\n      b: lispify(constants, extract, expectTypes[expect].next),\n    }),\n  );\n});\n\nconst opTypes = {\n  '&': LispType.BitAnd,\n  '|': LispType.BitOr,\n  '^': LispType.BitNegate,\n  '<<': LispType.BitShiftLeft,\n  '>>': LispType.BitShiftRight,\n  '>>>': LispType.BitUnsignedShiftRight,\n  '<=': LispType.SmallerEqualThan,\n  '>=': LispType.LargerEqualThan,\n  '<': LispType.SmallerThan,\n  '>': LispType.LargerThan,\n  '!==': LispType.StrictNotEqual,\n  '!=': LispType.NotEqual,\n  '===': LispType.StrictEqual,\n  '==': LispType.Equal,\n  '+': LispType.Plus,\n  '-': LispType.Minus,\n  '/': LispType.Divide,\n  '**': LispType.Power,\n  '*': LispType.Multiply,\n  '%': LispType.Modulus,\n} as any;\n\nsetLispType(\n  ['opHigh', 'op', 'comparitor', 'bitwiseShift', 'bitwiseAnd', 'bitwiseXor', 'bitwiseOr'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const next = [expectTypes.inlineIf.types.inlineIf, inlineIfElse];\n    switch (type) {\n      case 'opHigh':\n        next.push(expectTypes.splitter.types.opHigh);\n      case 'op':\n        next.push(expectTypes.splitter.types.op);\n      case 'comparitor':\n        next.push(expectTypes.splitter.types.comparitor);\n      case 'bitwiseShift':\n        next.push(expectTypes.splitter.types.bitwiseShift);\n      case 'bitwiseAnd':\n        next.push(expectTypes.splitter.types.bitwiseAnd);\n      case 'bitwiseXor':\n        next.push(expectTypes.splitter.types.bitwiseXor);\n      case 'bitwiseOr':\n        next.push(expectTypes.splitter.types.bitwiseOr);\n        next.push(expectTypes.splitter.types.boolOpAnd);\n        next.push(expectTypes.splitter.types.boolOpOr);\n    }\n    const extract = restOfExp(constants, part.substring(res[0].length), next);\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(extract.length + res[0].length),\n      restOfExp.next,\n      createLisp<\n        | BitAnd\n        | BitOr\n        | BitNegate\n        | BitShiftLeft\n        | BitShiftRight\n        | BitUnsignedShiftRight\n        | SmallerEqualThan\n        | LargerEqualThan\n        | SmallerThan\n        | LargerThan\n        | StrictNotEqual\n        | NotEqual\n        | StrictEqual\n        | Equal\n        | Plus\n        | Minus\n        | Divide\n        | Power\n        | Multiply\n        | Modulus\n      >({\n        op: opTypes[res[0]],\n        a: ctx.lispTree,\n        b: lispify(constants, extract, expectTypes[expect].next),\n      }),\n    );\n  },\n);\n\nsetLispType(['inlineIf'] as const, (constants, type, part, res, expect, ctx) => {\n  let found = false;\n  const extract = part.substring(0, 0);\n  let quoteCount = 1;\n  while (!found && extract.length < part.length) {\n    extract.end = restOfExp(constants, part.substring(extract.length + 1), [\n      expectTypes.inlineIf.types.inlineIf,\n      inlineIfElse,\n    ]).end;\n    if (part.char(extract.length) === '?') {\n      quoteCount++;\n    } else {\n      quoteCount--;\n    }\n    if (!quoteCount) {\n      found = true;\n    }\n  }\n  extract.start = part.start + 1;\n  ctx.lispTree = createLisp<InlineIf>({\n    op: LispType.InlineIf,\n    a: ctx.lispTree,\n    b: createLisp<InlineIfCase>({\n      op: LispType.InlineIfCase,\n      a: lispifyExpr(constants, extract),\n      b: lispifyExpr(constants, part.substring(res[0].length + extract.length + 1)),\n    }),\n  });\n});\n\nfunction extractIfElse(constants: IConstants, part: CodeString) {\n  let count = 0;\n  let found = part.substring(0, 0);\n  let foundElse = emptyString;\n  let foundTrue: CodeString | undefined;\n  let first = true;\n  let elseReg: RegExpExecArray | null;\n  let details: restDetails = {};\n  while (\n    (found = restOfExp(\n      constants,\n      part.substring(found.end - part.start),\n      [elseIf, ifElse, semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details,\n    )).length ||\n    first\n  ) {\n    first = false;\n    const f = part.substring(found.end - part.start).toString();\n\n    if (f.startsWith('if')) {\n      found.end++;\n      count++;\n    } else if (f.startsWith('else')) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end++;\n      count--;\n      if (!count) {\n        found.end--;\n      }\n    } else if ((elseReg = /^;?\\s*else(?![\\w$])/.exec(f))) {\n      foundTrue = part.substring(0, found.end - part.start);\n      found.end += elseReg[0].length - 1;\n      count--;\n      if (!count) {\n        found.end -= elseReg[0].length - 1;\n      }\n    } else {\n      foundTrue = foundElse.length ? foundTrue : part.substring(0, found.end - part.start);\n      break;\n    }\n    if (!count) {\n      const ie = extractIfElse(\n        constants,\n        part.substring(found.end - part.start + (/^;?\\s*else(?![\\w$])/.exec(f)?.[0].length || 0)),\n      );\n      foundElse = ie.all;\n      break;\n    }\n    details = {};\n  }\n  foundTrue = foundTrue || part.substring(0, found.end - part.start);\n  return {\n    all: part.substring(0, Math.max(foundTrue.end, foundElse.end) - part.start),\n    true: foundTrue,\n    false: foundElse,\n  };\n}\n\nsetLispType(['if'] as const, (constants, type, part, res, expect, ctx) => {\n  let condition = restOfExp(constants, part.substring(res[0].length), [], '(');\n  const ie = extractIfElse(constants, part.substring(res[1].length));\n  const startTrue = res[0].length - res[1].length + condition.length + 1;\n\n  let trueBlock = ie.true.substring(startTrue);\n  let elseBlock = ie.false;\n\n  condition = condition.trim();\n  trueBlock = trueBlock.trim();\n  elseBlock = elseBlock.trim();\n\n  if (trueBlock.char(0) === '{') trueBlock = trueBlock.slice(1, -1);\n  if (elseBlock.char(0) === '{') elseBlock = elseBlock.slice(1, -1);\n  ctx.lispTree = createLisp<If>({\n    op: LispType.If,\n    a: lispifyExpr(constants, condition),\n    b: createLisp<IfCase>({\n      op: LispType.IfCase,\n      a: lispifyBlock(trueBlock, constants),\n      b: lispifyBlock(elseBlock, constants),\n    }),\n  });\n});\n\nsetLispType(['switch'] as const, (constants, type, part, res, expect, ctx) => {\n  const test = restOfExp(constants, part.substring(res[0].length), [], '(');\n  let start = part.toString().indexOf('{', res[0].length + test.length + 1);\n  if (start === -1) throw new SyntaxError('Invalid switch');\n  let statement = insertSemicolons(\n    constants,\n    restOfExp(constants, part.substring(start + 1), [], '{'),\n  );\n  let caseFound: RegExpExecArray | null;\n  const caseTest = /^\\s*(case\\s|default)\\s*/;\n  const cases: SwitchCase[] = [];\n  let defaultFound = false;\n  while ((caseFound = caseTest.exec(statement.toString()))) {\n    if (caseFound[1] === 'default') {\n      if (defaultFound) throw new SyntaxError('Only one default switch case allowed');\n      defaultFound = true;\n    }\n    const cond = restOfExp(constants, statement.substring(caseFound[0].length), [/^:/]);\n    let found = emptyString;\n    let i = (start = caseFound[0].length + cond.length + 1);\n    const bracketFound = /^\\s*\\{/.exec(statement.substring(i).toString());\n    let exprs: Lisp[] = [];\n    if (bracketFound) {\n      i += bracketFound[0].length;\n      found = restOfExp(constants, statement.substring(i), [], '{');\n      i += found.length + 1;\n      exprs = lispifyBlock(found, constants);\n    } else {\n      const notEmpty = restOfExp(constants, statement.substring(i), [caseTest]);\n      if (!notEmpty.trim().length) {\n        exprs = [];\n        i += notEmpty.length;\n      } else {\n        while ((found = restOfExp(constants, statement.substring(i), [semiColon])).length) {\n          i += found.length + (statement.char(i + found.length) === ';' ? 1 : 0);\n          if (caseTest.test(statement.substring(i).toString())) {\n            break;\n          }\n        }\n        exprs = lispifyBlock(statement.substring(start, found.end - statement.start), constants);\n      }\n    }\n    statement = statement.substring(i);\n    cases.push(\n      createLisp<SwitchCase>({\n        op: LispType.SwitchCase,\n        a: caseFound[1] === 'default' ? LispType.None : lispifyExpr(constants, cond),\n        b: exprs,\n      }),\n    );\n  }\n  ctx.lispTree = createLisp<Switch>({\n    op: LispType.Switch,\n    a: lispifyExpr(constants, test),\n    b: cases,\n  });\n});\n\nsetLispType(['dot', 'prop'] as const, (constants, type, part, res, expect, ctx) => {\n  let prop = res[0];\n  let index = res[0].length;\n  let op = 'prop';\n  if (type === 'dot') {\n    if (res[1]) {\n      op = '?prop';\n    }\n    const matches = part.substring(res[0].length).toString().match(expectTypes.prop.types.prop);\n    if (matches && matches.length) {\n      prop = matches[0];\n      index = prop.length + res[0].length;\n    } else {\n      throw new SyntaxError('Hanging dot');\n    }\n  } else {\n    if (reservedWords.has(prop) && prop !== 'this') {\n      throw new SyntaxError(`Unexpected token '${prop}'`);\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(index),\n    expectTypes[expect].next,\n    createLisp<Prop | PropOptional>({\n      op: typesCreate[op],\n      a: ctx.lispTree,\n      b: prop,\n    }),\n  );\n});\n\nsetLispType(['spreadArray', 'spreadObject'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<SpreadArray | SpreadObject>({\n    op: type === 'spreadArray' ? LispType.SpreadArray : LispType.SpreadObject,\n    a: LispType.None,\n    b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n  });\n});\n\nsetLispType(['return', 'throw'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Return | Throw>({\n    op: type === 'return' ? LispType.Return : LispType.Throw,\n    a: LispType.None,\n    b: lispifyExpr(constants, part.substring(res[0].length)),\n  });\n});\n\nsetLispType(\n  ['number', 'boolean', 'null', 'und', 'NaN', 'Infinity'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Number | BigInt | GlobalSymbol>({\n        op:\n          type === 'number' ? (res[12] ? LispType.BigInt : LispType.Number) : LispType.GlobalSymbol,\n        a: LispType.None,\n        b: res[12] ? res[1] : res[0],\n      }),\n    );\n  },\n);\n\nsetLispType(['string', 'literal', 'regex'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length),\n    expectTypes[expect].next,\n    createLisp<StringIndex | LiteralIndex | RegexIndex>({\n      op:\n        type === 'string'\n          ? LispType.StringIndex\n          : type === 'literal'\n            ? LispType.LiteralIndex\n            : LispType.RegexIndex,\n      a: LispType.None,\n      b: res[1],\n    }),\n  );\n});\n\nsetLispType(['initialize'] as const, (constants, type, part, res, expect, ctx) => {\n  const lt = res[1] === 'var' ? LispType.Var : res[1] === 'let' ? LispType.Let : LispType.Const;\n  if (!res[3]) {\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length),\n      expectTypes[expect].next,\n      createLisp<Var | Let | Const>({\n        op: lt,\n        a: res[2],\n        b: LispType.None,\n      }),\n    );\n  } else {\n    ctx.lispTree = createLisp<Var | Let | Const>({\n      op: lt,\n      a: res[2],\n      b: lispify(constants, part.substring(res[0].length), expectTypes[expect].next),\n    });\n  }\n});\n\nsetLispType(\n  ['function', 'inlineFunction', 'arrowFunction', 'arrowFunctionSingle'] as const,\n  (constants, type, part, res, expect, ctx) => {\n    const isArrow = type !== 'function' && type !== 'inlineFunction';\n    const isReturn = isArrow && !res[res.length - 1];\n    const argPos = isArrow ? 2 : 3;\n    const isAsync = res[1] ? LispType.True : LispType.None;\n    const args: string[] = res[argPos] ? res[argPos].replace(/\\s+/g, '').split(/,/g) : [];\n    if (!isArrow) {\n      args.unshift((res[2] || '').trimStart());\n    }\n    let ended = false;\n    args.forEach((arg: string) => {\n      if (ended) throw new SyntaxError('Rest parameter must be last formal parameter');\n      if (arg.startsWith('...')) ended = true;\n    });\n    const f = restOfExp(\n      constants,\n      part.substring(res[0].length),\n      !isReturn ? [/^}/] : [/^[,)}\\]]/, semiColon],\n    );\n    const func = isReturn ? 'return ' + f : f.toString();\n    args.forEach((arg: string) => {\n      if (reservedWords.has(arg.replace(/^\\.\\.\\./, ''))) {\n        throw new SyntaxError(`Unexpected token '${arg}'`);\n      }\n    });\n    ctx.lispTree = lispify(\n      constants,\n      part.substring(res[0].length + func.length + 1),\n      expectTypes[expect].next,\n      createLisp<Function | InlineFunction | ArrowFunction>({\n        op: isArrow\n          ? LispType.ArrowFunction\n          : type === 'function'\n            ? LispType.Function\n            : LispType.InlineFunction,\n        a: [isAsync, ...args],\n        b: constants.eager ? lispifyFunction(new CodeString(func), constants) : func,\n      }),\n    );\n  },\n);\n\nconst iteratorRegex = /^((let|var|const)\\s+)?\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s+(in|of)(?![\\w$])/;\nsetLispType(['for', 'do', 'while'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = 0;\n  let startStep: LispItem = LispType.True;\n  let startInternal: Lisp[] = [];\n  let getIterator: Lisp | LispType.None = LispType.None;\n  let beforeStep: LispItem = LispType.None;\n  let checkFirst = LispType.True;\n  let condition: LispItem;\n  let step: LispItem = LispType.True;\n  let body: CodeString;\n  switch (type) {\n    case 'while': {\n      i = part.toString().indexOf('(') + 1;\n      const extract = restOfExp(constants, part.substring(i), [], '(');\n      condition = lispifyReturnExpr(constants, extract);\n      body = restOfExp(constants, part.substring(i + extract.length + 1)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n      break;\n    }\n    case 'for': {\n      i = part.toString().indexOf('(') + 1;\n      const args: CodeString[] = [];\n      let extract2 = emptyString;\n      for (let k = 0; k < 3; k++) {\n        extract2 = restOfExp(constants, part.substring(i), [/^[;)]/]);\n        args.push(extract2.trim());\n        i += extract2.length + 1;\n        if (part.char(i - 1) === ')') break;\n      }\n      let iterator: RegExpExecArray | null;\n      if (args.length === 1 && (iterator = iteratorRegex.exec(args[0].toString()))) {\n        if (iterator[4] === 'of') {\n          ((getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [ofStart2, ofStart3]));\n          condition = ofCondition;\n          step = ofStep;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$next.value'),\n            ['initialize'],\n          );\n        } else {\n          ((getIterator = lispifyReturnExpr(constants, args[0].substring(iterator[0].length))),\n            (startInternal = [inStart2, inStart3]));\n          step = inStep;\n          condition = inCondition;\n          beforeStep = lispify(\n            constants,\n            new CodeString((iterator[1] || 'let ') + iterator[3] + ' = $$keys[$$keyIndex]'),\n            ['initialize'],\n          );\n        }\n      } else if (args.length === 3) {\n        startStep = lispifyExpr(constants, args.shift()!, startingExecpted);\n        condition = lispifyReturnExpr(constants, args.shift()!);\n        step = lispifyExpr(constants, args.shift()!);\n      } else {\n        throw new SyntaxError('Invalid for loop definition');\n      }\n      body = restOfExp(constants, part.substring(i)).trim();\n      if (body.char(0) === '{') body = body.slice(1, -1);\n\n      break;\n    }\n    case 'do': {\n      checkFirst = LispType.None;\n      const isBlock = !!res[3];\n      body = restOfExp(constants, part.substring(res[0].length), isBlock ? [/^\\}/] : [semiColon]);\n      condition = lispifyReturnExpr(\n        constants,\n        restOfExp(\n          constants,\n          part.substring(part.toString().indexOf('(', res[0].length + body.length) + 1),\n          [],\n          '(',\n        ),\n      );\n      break;\n    }\n  }\n  const a = [\n    checkFirst,\n    startInternal,\n    getIterator,\n    startStep,\n    step,\n    condition,\n    beforeStep,\n  ] as LispItem;\n  ctx.lispTree = createLisp<Loop>({\n    op: LispType.Loop,\n    a,\n    b: lispifyBlock(body, constants),\n  });\n});\n\nsetLispType(['block'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<Block>({\n    op: LispType.Block,\n    a: lispifyBlock(restOfExp(constants, part.substring(1), [], '{'), constants),\n    b: LispType.None,\n  });\n});\n\nsetLispType(['loopAction'] as const, (constants, type, part, res, expect, ctx) => {\n  ctx.lispTree = createLisp<LoopAction>({\n    op: LispType.LoopAction,\n    a: res[1],\n    b: LispType.None,\n  });\n});\n\nconst catchReg = /^\\s*(catch\\s*(\\(\\s*([a-zA-Z$_][a-zA-Z\\d$_]*)\\s*\\))?|finally)\\s*\\{/;\nsetLispType(['try'] as const, (constants, type, part, res, expect, ctx) => {\n  const body = restOfExp(constants, part.substring(res[0].length), [], '{');\n  let catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n  let finallyBody;\n  let exception = '';\n  let catchBody;\n  let offset = 0;\n  if (catchRes![1].startsWith('catch')) {\n    catchRes = catchReg.exec(part.substring(res[0].length + body.length + 1).toString());\n    exception = catchRes![2];\n    catchBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{',\n    );\n    offset = res[0].length + body.length + 1 + catchRes![0].length + catchBody.length + 1;\n    if (\n      (catchRes = catchReg.exec(part.substring(offset).toString())) &&\n      catchRes[1].startsWith('finally')\n    ) {\n      finallyBody = restOfExp(constants, part.substring(offset + catchRes[0].length), [], '{');\n    }\n  } else {\n    finallyBody = restOfExp(\n      constants,\n      part.substring(res[0].length + body.length + 1 + catchRes![0].length),\n      [],\n      '{',\n    );\n  }\n  const b = [\n    exception,\n    lispifyBlock(insertSemicolons(constants, catchBody || emptyString), constants),\n    lispifyBlock(insertSemicolons(constants, finallyBody || emptyString), constants),\n  ] as LispItem;\n  ctx.lispTree = createLisp<Try>({\n    op: LispType.Try,\n    a: lispifyBlock(insertSemicolons(constants, body), constants),\n    b,\n  });\n});\n\nsetLispType(['void', 'await'] as const, (constants, type, part, res, expect, ctx) => {\n  const extract = restOfExp(constants, part.substring(res[0].length), [/^([^\\s.?\\w$]|\\?[^.])/]);\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(res[0].length + extract.length),\n    expectTypes[expect].next,\n    createLisp<Void | Await>({\n      op: type === 'void' ? LispType.Void : LispType.Await,\n      a: lispify(constants, extract),\n      b: LispType.None,\n    }),\n  );\n});\n\nsetLispType(['new'] as const, (constants, type, part, res, expect, ctx) => {\n  let i = res[0].length;\n  const obj = restOfExp(constants, part.substring(i), [], undefined, '(');\n  i += obj.length + 1;\n  const args: CodeString[] = [];\n  if (part.char(i - 1) === '(') {\n    const argsString = restOfExp(constants, part.substring(i), [], '(');\n    i += argsString.length + 1;\n    let found: CodeString;\n    let j = 0;\n    while ((found = restOfExp(constants, argsString.substring(j), [/^,/])).length) {\n      j += found.length + 1;\n      args.push(found.trim());\n    }\n  }\n  ctx.lispTree = lispify(\n    constants,\n    part.substring(i),\n    expectTypes.expEdge.next,\n    createLisp({\n      op: LispType.New,\n      a: lispify(constants, obj, expectTypes.initialize.next),\n      b: args.map((arg) => lispify(constants, arg, expectTypes.initialize.next)),\n    }),\n  );\n});\n\nconst ofStart2 = lispify(\n  undefined as any,\n  new CodeString('let $$iterator = $$obj[Symbol.iterator]()'),\n  ['initialize'],\n);\nconst ofStart3 = lispify(undefined as any, new CodeString('let $$next = $$iterator.next()'), [\n  'initialize',\n]);\nconst ofCondition = lispify(undefined as any, new CodeString('return !$$next.done'), [\n  'initialize',\n]);\nconst ofStep = lispify(undefined as any, new CodeString('$$next = $$iterator.next()'));\nconst inStart2 = lispify(undefined as any, new CodeString('let $$keys = Object.keys($$obj)'), [\n  'initialize',\n]);\nconst inStart3 = lispify(undefined as any, new CodeString('let $$keyIndex = 0'), ['initialize']);\nconst inStep = lispify(undefined as any, new CodeString('$$keyIndex++'));\nconst inCondition = lispify(undefined as any, new CodeString('return $$keyIndex < $$keys.length'), [\n  'initialize',\n]);\n\nfunction lispify(\n  constants: IConstants,\n  part: CodeString,\n  expected?: readonly string[],\n  lispTree?: Lisp,\n  topLevel = false,\n): Lisp {\n  lispTree = lispTree || NullLisp;\n  expected = expected || expectTypes.initialize.next;\n  if (part === undefined) return lispTree;\n\n  part = part.trimStart();\n  const str = part.toString();\n  if (!part.length && !expected.includes('expEnd')) {\n    throw new SyntaxError('Unexpected end of expression');\n  }\n  if (!part.length) return lispTree;\n\n  const ctx = { lispTree: lispTree };\n\n  let res: any;\n  for (const expect of expected) {\n    if (expect === 'expEnd') {\n      continue;\n    }\n    for (const type in expectTypes[expect].types) {\n      if (type === 'expEnd') {\n        continue;\n      }\n      if ((res = expectTypes[expect].types[type].exec(str))) {\n        lastType = type;\n        lastLastLastLastPart = lastLastLastPart;\n        lastLastLastPart = lastLastPart;\n        lastLastPart = lastPart;\n        lastPart = part;\n        try {\n          lispTypes.get(type)?.(constants, type, part, res, expect, ctx);\n        } catch (e) {\n          if (topLevel && e instanceof SyntaxError) {\n            throw new ParseError(e.message, str);\n          }\n          throw e;\n        }\n        break;\n      }\n    }\n    if (res) break;\n  }\n\n  if (!res && part.length) {\n    if (topLevel) {\n      throw new ParseError(`Unexpected token after ${lastType}: ${part.char(0)}`, str);\n    }\n    throw new SyntaxError(`Unexpected token after ${lastType}: ${part.char(0)}`);\n  }\n  return ctx.lispTree;\n}\n\nconst startingExpectedWithoutSingle = startingExecpted.filter((r) => r !== 'expSingle');\n\nfunction lispifyExpr(constants: IConstants, str: CodeString, expected?: readonly string[]): Lisp {\n  if (!str.trimStart().length) return NullLisp;\n  const subExpressions: CodeString[] = [];\n  let sub: CodeString;\n  let pos = 0;\n  expected = expected || expectTypes.initialize.next;\n  if (expected.includes('expSingle')) {\n    if (testMultiple(str.toString(), Object.values(expectTypes.expSingle.types))) {\n      return lispify(constants, str, ['expSingle'], undefined, true);\n    }\n  }\n  if (expected === startingExecpted) expected = startingExpectedWithoutSingle;\n  while ((sub = restOfExp(constants, str.substring(pos), [/^,/])).length) {\n    subExpressions.push(sub.trimStart());\n    pos += sub.length + 1;\n  }\n  if (subExpressions.length === 1) {\n    return lispify(constants, str, expected, undefined, true);\n  }\n  if (expected.includes('initialize')) {\n    const defined = expectTypes.initialize.types.initialize.exec(subExpressions[0].toString());\n    if (defined) {\n      return createLisp<Block>({\n        op: LispType.Block,\n        a: subExpressions.map((str, i) =>\n          lispify(\n            constants,\n            i ? new CodeString(defined![1] + ' ' + str) : str,\n            ['initialize'],\n            undefined,\n            true,\n          ),\n        ),\n        b: LispType.None,\n      });\n    } else if (expectTypes.initialize.types.return.exec(subExpressions[0].toString())) {\n      return lispify(constants, str, expected, undefined, true);\n    }\n  }\n  const exprs = subExpressions.map((str) => lispify(constants, str, expected, undefined, true));\n  return createLisp<Expression>({ op: LispType.Expression, a: exprs, b: LispType.None });\n}\n\nexport function lispifyReturnExpr(constants: IConstants, str: CodeString) {\n  return createLisp<Return>({\n    op: LispType.Return,\n    a: LispType.None,\n    b: lispifyExpr(constants, str),\n  });\n}\n\nexport function lispifyBlock(str: CodeString, constants: IConstants, expression = false): Lisp[] {\n  str = insertSemicolons(constants, str);\n  if (!str.trim().length) return [];\n  const parts: CodeString[] = [];\n  let part: CodeString;\n  let pos = 0;\n  let start = 0;\n  let details: restDetails = {};\n  let skipped = false;\n  let isInserted = false;\n  while (\n    (part = restOfExp(\n      constants,\n      str.substring(pos),\n      [semiColon],\n      undefined,\n      undefined,\n      undefined,\n      details,\n    )).length\n  ) {\n    isInserted = !!(str.char(pos + part.length) && str.char(pos + part.length) !== ';');\n    pos += part.length + (isInserted ? 0 : 1);\n    if (/^\\s*else(?![\\w$])/.test(str.substring(pos).toString())) {\n      skipped = true;\n    } else if (\n      details['words']?.includes('do') &&\n      /^\\s*while(?![\\w$])/.test(str.substring(pos).toString())\n    ) {\n      skipped = true;\n    } else {\n      skipped = false;\n      parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n      start = pos;\n    }\n    details = {};\n    if (expression) break;\n  }\n  if (skipped) {\n    parts.push(str.substring(start, pos - (isInserted ? 0 : 1)));\n  }\n  return parts\n    .map((str) => str.trimStart())\n    .filter((str) => str.length)\n    .map((str) => {\n      return lispifyExpr(constants, str.trimStart(), startingExecpted);\n    });\n}\n\nexport function lispifyFunction(\n  str: CodeString,\n  constants: IConstants,\n  expression = false,\n): Lisp[] {\n  if (!str.trim().length) return [];\n  const tree = lispifyBlock(str, constants, expression);\n  hoist(tree);\n  return tree;\n}\n\nfunction hoist(item: LispItem, res: Lisp[] = []): boolean {\n  if (isLisp(item)) {\n    if (!isLisp<LispFamily>(item)) return false;\n    const [op, a, b] = item;\n    if (\n      op === LispType.Try ||\n      op === LispType.If ||\n      op === LispType.Loop ||\n      op === LispType.Switch\n    ) {\n      hoist(a, res);\n      hoist(b, res);\n    } else if (op === LispType.Var) {\n      res.push(createLisp({ op: LispType.Var, a: a, b: LispType.None }));\n    } else if (op === LispType.Function && a[1]) {\n      res.push(item);\n      return true;\n    }\n  } else if (Array.isArray(item)) {\n    const rep: LispItemSingle[] = [];\n    for (const it of item) {\n      if (!hoist(it, res)) {\n        rep.push(it);\n      }\n    }\n    if (rep.length !== item.length) {\n      item.length = 0;\n      item.push(...res, ...rep);\n    }\n  }\n  return false;\n}\n\nconst closingsNoInsertion = /^(\\})\\s*(catch|finally|else|while|instanceof)(?![\\w$])/;\n//  \\w|)|] \\n \\w = 2                                  // \\} \\w|\\{ = 5\nconst colonsRegex = /^((([\\w$\\])\"'`]|\\+\\+|--)\\s*\\r?\\n\\s*([\\w$+\\-!~]))|(\\}\\s*[\\w$!~+\\-{(\"'`]))/;\n\n// if () \\w \\n; \\w              == \\w \\n \\w    | last === if             a\n// if () { }; \\w                == \\} ^else    | last === if             b\n// if () \\w \\n; else \\n \\w \\n;  == \\w \\n \\w    | last === else           a\n// if () {} else {}; \\w         == \\} \\w       | last === else           b\n// while () \\n \\w \\n; \\w        == \\w \\n \\w    | last === while          a\n// while () { }; \\w             == \\} \\w       | last === while          b\n// do \\w \\n; while (); \\w       == \\w \\n while | last === do             a\n// do { } while (); \\w          == \\) \\w       | last === while          c\n// try {} catch () {}; \\w       == \\} \\w       | last === catch|finally  b\n// \\w \\n; \\w                    == \\w \\n \\w    | last === none           a\n// cb() \\n \\w                   == \\) \\n \\w    | last === none           a\n// obj[a] \\n \\w                 == \\] \\n \\w    | last === none           a\n// {} {}                        == \\} \\{       | last === none           b\n\nexport function insertSemicolons(constants: IConstants, str: CodeString): CodeString {\n  let rest = str;\n  let sub = emptyString;\n  let details: restDetails = {};\n  const inserted = insertedSemicolons.get(str.ref) || new Array(str.ref.str.length);\n  while (\n    (sub = restOfExp(constants, rest, [], undefined, undefined, [colonsRegex], details)).length\n  ) {\n    let valid = false;\n    let part = sub;\n    let edge = sub.length;\n    if (details.regRes) {\n      valid = true;\n      const [, , a, , , b] = details.regRes;\n      edge = details.regRes[3] === '++' || details.regRes[3] === '--' ? sub.length + 1 : sub.length;\n      part = rest.substring(0, edge);\n      if (b) {\n        const res = closingsNoInsertion.exec(rest.substring(sub.length - 1).toString());\n        if (res) {\n          if (res[2] === 'while') {\n            valid = details.lastWord !== 'do';\n          } else {\n            valid = false;\n          }\n        } else if (\n          details.lastWord === 'function' &&\n          details.regRes[5][0] === '}' &&\n          details.regRes[5].slice(-1) === '('\n        ) {\n          valid = false;\n        }\n      } else if (a) {\n        if (\n          details.lastWord === 'if' ||\n          details.lastWord === 'while' ||\n          details.lastWord === 'for' ||\n          details.lastWord === 'else'\n        ) {\n          valid = false;\n        }\n      }\n    }\n    if (valid) {\n      inserted[part.end] = true;\n    }\n    rest = rest.substring(edge);\n    details = {};\n  }\n  insertedSemicolons.set(str.ref, inserted);\n  return str;\n}\n\nexport function checkRegex(str: string): IRegEx | null {\n  let i = 1;\n  let escape = false;\n  let done = false;\n  let cancel = false;\n  while (i < str.length && !done && !cancel) {\n    done = str[i] === '/' && !escape;\n    escape = str[i] === '\\\\' && !escape;\n    cancel = str[i] === '\\n';\n    i++;\n  }\n  const after = str.substring(i);\n  cancel = cancel || !done || /^\\s*\\d/.test(after);\n  if (cancel) return null;\n  const flags = /^[a-z]*/.exec(after);\n  if (/^\\s+[\\w$]/.test(str.substring(i + flags![0].length))) {\n    return null;\n  }\n  return {\n    regex: str.substring(1, i - 1),\n    flags: (flags && flags[0]) || '',\n    length: i + ((flags && flags[0].length) || 0),\n  };\n}\n\nconst notDivide = /(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/;\nconst possibleDivide = /^([\\w$\\])]|\\+\\+|--)[\\s/]/;\nexport function extractConstants(\n  constants: IConstants,\n  str: string,\n  currentEnclosure = '',\n): { str: string; length: number } {\n  let quote;\n  let extract: (string | number)[] = [];\n  let escape = false;\n  let regexFound: IRegEx | null;\n  let comment = '';\n  let commentStart = -1;\n  let currJs: string[] = [];\n  let char = '';\n  const strRes: (string | number)[] = [];\n  const enclosures: string[] = [];\n  let isPossibleDivide: RegExpExecArray | null = null;\n  let i = 0;\n  for (i = 0; i < str.length; i++) {\n    char = str[i];\n    if (comment) {\n      if (char === comment) {\n        if (comment === '*' && str[i + 1] === '/') {\n          comment = '';\n          i++;\n        } else if (comment === '\\n') {\n          comment = '';\n        }\n      }\n    } else {\n      if (escape) {\n        escape = false;\n        extract.push(char);\n        continue;\n      }\n\n      if (quote) {\n        if (quote === '`' && char === '$' && str[i + 1] === '{') {\n          const skip = extractConstants(constants, str.substring(i + 2), '{');\n          currJs.push(skip.str);\n          extract.push('${', currJs.length - 1, `}`);\n          i += skip.length + 2;\n        } else if (quote === char) {\n          if (quote === '`') {\n            const li = createLisp<Literal>({\n              op: LispType.Literal,\n              a: unraw(extract.join('')),\n              b: [],\n            });\n            li.tempJsStrings = currJs;\n            constants.literals.push(li);\n            strRes.push(`\\``, constants.literals.length - 1, `\\``);\n          } else {\n            constants.strings.push(unraw(extract.join('')));\n            strRes.push(`\"`, constants.strings.length - 1, `\"`);\n          }\n          quote = null;\n          extract = [];\n        } else {\n          extract.push(char);\n        }\n      } else {\n        if (char === \"'\" || char === '\"' || char === '`') {\n          currJs = [];\n          quote = char;\n        } else if (closings[currentEnclosure] === char && !enclosures.length) {\n          return { str: strRes.join(''), length: i };\n        } else if (closings[char]) {\n          enclosures.push(char);\n          strRes.push(char);\n        } else if (closings[enclosures[enclosures.length - 1]] === char) {\n          enclosures.pop();\n          strRes.push(char);\n        } else if (char === '/' && (str[i + 1] === '*' || str[i + 1] === '/')) {\n          comment = str[i + 1] === '*' ? '*' : '\\n';\n          commentStart = i;\n        } else if (\n          char === '/' &&\n          !isPossibleDivide &&\n          (regexFound = checkRegex(str.substring(i)))\n        ) {\n          constants.regexes.push(regexFound);\n          strRes.push(`/`, constants.regexes.length - 1, `/r`);\n          i += regexFound.length - 1;\n        } else {\n          strRes.push(char);\n        }\n\n        if (!isPossibleDivide || !space.test(char)) {\n          if ((isPossibleDivide = possibleDivide.exec(str.substring(i)))) {\n            if (notDivide.test(str.substring(0, i + isPossibleDivide[1].length))) {\n              isPossibleDivide = null;\n            }\n          }\n        }\n      }\n      escape = !!(quote && char === '\\\\');\n    }\n  }\n\n  if (comment) {\n    if (comment === '*') {\n      throw new SyntaxError(`Unclosed comment '/*': ${str.substring(commentStart)}`);\n    }\n  }\n  return { str: strRes.join(''), length: i };\n}\n\nexport default function parse(code: string, eager = false, expression = false): IExecutionTree {\n  if (typeof code !== 'string') throw new ParseError(`Cannot parse ${code}`, code);\n  let str = ' ' + code;\n  const constants: IConstants = { strings: [], literals: [], regexes: [], eager };\n  str = extractConstants(constants, str).str;\n\n  for (const l of constants.literals) {\n    l[2] = l.tempJsStrings!.map((js: string) => lispifyExpr(constants, new CodeString(js)));\n    delete l.tempJsStrings;\n  }\n  return { tree: lispifyFunction(new CodeString(str), constants, expression), constants };\n}\n"],"names":[],"mappings":"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"}